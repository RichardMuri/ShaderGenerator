public class ColossalMight extends CardImpl {§public ColossalMight (UUID ownerId) {§super(ownerId, 51, "Colossal Might", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{R}{G}");§this.expansionSetCode = "ARB";§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new BoostTargetEffect(4, 2, Duration.EndOfTurn));§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(TrampleAbility.getInstance(), Duration.EndOfTurn));§}§public ColossalMight (final ColossalMight card) {§super(card);§}§@Override§public ColossalMight copy() {§return new ColossalMight(this);§}§}§
public class EtherwroughtPage extends CardImpl {§public EtherwroughtPage(UUID ownerId) {§super(ownerId, 108, "Etherwrought Page", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{1}{W}{U}{B}");§this.expansionSetCode = "ARB";§Ability ability = new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new GainLifeEffect(2), TargetController.YOU, false);§Mode mode = new Mode();§mode.getEffects().add(new EtherwroughtPageEffect());§ability.addMode(mode);§Mode mode1 = new Mode();§mode1.getEffects().add(new LoseLifeOpponentsEffect(1));§ability.addMode(mode1);§this.addAbility(ability);§}§public EtherwroughtPage(final EtherwroughtPage card) {§super(card);§}§@Override§public EtherwroughtPage copy() {§return new EtherwroughtPage(this);§}§}§class EtherwroughtPageEffect extends OneShotEffect {§public EtherwroughtPageEffect() {§super(Outcome.DrawCard);§this.staticText = "or look at the top card of your library, then you may put that card into your graveyard";§}§public EtherwroughtPageEffect(final EtherwroughtPageEffect effect) {§super(effect);§}§@Override§public EtherwroughtPageEffect copy() {§return new EtherwroughtPageEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null && controller.getLibrary().size() > 0) {§Card card = controller.getLibrary().getFromTop(game);§if (card != null) {§CardsImpl cards = new CardsImpl();§cards.add(card);§controller.lookAtCards("Etherwrought Page", cards, game);§if (controller.chooseUse(Outcome.Neutral, "Do you wish to put the card into your graveyard?", source, game)) {§return controller.moveCards(card, Zone.LIBRARY, Zone.GRAVEYARD, source, game);§}§return true;§}§}§return false;§}§}§
public class JenaraAsuraOfWar extends CardImpl {§public JenaraAsuraOfWar (UUID ownerId) {§super(ownerId, 128, "Jenara, Asura of War", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{G}{W}{U}");§this.expansionSetCode = "ARB";§this.subtype.add("Angel");§this.supertype.add("Legendary");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.P1P1.createInstance()), new ManaCostsImpl("{1}{W}")));§}§public JenaraAsuraOfWar (final JenaraAsuraOfWar card) {§super(card);§}§@Override§public JenaraAsuraOfWar copy() {§return new JenaraAsuraOfWar(this);§}§}§
public class MarisisTwinclaws extends CardImpl {§public MarisisTwinclaws (UUID ownerId) {§super(ownerId, 140, "Marisi's Twinclaws", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{R/W}{G}");§this.expansionSetCode = "ARB";§this.subtype.add("Cat");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(4);§this.addAbility(DoubleStrikeAbility.getInstance());§}§public MarisisTwinclaws (final MarisisTwinclaws card) {§super(card);§}§@Override§public MarisisTwinclaws copy() {§return new MarisisTwinclaws(this);§}§}§
public class QasaliPridemage extends CardImpl {§public QasaliPridemage(UUID ownerId) {§super(ownerId, 75, "Qasali Pridemage", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{G}{W}");§this.expansionSetCode = "ARB";§this.subtype.add("Cat");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new ExaltedAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new ManaCostsImpl("{1}"));§ability.addCost(new SacrificeSourceCost());§Target target = new TargetPermanent(new FilterArtifactOrEnchantmentPermanent());§ability.addTarget(target);§this.addAbility(ability);§}§public QasaliPridemage(final QasaliPridemage card) {§super(card);§}§@Override§public QasaliPridemage copy() {§return new QasaliPridemage(this);§}§}§
public class SpellboundDragon extends CardImpl {§public SpellboundDragon(UUID ownerId) {§super(ownerId, 90, "Spellbound Dragon", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{U}{R}");§this.expansionSetCode = "ARB";§this.subtype.add("Dragon");§this.power = new MageInt(3);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new AttacksTriggeredAbility(new SpellboundDragonEffect(), false));§}§public SpellboundDragon(final SpellboundDragon card) {§super(card);§}§@Override§public SpellboundDragon copy() {§return new SpellboundDragon(this);§}§}§class SpellboundDragonEffect extends OneShotEffect {§public SpellboundDragonEffect() {§super(Outcome.BoostCreature);§staticText = "draw a card, then discard a card. Spellbound Dragon gets +X/+0 until end of turn, where X is the discarded card's converted mana cost";§}§public SpellboundDragonEffect(final SpellboundDragonEffect effect) {§super(effect);§}§@Override§public SpellboundDragonEffect copy() {§return new SpellboundDragonEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player you = game.getPlayer(source.getControllerId());§Permanent dragon = game.getPermanent(source.getSourceId());§you.drawCards(1, game);§TargetDiscard target = new TargetDiscard(you.getId());§you.choose(Outcome.Discard, target, source.getSourceId(), game);§Card card = you.getHand().get(target.getFirstTarget(), game);§if (card != null && you.discard(card, source, game)) {§int cmc = card.getManaCost().convertedManaCost();§if (dragon != null) {§game.addEffect(new BoostSourceEffect(cmc, 0, Duration.EndOfTurn), source);§return true;§}§}§return false;§}§}§
public class VeinfireBorderpost extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledLandPermanent("a basic land");§static {§filter.add(new SupertypePredicate("Basic"));§}§public VeinfireBorderpost (UUID ownerId) {§super(ownerId, 48, "Veinfire Borderpost", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{1}{B}{R}");§this.expansionSetCode = "ARB";§Ability ability = new AlternativeCostSourceAbility(new GenericManaCost(1));§ability.addCost(new ReturnToHandChosenControlledPermanentCost(new TargetControlledPermanent(filter)));§this.addAbility(ability);§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new BlackManaAbility());§this.addAbility(new RedManaAbility());§}§public VeinfireBorderpost (final VeinfireBorderpost card) {§super(card);§}§@Override§public VeinfireBorderpost copy() {§return new VeinfireBorderpost(this);§}§}§
public class ElvishSpiritGuide extends CardImpl {§public ElvishSpiritGuide(UUID ownerId) {§super(ownerId, 69, "Elvish Spirit Guide", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "ALL";§this.subtype.add("Elf");§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SimpleManaAbility(Zone.HAND, new BasicManaEffect(Mana.GreenMana(1)), new ExileSourceFromHandCost()));§}§public ElvishSpiritGuide(final ElvishSpiritGuide card) {§super(card);§}§@Override§public ElvishSpiritGuide copy() {§return new ElvishSpiritGuide(this);§}§}§class ExileSourceFromHandCost extends CostImpl {§public ExileSourceFromHandCost() {§this.text = "Exile {this} from your hand";§}§public ExileSourceFromHandCost(ExileSourceFromHandCost cost) {§super(cost);§}§@Override§public boolean pay(Ability ability, Game game, UUID sourceId, UUID controllerId, boolean noMana, Cost costToPay) {§Card card = game.getCard(sourceId);§Player player = game.getPlayer(controllerId);§if (player != null && player.getHand().contains(sourceId) && card != null) {§paid = card.moveToExile(ability.getSourceId(), "from Hand", ability.getSourceId(), game);§}§return paid;§}§@Override§public boolean canPay(Ability ability, UUID sourceId, UUID controllerId, Game game) {§Player player = game.getPlayer(controllerId);§if (player != null && player.getHand().contains(sourceId)) {§return true;§}§return false;§}§@Override§public ExileSourceFromHandCost copy() {§return new ExileSourceFromHandCost(this);§}§}§
public class PhyrexianDevourer extends CardImpl {§public PhyrexianDevourer(UUID ownerId) {§super(ownerId, 167, "Phyrexian Devourer", Rarity.RARE, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{6}");§this.expansionSetCode = "ALL";§this.subtype.add("Construct");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new PhyrexianDevourerStateTriggeredAbility());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new PhyrexianDevourerEffect(), new ExileTopCardLibraryCost()));§}§public PhyrexianDevourer(final PhyrexianDevourer card) {§super(card);§}§@Override§public PhyrexianDevourer copy() {§return new PhyrexianDevourer(this);§}§}§class PhyrexianDevourerStateTriggeredAbility extends StateTriggeredAbility {§public PhyrexianDevourerStateTriggeredAbility() {§super(Zone.BATTLEFIELD, new SacrificeSourceEffect());§}§public PhyrexianDevourerStateTriggeredAbility(final PhyrexianDevourerStateTriggeredAbility ability) {§super(ability);§}§@Override§public PhyrexianDevourerStateTriggeredAbility copy() {§return new PhyrexianDevourerStateTriggeredAbility(this);§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent permanent = game.getPermanent(getSourceId());§return permanent != null && permanent.getPower().getValue() >= 7;§}§@Override§public String getRule() {§return "When {this}'s power is 7 or greater, sacrifice it.";§}§}§class PhyrexianDevourerEffect extends OneShotEffect {§public PhyrexianDevourerEffect() {§super(Outcome.BoostCreature);§this.staticText = "Put X +1/+1 counters on {this}, where X is the exiled card's converted mana cost";§}§public PhyrexianDevourerEffect(final PhyrexianDevourerEffect effect) {§super(effect);§}§@Override§public PhyrexianDevourerEffect copy() {§return new PhyrexianDevourerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Card card = null;§for (Cost cost : source.getCosts()) {§if (cost instanceof ExileTopCardLibraryCost) {§card = ((ExileTopCardLibraryCost) cost).getCard();§}§}§if (card != null) {§int amount = card.getManaCost().convertedManaCost();§if (amount > 0) {§return new AddCountersSourceEffect(CounterType.P1P1.createInstance(amount)).apply(game, source);§}§}§return true;§}§return false;§}§}§class ExileTopCardLibraryCost extends CostImpl {§Card card;§public ExileTopCardLibraryCost() {§this.text = "Exile the top card of your library";§}§public ExileTopCardLibraryCost(final ExileTopCardLibraryCost cost) {§super(cost);§this.card = cost.getCard();§}§@Override§public boolean pay(Ability ability, Game game, UUID sourceId, UUID controllerId, boolean noMana, Cost costToPay) {§Player controller = game.getPlayer(controllerId);§if (controller != null) {§card = controller.getLibrary().getFromTop(game);§if (card != null) {§paid = controller.moveCards(card, null, Zone.EXILED, ability, game);§}§}§return paid;§}§@Override§public boolean canPay(Ability ability, UUID sourceId, UUID controllerId, Game game) {§Player controller = game.getPlayer(controllerId);§if (controller != null) {§return controller.getLibrary().size() > 0;§}§return false;§}§@Override§public ExileTopCardLibraryCost copy() {§return new ExileTopCardLibraryCost(this);§}§public Card getCard() {§return card;§}§}§
public class TerrainGenerator extends CardImpl {§public TerrainGenerator(UUID ownerId) {§super(ownerId, 29, "Terrain Generator", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "DD3D";§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PutLandOnBattlefieldEffect(), new ManaCostsImpl("{2}"));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public TerrainGenerator(final TerrainGenerator card) {§super(card);§}§@Override§public TerrainGenerator copy() {§return new TerrainGenerator(this);§}§}§class PutLandOnBattlefieldEffect extends OneShotEffect {§private static final FilterCard filter = new FilterCard("card other than a basic land card");§static {§filter.add(Predicates.and(new CardTypePredicate(CardType.LAND), new SupertypePredicate("Basic")));§}§private static final String choiceText = "Put a basic land card from your hand onto the battlefield?";§public PutLandOnBattlefieldEffect() {§super(Outcome.PutLandInPlay);§this.staticText = "put a basic land card from your hand onto the battlefield";§}§public PutLandOnBattlefieldEffect(final PutLandOnBattlefieldEffect effect) {§super(effect);§}§@Override§public PutLandOnBattlefieldEffect copy() {§return new PutLandOnBattlefieldEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player == null || !player.chooseUse(Outcome.PutLandInPlay, choiceText, source, game)) {§return false;§}§TargetCardInHand target = new TargetCardInHand(filter);§if (player.choose(Outcome.PutLandInPlay, target, source.getSourceId(), game)) {§Card card = game.getCard(target.getFirstTarget());§if (card != null) {§card.putOntoBattlefield(game, Zone.HAND, source.getSourceId(), source.getControllerId());§Permanent permanent = game.getPermanent(card.getId());§if (permanent != null) {§permanent.setTapped(true);§}§return true;§}§}§return false;§}§}§
public class Reconstruction extends CardImpl {§public Reconstruction(UUID ownerId) {§super(ownerId, 56, "Reconstruction", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{U}");§this.expansionSetCode = "ATQ";§this.getSpellAbility().addEffect(new ReturnToHandTargetEffect());§this.getSpellAbility().addTarget(new TargetCardInYourGraveyard(new FilterArtifactCard("artifact card from your graveyard")));§}§public Reconstruction(final Reconstruction card) {§super(card);§}§@Override§public Reconstruction copy() {§return new Reconstruction(this);§}§}§
public class DeadRingers extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("nonblack creature");§static {§filter.add(Predicates.not(new ColorPredicate(ObjectColor.BLACK)));§}§public DeadRingers(UUID ownerId) {§super(ownerId, 37, "Dead Ringers", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{4}{B}");§this.expansionSetCode = "APC";§this.getSpellAbility().addEffect(new DeadRingersEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent(2, 2, filter, false));§}§public DeadRingers(final DeadRingers card) {§super(card);§}§@Override§public DeadRingers copy() {§return new DeadRingers(this);§}§}§class DeadRingersEffect extends DestroyTargetEffect {§public DeadRingersEffect() {§super(true);§staticText = "Destroy two target nonblack creatures unless either one is a color the other isn't. They can't be regenerated.";§}§public DeadRingersEffect(final DeadRingersEffect effect) {§super(effect);§}§@Override§public DeadRingersEffect copy() {§return new DeadRingersEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Target target = source.getTargets().get(0);§Permanent first = game.getPermanentOrLKIBattlefield(target.getTargets().get(0));§Permanent second = game.getPermanentOrLKIBattlefield(target.getTargets().get(1));§if(first != null && second != null && first.getColor(game).equals(second.getColor(game))) {§return super.apply(game, source);§}§return false;§}§}§
public class GaeasSkyfolk extends CardImpl {§public GaeasSkyfolk(UUID ownerId) {§super(ownerId, 101, "Gaea's Skyfolk", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{G}{U}");§this.expansionSetCode = "APC";§this.subtype.add("Elf");§this.subtype.add("Merfolk");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§}§public GaeasSkyfolk(final GaeasSkyfolk card) {§super(card);§}§@Override§public GaeasSkyfolk copy() {§return new GaeasSkyfolk(this);§}§}§
public class LightningAngel extends CardImpl {§public LightningAngel(UUID ownerId) {§super(ownerId, 108, "Lightning Angel", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{R}{W}{U}");§this.expansionSetCode = "APC";§this.subtype.add("Angel");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(HasteAbility.getInstance());§}§public LightningAngel(final LightningAngel card) {§super(card);§}§@Override§public LightningAngel copy() {§return new LightningAngel(this);§}§}§
public class PhyrexianGargantua extends CardImpl {§public PhyrexianGargantua(UUID ownerId) {§super(ownerId, 48, "Phyrexian Gargantua", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{B}{B}");§this.expansionSetCode = "APC";§this.subtype.add("Horror");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§Ability ability = new EntersBattlefieldTriggeredAbility(new DrawCardSourceControllerEffect(2), false);§ability.addEffect(new LoseLifeSourceControllerEffect(2));§this.addAbility(ability);§}§public PhyrexianGargantua(final PhyrexianGargantua card) {§super(card);§}§@Override§public PhyrexianGargantua copy() {§return new PhyrexianGargantua(this);§}§}§
public class SuffocatingBlast extends CardImpl {§public SuffocatingBlast(UUID ownerId) {§super(ownerId, 124, "Suffocating Blast", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{1}{U}{U}{R}");§this.expansionSetCode = "APC";§this.getSpellAbility().addEffect(new CounterTargetEffect());§this.getSpellAbility().addTarget(new TargetSpell());§Effect effect = new DamageTargetEffect(3);§effect.setText("and {this} deals 3 damage to target creature");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public SuffocatingBlast(final SuffocatingBlast card) {§super(card);§}§@Override§public SuffocatingBlast copy() {§return new SuffocatingBlast(this);§}§}§
public class BazaarOfBaghdad extends CardImpl {§public BazaarOfBaghdad(UUID ownerId) {§super(ownerId, 84, "Bazaar of Baghdad", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "ARN";§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawDiscardControllerEffect(2, 3), new TapSourceCost()));§}§public BazaarOfBaghdad(final BazaarOfBaghdad card) {§super(card);§}§@Override§public BazaarOfBaghdad copy() {§return new BazaarOfBaghdad(this);§}§}§
public class Skullcage extends CardImpl {§public Skullcage(UUID ownerId) {§super(ownerId, 115, "Skullcage", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "ARC";§this.addAbility(new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new SkullcageEffect(), TargetController.OPPONENT, false, true));§}§public Skullcage(final Skullcage card) {§super(card);§}§@Override§public Skullcage copy() {§return new Skullcage(this);§}§}§class SkullcageEffect extends OneShotEffect {§public SkullcageEffect() {§super(Outcome.Damage);§staticText = "{source} deals 2 damage to that player unless he or she has exactly three or exactly four cards in hand";§}§public SkullcageEffect(final SkullcageEffect effect) {§super(effect);§}§@Override§public SkullcageEffect copy() {§return new SkullcageEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(getTargetPointer().getFirst(game, source));§if (player != null) {§if(player.getHand().size() != 3 && player.getHand().size() != 4){§player.damage(2, source.getSourceId(), game, false, true);§}§}§return false;§}§}§
public class BarterInBlood extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("creature");§static {§filter.add(new CardTypePredicate(CardType.CREATURE));§}§public BarterInBlood(UUID ownerId) {§super(ownerId, 85, "Barter in Blood", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{2}{B}{B}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new SacrificeAllEffect(2, filter));§}§public BarterInBlood(final BarterInBlood card) {§super(card);§}§@Override§public BarterInBlood copy() {§return new BarterInBlood(this);§}§}§
public class ConjurersCloset extends CardImpl {§public ConjurersCloset(UUID ownerId) {§super(ownerId, 214, "Conjurer's Closet", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{5}");§this.expansionSetCode = "AVR";§Ability ability = new BeginningOfYourEndStepTriggeredAbility(new ExileTargetForSourceEffect(), true);§ability.addEffect(new ReturnToBattlefieldUnderYourControlTargetEffect(true));§ability.addTarget(new TargetControlledCreaturePermanent());§this.addAbility(ability);§}§public ConjurersCloset(final ConjurersCloset card) {§super(card);§}§@Override§public ConjurersCloset copy() {§return new ConjurersCloset(this);§}§}§
public class DiregrafEscort extends CardImpl {§private static final String ruleText = "As long as {this} is paired with another creature, both creatures have protection from Zombies";§private static final FilterPermanent filter = new FilterCreaturePermanent("Zombies");§static {§filter.add(new SubtypePredicate("Zombie"));§}§public DiregrafEscort(UUID ownerId) {§super(ownerId, 174, "Diregraf Escort", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(SoulbondAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityPairedEffect(new ProtectionAbility(filter), ruleText)));§}§public DiregrafEscort(final DiregrafEscort card) {§super(card);§}§@Override§public DiregrafEscort copy() {§return new DiregrafEscort(this);§}§}§
public class FloweringLumberknot extends CardImpl {§public FloweringLumberknot(UUID ownerId) {§super(ownerId, 178, "Flowering Lumberknot", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "AVR";§this.subtype.add("Treefolk");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new FloweringLumberknotEffect()));§}§public FloweringLumberknot(final FloweringLumberknot card) {§super(card);§}§@Override§public FloweringLumberknot copy() {§return new FloweringLumberknot(this);§}§}§class FloweringLumberknotEffect extends RestrictionEffect {§public FloweringLumberknotEffect() {§super(Duration.WhileOnBattlefield);§staticText = "{this} can't attack or block unless it's paired with a creature with soulbond";§}§public FloweringLumberknotEffect(final FloweringLumberknotEffect effect) {§super(effect);§}§@Override§public boolean applies(Permanent permanent, Ability source, Game game) {§if (permanent.getId().equals(source.getSourceId())) {§if (permanent.getPairedCard() == null) {§return true; §
public class HanweirLancer extends CardImpl {§private static final String ruleText = "As long as {this} is paired with another creature, both creatures have first strike";§public HanweirLancer(UUID ownerId) {§super(ownerId, 138, "Hanweir Lancer", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Knight");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(SoulbondAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityPairedEffect(FirstStrikeAbility.getInstance(), ruleText)));§}§public HanweirLancer(final HanweirLancer card) {§super(card);§}§@Override§public HanweirLancer copy() {§return new HanweirLancer(this);§}§}§
public class LatchSeeker extends CardImpl {§public LatchSeeker(UUID ownerId) {§super(ownerId, 63, "Latch Seeker", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{U}{U}");§this.expansionSetCode = "AVR";§this.subtype.add("Spirit");§this.power = new MageInt(3);§this.toughness = new MageInt(1);§this.addAbility(new CantBeBlockedSourceAbility());§}§public LatchSeeker(final LatchSeeker card) {§super(card);§}§@Override§public LatchSeeker copy() {§return new LatchSeeker(this);§}§}§
public class NarstadScrapper extends CardImpl {§public NarstadScrapper(UUID ownerId) {§super(ownerId, 218, "Narstad Scrapper", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{5}");§this.expansionSetCode = "AVR";§this.subtype.add("Construct");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 0, Duration.EndOfTurn), new GenericManaCost(2)));§}§public NarstadScrapper(final NarstadScrapper card) {§super(card);§}§@Override§public NarstadScrapper copy() {§return new NarstadScrapper(this);§}§}§
public class RevengeOfTheHunted extends CardImpl {§public RevengeOfTheHunted(UUID ownerId) {§super(ownerId, 191, "Revenge of the Hunted", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{4}{G}{G}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new BoostTargetEffect(6, 6, Duration.EndOfTurn));§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(TrampleAbility.getInstance(), Duration.EndOfTurn));§Effect effect = new MustBeBlockedByAllTargetEffect(Duration.EndOfTurn);§effect.setText("and all creatures able to block it this turn do so");§this.getSpellAbility().addEffect(effect);§this.addAbility(new MiracleAbility(this, new ManaCostsImpl("{G}")));§}§public RevengeOfTheHunted(final RevengeOfTheHunted card) {§super(card);§}§@Override§public RevengeOfTheHunted copy() {§return new RevengeOfTheHunted(this);§}§}§
public class SomberwaldSage extends CardImpl {§public SomberwaldSage(UUID ownerId) {§super(ownerId, 194, "Somberwald Sage", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Druid");§this.power = new MageInt(0);§this.toughness = new MageInt(1);§this.addAbility(new ConditionalAnyColorManaAbility(new TapSourceCost(), 3, new SomberwaldSageManaBuilder(), true));§}§public SomberwaldSage(final SomberwaldSage card) {§super(card);§}§@Override§public SomberwaldSage copy() {§return new SomberwaldSage(this);§}§}§class SomberwaldSageManaBuilder extends ConditionalManaBuilder {§@Override§public ConditionalMana build(Object... options) {§return new CreatureCastConditionalMana(this.mana);§}§@Override§public String getRule() {§return "Spend this mana only to cast creature spells";§}§}§
public class TimberlandGuide extends CardImpl {§public TimberlandGuide(UUID ownerId) {§super(ownerId, 197, "Timberland Guide", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Scout");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new EntersBattlefieldTriggeredAbility(new AddCountersTargetEffect(CounterType.P1P1.createInstance()));§TargetCreaturePermanent target = new TargetCreaturePermanent();§ability.addTarget(target);§this.addAbility(ability);§}§public TimberlandGuide(final TimberlandGuide card) {§super(card);§}§@Override§public TimberlandGuide copy() {§return new TimberlandGuide(this);§}§}§
public class WildwoodGeist extends CardImpl {§public WildwoodGeist(UUID ownerId) {§super(ownerId, 204, "Wildwood Geist", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{G}");§this.expansionSetCode = "AVR";§this.subtype.add("Spirit");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(§new BoostSourceEffect(2, 2, Duration.WhileOnBattlefield),§MyTurnCondition.getInstance(),§"{this} gets +2/+2 as long as it's your turn")));§}§public WildwoodGeist(final WildwoodGeist card) {§super(card);§}§@Override§public WildwoodGeist copy() {§return new WildwoodGeist(this);§}§}§
public class BenthicInfiltrator extends CardImpl {§public BenthicInfiltrator(UUID ownerId) {§super(ownerId, 55, "Benthic Infiltrator", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Drone");§this.power = new MageInt(1);§this.toughness = new MageInt(4);§this.addAbility(new DevoidAbility(this.color));§this.addAbility(new IngestAbility());§this.addAbility(new CantBeBlockedSourceAbility());§}§public BenthicInfiltrator(final BenthicInfiltrator card) {§super(card);§}§@Override§public BenthicInfiltrator copy() {§return new BenthicInfiltrator(this);§}§}§
public class CatacombSifter extends CardImpl {§private final static FilterCreaturePermanent filter = new FilterCreaturePermanent("another creature you control");§static {§filter.add(new AnotherPredicate());§filter.add(new ControllerPredicate(TargetController.YOU));§}§public CatacombSifter(UUID ownerId) {§super(ownerId, 201, "Catacomb Sifter", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{B}{G}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Drone");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(new DevoidAbility(this.color));§this.addAbility(new EntersBattlefieldTriggeredAbility(new CreateTokenEffect(new EldraziScionToken())));§this.addAbility(new DiesCreatureTriggeredAbility(new ScryEffect(1), false, filter));§}§public CatacombSifter(final CatacombSifter card) {§super(card);§}§@Override§public CatacombSifter copy() {§return new CatacombSifter(this);§}§}§
public class DranaLiberatorOfMalakir extends CardImpl {§private static final FilterAttackingCreature filter = new FilterAttackingCreature("each attacking creature you control");§static {§filter.add(new ControllerPredicate(TargetController.YOU));§}§public DranaLiberatorOfMalakir(UUID ownerId) {§super(ownerId, 109, "Drana, Liberator of Malakir", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{1}{B}{B}");§this.expansionSetCode = "BFZ";§this.supertype.add("Legendary");§this.subtype.add("Vampire");§this.subtype.add("Ally");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(FirstStrikeAbility.getInstance());§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(new AddCountersAllEffect(CounterType.P1P1.createInstance(), filter), false));§}§public DranaLiberatorOfMalakir(final DranaLiberatorOfMalakir card) {§super(card);§}§@Override§public DranaLiberatorOfMalakir copy() {§return new DranaLiberatorOfMalakir(this);§}§}§
public class GhostlySentinel extends CardImpl {§public GhostlySentinel(UUID ownerId) {§super(ownerId, 28, "Ghostly Sentinel", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{W}");§this.expansionSetCode = "BFZ";§this.subtype.add("Kor");§this.subtype.add("Spirit");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(VigilanceAbility.getInstance());§}§public GhostlySentinel(final GhostlySentinel card) {§super(card);§}§@Override§public GhostlySentinel copy() {§return new GhostlySentinel(this);§}§}§
public class JaddiOffshoot extends CardImpl {§public JaddiOffshoot(UUID ownerId) {§super(ownerId, 176, "Jaddi Offshoot", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "BFZ";§this.subtype.add("Plant");§this.power = new MageInt(0);§this.toughness = new MageInt(3);§this.addAbility(DefenderAbility.getInstance());§this.addAbility(new LandfallAbility(new GainLifeEffect(1), false));§}§public JaddiOffshoot(final JaddiOffshoot card) {§super(card);§}§@Override§public JaddiOffshoot copy() {§return new JaddiOffshoot(this);§}§}§
public class MindRaker extends CardImpl {§public MindRaker(UUID ownerId) {§super(ownerId, 95, "Mind Raker", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{B}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Processor");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new DevoidAbility(this.color));§this.addAbility(new EntersBattlefieldTriggeredAbility(§new DoIfCostPaid(new DiscardEachPlayerEffect(TargetController.OPPONENT), new ExileOpponentsCardFromExileToGraveyardCost(true)), false));§}§public MindRaker(final MindRaker card) {§super(card);§}§@Override§public MindRaker copy() {§return new MindRaker(this);§}§}§
public class OranRiefHydra extends CardImpl {§public OranRiefHydra(UUID ownerId) {§super(ownerId, 181, "Oran-Rief Hydra", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{G}{G}");§this.expansionSetCode = "BFZ";§this.subtype.add("Hydra");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new OranRiefHydraTriggeredAbility());§}§public OranRiefHydra(final OranRiefHydra card) {§super(card);§}§@Override§public OranRiefHydra copy() {§return new OranRiefHydra(this);§}§}§class OranRiefHydraTriggeredAbility extends TriggeredAbilityImpl {§private static final String text = "<i>Landfall</i> - Whenever a land enters the battlefield under your control, put a +1/+1 counter on {this}. "§+ "If that land is a Forest, put two +1/+1 counters on {this} instead.";§public OranRiefHydraTriggeredAbility() {§super(Zone.BATTLEFIELD, new OranRiefHydraEffect());§}§public OranRiefHydraTriggeredAbility(final OranRiefHydraTriggeredAbility ability) {§super(ability);§}§@Override§public OranRiefHydraTriggeredAbility copy() {§return new OranRiefHydraTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.ENTERS_THE_BATTLEFIELD;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent permanent = game.getPermanent(event.getTargetId());§if (permanent != null§&& permanent.getCardType().contains(CardType.LAND)§&& permanent.getControllerId().equals(getControllerId())) {§Permanent sourcePermanent = game.getPermanent(getSourceId());§if (sourcePermanent != null) {§for (Effect effect : getEffects()) {§if (effect instanceof OranRiefHydraEffect) {§effect.setTargetPointer(new FixedTarget(permanent, game));§}§return true;§}§}§}§return false;§}§@Override§public String getRule() {§return text;§}§}§class OranRiefHydraEffect extends OneShotEffect {§public OranRiefHydraEffect() {§super(Outcome.BoostCreature);§}§public OranRiefHydraEffect(final OranRiefHydraEffect effect) {§super(effect);§}§@Override§public OranRiefHydraEffect copy() {§return new OranRiefHydraEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent land = game.getPermanentOrLKIBattlefield(getTargetPointer().getFirst(game, source));§Permanent sourcePermanent = game.getPermanent(source.getSourceId());§if (land != null && sourcePermanent != null) {§if (land.hasSubtype("Forest")) {§sourcePermanent.addCounters(CounterType.P1P1.createInstance(2), game);§} else {§sourcePermanent.addCounters(CounterType.P1P1.createInstance(), game);§}§return true;§}§return false;§}§}§
public class RisingMiasma extends CardImpl {§public RisingMiasma(UUID ownerId) {§super(ownerId, 122, "Rising Miasma", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{3}{B}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().addEffect(new BoostAllEffect(-2, -2, Duration.EndOfTurn));§this.addAbility(new AwakenAbility(this, 3, "{5}{B}{B}"));§}§public RisingMiasma(final RisingMiasma card) {§super(card);§}§@Override§public RisingMiasma copy() {§return new RisingMiasma(this);§}§}§
public class ShatterskullRecruit extends CardImpl {§public ShatterskullRecruit(UUID ownerId) {§super(ownerId, 155, "Shatterskull Recruit", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{R}{R}");§this.expansionSetCode = "BFZ";§this.subtype.add("Giant");§this.subtype.add("Warrior");§this.subtype.add("Ally");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new MenaceAbility());§}§public ShatterskullRecruit(final ShatterskullRecruit card) {§super(card);§}§@Override§public ShatterskullRecruit copy() {§return new ShatterskullRecruit(this);§}§}§
public class SwellOfGrowth extends CardImpl {§public SwellOfGrowth(UUID ownerId) {§super(ownerId, 191, "Swell of Growth", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{G}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().addEffect(new BoostTargetEffect(2, 2, Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new PutLandFromHandOntoBattlefieldEffect());§}§public SwellOfGrowth(final SwellOfGrowth card) {§super(card);§}§@Override§public SwellOfGrowth copy() {§return new SwellOfGrowth(this);§}§}§
public class ValakutInvoker extends CardImpl {§public ValakutInvoker(UUID ownerId) {§super(ownerId, 159, "Valakut Invoker", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "BFZ";§this.subtype.add("Human");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(3), new GenericManaCost(8));§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public ValakutInvoker(final ValakutInvoker card) {§super(card);§}§@Override§public ValakutInvoker copy() {§return new ValakutInvoker(this);§}§}§
public class BileUrchin extends CardImpl {§public BileUrchin(UUID ownerId) {§super(ownerId, 61, "Bile Urchin", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{B}");§this.expansionSetCode = "BOK";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new LoseLifeTargetEffect(1), new SacrificeSourceCost());§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public BileUrchin(final BileUrchin card) {§super(card);§}§@Override§public BileUrchin copy() {§return new BileUrchin(this);§}§}§
public class FaithfulSquire extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public FaithfulSquire(UUID ownerId) {§super(ownerId, 3, "Faithful Squire", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{W}{W}");§this.expansionSetCode = "BOK";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.flipCard = true;§this.flipCardName = "Kaiso, Memory of Loyalty";§this.addAbility(new SpellCastControllerTriggeredAbility(new AddCountersSourceEffect(CounterType.KI.createInstance()), filter, true));§this.addAbility(new ConditionalTriggeredAbility(§new OnEventTriggeredAbility(GameEvent.EventType.END_TURN_STEP_PRE, "beginning of the end step", true, new FlipSourceEffect(new KaisoMemoryOfLoyalty())),§new SourceHasCounterCondition(CounterType.KI, 2, Integer.MAX_VALUE),§"At the beginning of the end step, if there are two or more ki counters on {this}, you may flip it."));§}§public FaithfulSquire(final FaithfulSquire card) {§super(card);§}§@Override§public FaithfulSquire copy() {§return new FaithfulSquire(this);§}§}§class KaisoMemoryOfLoyalty extends Token {§KaisoMemoryOfLoyalty() {§super("Kaiso, Memory of Loyalty", "");§supertype.add("Legendary");§cardType.add(CardType.CREATURE);§color.setWhite(true);§subtype.add("Spirit");§power = new MageInt(3);§toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(§Zone.BATTLEFIELD,§new PreventDamageToTargetEffect(Duration.EndOfTurn, Integer.MAX_VALUE),§new RemoveCountersSourceCost(CounterType.KI.createInstance()));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§}§
public class HeartlessHidetsugu extends CardImpl {§public HeartlessHidetsugu(UUID ownerId) {§super(ownerId, 107, "Heartless Hidetsugu", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{R}{R}");§this.expansionSetCode = "BOK";§this.supertype.add("Legendary");§this.subtype.add("Ogre");§this.subtype.add("Shaman");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new HeartlessHidetsuguDamageEffect(), new TapSourceCost()));§}§public HeartlessHidetsugu(final HeartlessHidetsugu card) {§super(card);§}§@Override§public HeartlessHidetsugu copy() {§return new HeartlessHidetsugu(this);§}§}§class HeartlessHidetsuguDamageEffect extends OneShotEffect {§public HeartlessHidetsuguDamageEffect() {§super(Outcome.Detriment);§this.staticText = "{this} deals damage to each player equal to half that player's life total, rounded down";§}§public HeartlessHidetsuguDamageEffect(final HeartlessHidetsuguDamageEffect effect) {§super(effect);§}§@Override§public HeartlessHidetsuguDamageEffect copy() {§return new HeartlessHidetsuguDamageEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§int damage = player.getLife() / 2;§player.damage(damage, source.getSourceId(), game, false, true);§}§}§return true;§}§return false;§}§}§
public class KamiOfTheHonoredDead extends CardImpl {§public KamiOfTheHonoredDead(UUID ownerId) {§super(ownerId, 12, "Kami of the Honored Dead", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{5}{W}{W}");§this.expansionSetCode = "BOK";§this.subtype.add("Spirit");§this.power = new MageInt(3);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new KamiOfTheHonoredDeadTriggeredAbility());§this.addAbility(new SoulshiftAbility(6));§}§public KamiOfTheHonoredDead(final KamiOfTheHonoredDead card) {§super(card);§}§@Override§public KamiOfTheHonoredDead copy() {§return new KamiOfTheHonoredDead(this);§}§}§class KamiOfTheHonoredDeadTriggeredAbility extends TriggeredAbilityImpl {§public KamiOfTheHonoredDeadTriggeredAbility() {§super(Zone.BATTLEFIELD, new KamiOfTheHonoredDeadGainLifeEffect());§}§public KamiOfTheHonoredDeadTriggeredAbility(final KamiOfTheHonoredDeadTriggeredAbility effect) {§super(effect);§}§@Override§public KamiOfTheHonoredDeadTriggeredAbility copy() {§return new KamiOfTheHonoredDeadTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_CREATURE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getTargetId().equals(this.sourceId)) {§this.getEffects().get(0).setValue("damageAmount", event.getAmount());§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever {this} is dealt damage, " + super.getRule();§}§}§class KamiOfTheHonoredDeadGainLifeEffect extends OneShotEffect {§public KamiOfTheHonoredDeadGainLifeEffect() {§super(Outcome.GainLife);§staticText = "you gain that much life";§}§public KamiOfTheHonoredDeadGainLifeEffect(final KamiOfTheHonoredDeadGainLifeEffect effect) {§super(effect);§}§@Override§public KamiOfTheHonoredDeadGainLifeEffect copy() {§return new KamiOfTheHonoredDeadGainLifeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§player.gainLife((Integer) this.getValue("damageAmount"), game);§}§return true;§}§}§
public class NekoTe extends CardImpl {§public NekoTe(UUID ownerId) {§super(ownerId, 155, "Neko-Te", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "BOK";§this.subtype.add("Equipment");§ContinuousRuleModifyingEffect skipUntapEffect = new DontUntapInControllersUntapStepTargetEffect(Duration.WhileOnBattlefield);§skipUntapEffect.setText("That creature doesn't untap during its controller's untap step for as long as {this} remains on the battlefield");§ConditionalContinuousRuleModifyingEffect effect = new ConditionalContinuousRuleModifyingEffect(skipUntapEffect, new SourceOnBattlefieldCondition());§Ability ability = new DealsDamageToACreatureAttachedTriggeredAbility(new TapTargetEffect("that creature"), false, "equipped creature", false, true);§ability.addEffect(effect);§this.addAbility(ability);§this.addAbility(new DealsDamageToAPlayerAttachedTriggeredAbility(new LoseLifeTargetEffect(1), "equipped creature", false, true, false));§this.addAbility(new EquipAbility(Outcome.Benefit, new GenericManaCost(2)));§}§public NekoTe(final NekoTe card) {§super(card);§}§@Override§public NekoTe copy() {§return new NekoTe(this);§}§}§
public class PusKami extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("nonblack creature");§static {§filter.add(Predicates.not(new ColorPredicate(ObjectColor.BLACK)));§}§public PusKami(UUID ownerId) {§super(ownerId, 79, "Pus Kami", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{5}{B}{B}");§this.expansionSetCode = "BOK";§this.subtype.add("Spirit");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new ColoredManaCost(ColoredManaSymbol.B));§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§this.addAbility(new SoulshiftAbility(6));§}§public PusKami(final PusKami card) {§super(card);§}§@Override§public PusKami copy() {§return new PusKami(this);§}§}§
public class SickeningShoal extends CardImpl {§public SickeningShoal(UUID ownerId) {§super(ownerId, 82, "Sickening Shoal", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{X}{B}{B}");§this.expansionSetCode = "BOK";§this.subtype.add("Arcane");§FilterOwnedCard filter = new FilterOwnedCard("a black card with converted mana cost X from your hand");§filter.add(new ColorPredicate(ObjectColor.BLACK));§filter.add(Predicates.not(new CardIdPredicate(this.getId()))); §
public class ThatWhichWasTaken extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("permanent other than That Which Was Taken");§private static final FilterPermanent filterIndestructible = new FilterPermanent("Each permanent with a divinity counter on it");§static {§filter.add(new AnotherPredicate());§filterIndestructible.add(new CounterPredicate(CounterType.DIVINITY));§}§public ThatWhichWasTaken(UUID ownerId) {§super(ownerId, 162, "That Which Was Taken", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{5}");§this.expansionSetCode = "BOK";§this.supertype.add("Legendary");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersTargetEffect(CounterType.DIVINITY.createInstance()), new GenericManaCost(4));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§Effect effect = new GainAbilityAllEffect(IndestructibleAbility.getInstance(), Duration.WhileOnBattlefield, filterIndestructible, false);§effect.setText("Each permanent with a divinity counter on it is indestructible");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD,§effect));§}§public ThatWhichWasTaken(final ThatWhichWasTaken card) {§super(card);§}§@Override§public ThatWhichWasTaken copy() {§return new ThatWhichWasTaken(this);§}§}§
public class MindbreakerDemon extends CardImpl {§public MindbreakerDemon(UUID ownerId) {§super(ownerId, 41, "Mindbreaker Demon", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{2}{B}{B}");§this.expansionSetCode = "DDQ";§this.subtype.add("Demon");§this.power = new MageInt(4);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new PutTopCardOfLibraryIntoGraveControllerEffect(4)));§this.addAbility(new ConditionalTriggeredAbility(§new BeginningOfUpkeepTriggeredAbility(new LoseLifeSourceControllerEffect(4), TargetController.YOU, false),§new TwentyGraveyardCreatureCondition(),§"At the beginning of your upkeep, if you don't have 4 or more card types in your graveyard, you lose 4 life."));§}§public MindbreakerDemon(final MindbreakerDemon card) {§super(card);§}§@Override§public MindbreakerDemon copy() {§return new MindbreakerDemon(this);§}§}§class TwentyGraveyardCreatureCondition implements Condition {§private static final FilterCreatureCard filter = new FilterCreatureCard();§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§MageObject target = game.getObject(source.getSourceId());§if (target != null) {§HashSet<CardType> foundCardTypes = new HashSet<>();§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§for (Card card : player.getGraveyard().getCards(game)) {§foundCardTypes.addAll(card.getCardType());§}§}§}§int number = foundCardTypes.size();§return number < 4;§}§}§return false;§}§}§
public class ChampionOfStraySouls extends CardImpl {§private final UUID originalId;§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("other creatures");§static {§filter.add(new AnotherPredicate());§}§public ChampionOfStraySouls(UUID ownerId) {§super(ownerId, 63, "Champion of Stray Souls", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{4}{B}{B}");§this.expansionSetCode = "BNG";§this.subtype.add("Skeleton");§this.subtype.add("Warrior");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§/**§* You choose the targets of the first ability as you activate that§* ability, before you pay any costs. You can't target any of the§* creatures you sacrifice.§*/§Effect effect = new ReturnFromGraveyardToBattlefieldTargetEffect();§effect.setText("Return X target creatures from your graveyard to the battlefield");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl("{3}{B}{B}"));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeXTargetCost(filter));§ability.addTarget(new TargetCardInYourGraveyard(0, Integer.MAX_VALUE, new FilterCreatureCard("creature cards from your graveyard")));§originalId = ability.getOriginalId();§this.addAbility(ability);§this.addAbility(new SimpleActivatedAbility(Zone.GRAVEYARD,§new PutOnLibrarySourceEffect(true, "Put {this} on top of your library from your graveyard"),§new ManaCostsImpl("{5}{B}{B}")));§}§@Override§public void adjustTargets(Ability ability, Game game) {§if (ability.getOriginalId().equals(originalId)) {§for (Effect effect : ability.getEffects()) {§if (effect instanceof ReturnFromGraveyardToBattlefieldTargetEffect) {§int xValue = new GetXValue().calculate(game, ability, null);§ability.getTargets().clear();§ability.addTarget(new TargetCardInYourGraveyard(xValue, xValue, new FilterCreatureCard("creature cards from your graveyard")));§}§}§}§}§public ChampionOfStraySouls(final ChampionOfStraySouls card) {§super(card);§this.originalId = card.originalId;§}§@Override§public ChampionOfStraySouls copy() {§return new ChampionOfStraySouls(this);§}§}§
public class EverflameEidolon extends CardImpl {§public EverflameEidolon(UUID ownerId) {§super(ownerId, 92, "Everflame Eidolon", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "BNG";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new BestowAbility(this, "{2}{R}"));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new EverflameEidolonEffect(), new ManaCostsImpl("{R}")));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(1, 1, Duration.WhileOnBattlefield)));§}§public EverflameEidolon(final EverflameEidolon card) {§super(card);§}§@Override§public EverflameEidolon copy() {§return new EverflameEidolon(this);§}§}§class EverflameEidolonEffect extends OneShotEffect {§public EverflameEidolonEffect() {§super(Outcome.BoostCreature);§this.staticText = "{this} gets +1/+0 until end of turn. If it's an Aura, enchanted creature gets +1/+0 until end of turn instead";§}§public EverflameEidolonEffect(final EverflameEidolonEffect effect) {§super(effect);§}§@Override§public EverflameEidolonEffect copy() {§return new EverflameEidolonEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent sourceObject = game.getPermanentOrLKIBattlefield(source.getSourceId());§if (sourceObject != null) {§if (sourceObject.getSubtype().contains("Aura")) {§new BoostEnchantedEffect(1, 0, Duration.EndOfTurn).apply(game, source);§} else {§game.addEffect(new BoostSourceEffect(1, 0, Duration.EndOfTurn), source);§}§return true;§}§return false;§}§}§
public class GhostbladeEidolon extends CardImpl {§public GhostbladeEidolon(UUID ownerId) {§super(ownerId, 12, "Ghostblade Eidolon", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "BNG";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new BestowAbility(this, "{5}{W}"));§this.addAbility(DoubleStrikeAbility.getInstance());§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(1,1));§Effect effect = new GainAbilityAttachedEffect(DoubleStrikeAbility.getInstance(), AttachmentType.AURA, Duration.WhileOnBattlefield);§effect.setText("and has double strike");§ability.addEffect(effect);§this.addAbility(ability);§}§public GhostbladeEidolon(final GhostbladeEidolon card) {§super(card);§}§@Override§public GhostbladeEidolon copy() {§return new GhostbladeEidolon(this);§}§}§
public class KragmaButcher extends CardImpl {§public KragmaButcher(UUID ownerId) {§super(ownerId, 100, "Kragma Butcher", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "BNG";§this.subtype.add("Minotaur");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§Effect effect = new BoostSourceEffect(2,0, Duration.EndOfTurn);§effect.setText("it gets +2/+0 until end of turn");§this.addAbility(new InspiredAbility(effect));§}§public KragmaButcher(final KragmaButcher card) {§super(card);§}§@Override§public KragmaButcher copy() {§return new KragmaButcher(this);§}§}§
public class OdunosRiverTrawler extends CardImpl {§private static final FilterCard filter = new FilterCard("enchantment creature card from your graveyard");§static {§filter.add(new CardTypePredicate(CardType.ENCHANTMENT));§filter.add(new CardTypePredicate(CardType.CREATURE));§}§public OdunosRiverTrawler(UUID ownerId) {§super(ownerId, 79, "Odunos River Trawler", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "BNG";§this.subtype.add("Zombie");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new EntersBattlefieldTriggeredAbility(new ReturnFromGraveyardToHandTargetEffect());§ability.addTarget(new TargetCardInYourGraveyard(filter));§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ReturnFromGraveyardToHandTargetEffect(), new ManaCostsImpl("{W}"));§ability.addTarget(new TargetCardInYourGraveyard(filter));§this.addAbility(ability);§}§public OdunosRiverTrawler(final OdunosRiverTrawler card) {§super(card);§}§@Override§public OdunosRiverTrawler copy() {§return new OdunosRiverTrawler(this);§}§}§
public class RiseToTheChallenge extends CardImpl {§public RiseToTheChallenge(UUID ownerId) {§super(ownerId, 107, "Rise to the Challenge", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{R}");§this.expansionSetCode = "BNG";§Effect effect = new BoostTargetEffect(2,0, Duration.EndOfTurn);§effect.setText("Target creature gets +2/+0");§this.getSpellAbility().addEffect(effect);§effect = new GainAbilityTargetEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn);§effect.setText("and gains first strike until end of turn");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public RiseToTheChallenge(final RiseToTheChallenge card) {§super(card);§}§@Override§public RiseToTheChallenge copy() {§return new RiseToTheChallenge(this);§}§}§
public class SpitefulReturned extends CardImpl {§public SpitefulReturned(UUID ownerId) {§super(ownerId, 84, "Spiteful Returned", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "BNG";§this.subtype.add("Zombie");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new BestowAbility(this, "{3}{B}"));§Effect effect = new LoseLifeTargetEffect(2);§effect.setText("defending player loses 2 life");§this.addAbility(new SpitefulReturnedTriggeredAbility(effect));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(1, 1, Duration.WhileOnBattlefield)));§}§public SpitefulReturned(final SpitefulReturned card) {§super(card);§}§@Override§public SpitefulReturned copy() {§return new SpitefulReturned(this);§}§}§class SpitefulReturnedTriggeredAbility extends TriggeredAbilityImpl {§public SpitefulReturnedTriggeredAbility(Effect effect) {§super(Zone.BATTLEFIELD, effect);§}§public SpitefulReturnedTriggeredAbility(final SpitefulReturnedTriggeredAbility ability) {§super(ability);§}§@Override§public SpitefulReturnedTriggeredAbility copy() {§return new SpitefulReturnedTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ATTACKER_DECLARED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent sourcePermanent = game.getPermanent(this.getSourceId());§if (sourcePermanent != null) {§if (sourcePermanent.getCardType().contains(CardType.CREATURE)) {§if (event.getSourceId() != null§&& event.getSourceId().equals(this.getSourceId())) {§UUID defender = game.getCombat().getDefendingPlayerId(this.getSourceId(), game);§this.getEffects().get(0).setTargetPointer(new FixedTarget(defender));§return true;§}§} else {§if (sourcePermanent.getAttachedTo() != null && sourcePermanent.getAttachedTo().equals(event.getSourceId())) {§UUID defender = game.getCombat().getDefendingPlayerId(sourcePermanent.getAttachedTo(), game);§this.getEffects().get(0).setTargetPointer(new FixedTarget(defender));§return true;§}§}§}§return false;§}§@Override§public String getRule() {§return new StringBuilder("Whenever {this} or enchanted creature attacks, ").append(super.getRule()).toString();§}§}§
public class WhimsOfTheFates extends CardImpl {§public WhimsOfTheFates(UUID ownerId) {§super(ownerId, 115, "Whims of the Fates", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{5}{R}");§this.expansionSetCode = "BNG";§this.getSpellAbility().addEffect(new WhimsOfTheFateEffect());§}§public WhimsOfTheFates(final WhimsOfTheFates card) {§super(card);§}§@Override§public WhimsOfTheFates copy() {§return new WhimsOfTheFates(this);§}§}§class WhimsOfTheFateEffect extends OneShotEffect {§protected static Random rnd = new Random();§public WhimsOfTheFateEffect() {§super(Outcome.Detriment);§this.staticText = "Starting with you, each player separates all permanents he or she controls into three piles. Then each player chooses one of his or her piles at random and sacrifices those permanents.";§}§public WhimsOfTheFateEffect(final WhimsOfTheFateEffect effect) {§super(effect);§}§@Override§public WhimsOfTheFateEffect copy() {§return new WhimsOfTheFateEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Map<UUID, Map<Integer, Set<UUID>>> playerPermanents = new LinkedHashMap<>();§PlayerList playerList = game.getState().getPlayerList().copy();§while (!playerList.get().equals(source.getControllerId()) && controller.canRespond()) {§playerList.getNext();§}§Player currentPlayer = game.getPlayer(playerList.get());§Player nextPlayer;§UUID firstNextPlayer = null;§while (!getNextPlayerInDirection(true, playerList, game).equals(firstNextPlayer) && controller.canRespond()) {§nextPlayer = game.getPlayer(playerList.get());§if (nextPlayer == null) {§return false;§}§if (firstNextPlayer == null) {§firstNextPlayer = nextPlayer.getId();§}§if (!nextPlayer.canRespond()) {§continue;§}§if (currentPlayer != null && game.getState().getPlayersInRange(controller.getId(), game).contains(currentPlayer.getId())) {§Map<Integer, Set<UUID>> playerPiles = new HashMap<>();§for (int i = 1; i < 4; i++) {§playerPiles.put(i, new LinkedHashSet<UUID>());§}§playerPermanents.put(currentPlayer.getId(), playerPiles);§for (int i = 1; i < 3; i++) {§FilterPermanent filter = new FilterPermanent(§new StringBuilder("the permanents for the ").append(i == 1 ? "first " : "second ").append("pile").toString());§filter.add(new ControllerIdPredicate(currentPlayer.getId()));§Target target;§if (i == 1) {§target = new TargetPermanent(0, Integer.MAX_VALUE, filter, true);§} else {§target = new TargetSecondPilePermanent(playerPiles.get(1), filter);§}§target.setRequired(false);§currentPlayer.chooseTarget(outcome, target, source, game);§StringBuilder message = new StringBuilder(currentPlayer.getLogName()).append(" pile ").append(i).append(": ");§if (target.getTargets().isEmpty()) {§message.append(" (empty)");§} else {§for (UUID permanentId : target.getTargets()) {§Permanent permanent = game.getPermanent(permanentId);§if (permanent != null) {§message.append(permanent.getName()).append(" ");§}§}§}§game.informPlayers(message.toString());§playerPiles.get(i).addAll(target.getTargets());§}§StringBuilder message = new StringBuilder(currentPlayer.getLogName()).append(" pile 3: ");§for (Permanent permanent : game.getState().getBattlefield().getAllActivePermanents(currentPlayer.getId())) {§if (!playerPiles.get(1).contains(permanent.getId()) && !playerPiles.get(2).contains(permanent.getId())) {§playerPiles.get(3).add(permanent.getId());§message.append(permanent.getName()).append(" ");§}§}§if (playerPiles.get(3).isEmpty()) {§message.append(" (empty)");§}§game.informPlayers(message.toString());§}§currentPlayer = nextPlayer;§}§for (Map.Entry<UUID, Map<Integer, Set<UUID>>> playerPiles : playerPermanents.entrySet()) {§Player player = game.getPlayer(playerPiles.getKey());§if (player != null) {§int sacrificePile = rnd.nextInt(3) + 1; §
public class BrutalDeceiver extends CardImpl {§public BrutalDeceiver(UUID ownerId) {§super(ownerId, 161, "Brutal Deceiver", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new LookLibraryControllerEffect(), new GenericManaCost(1)));§Ability ability = new BrutalDeceiverAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1,0,Duration.EndOfTurn), new ManaCostsImpl("{2}"));§ability.addEffect(new GainAbilitySourceEffect(FirstStrikeAbility.getInstance(),Duration.EndOfTurn));§this.addAbility(ability);§}§public BrutalDeceiver(final BrutalDeceiver card) {§super(card);§}§@Override§public BrutalDeceiver copy() {§return new BrutalDeceiver(this);§}§}§class BrutalDeceiverAbility extends LimitedTimesPerTurnActivatedAbility {§public BrutalDeceiverAbility(Zone zone, Effect effect, Cost cost) {§super(zone, effect, cost);§}§public BrutalDeceiverAbility(BrutalDeceiverAbility ability) {§super(ability);§}§@Override§public BrutalDeceiverAbility copy() {§return new BrutalDeceiverAbility(this);§}§@Override§public boolean checkIfClause(Game game) {§Player player = game.getPlayer(this.getControllerId());§if (player != null) {§Cards cards = new CardsImpl();§Card card = player.getLibrary().getFromTop(game);§cards.add(card);§player.revealCards("Brutal Deceiver", cards, game);§if (card != null && card.getCardType().contains(CardType.LAND)) {§return true;§}§}§return false;§}§@Override§public String getRule() {§return "{2}: Reveal the top card of your library. If it's a land card, {this} gets +1/+0 and gains first strike until end of turn. Activate this ability only once each turn.";§}§}§
public class DevotedRetainer extends CardImpl {§public DevotedRetainer (UUID ownerId) {§super(ownerId, 7, "Devoted Retainer", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Human");§this.subtype.add("Samurai");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new BushidoAbility(1));§}§public DevotedRetainer (final DevotedRetainer card) {§super(card);§}§@Override§public DevotedRetainer copy() {§return new DevotedRetainer(this);§}§}§
public class GhostlyPrison extends CardImpl {§public GhostlyPrison(UUID ownerId) {§super(ownerId, 10, "Ghostly Prison", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{W}");§this.expansionSetCode = "CHK";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CantAttackYouUnlessPayManaAllEffect(new ManaCostsImpl("{2}"))));§}§public GhostlyPrison(final GhostlyPrison card) {§super(card);§}§@Override§public GhostlyPrison copy() {§return new GhostlyPrison(this);§}§}§
public class HisokaMinamoSensei extends CardImpl {§public HisokaMinamoSensei(UUID ownerId) {§super(ownerId, 66, "Hisoka, Minamo Sensei", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{U}{U}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new HisokaMinamoSenseiCounterEffect(), new ManaCostsImpl("{2}{U}"));§ability.addTarget(new TargetSpell());§TargetCardInHand targetCard = new TargetCardInHand(new FilterCard("a card"));§ability.addCost(new HisokaMinamoSenseiDiscardTargetCost(targetCard));§this.addAbility(ability);§}§public HisokaMinamoSensei(final HisokaMinamoSensei card) {§super(card);§}§@Override§public HisokaMinamoSensei copy() {§return new HisokaMinamoSensei(this);§}§}§class HisokaMinamoSenseiDiscardTargetCost extends CostImpl {§protected Card card = null;§public HisokaMinamoSenseiDiscardTargetCost(TargetCardInHand target) {§this.addTarget(target);§this.text = "Discard " + target.getTargetName();§}§public HisokaMinamoSenseiDiscardTargetCost(HisokaMinamoSenseiDiscardTargetCost cost) {§super(cost);§}§@Override§public boolean pay(Ability ability, Game game, UUID sourceId, UUID controllerId, boolean noMana, Cost costToPay) {§if (targets.choose(Outcome.Discard, controllerId, sourceId, game)) {§Player player = game.getPlayer(controllerId);§for (UUID targetId: targets.get(0).getTargets()) {§card = player.getHand().get(targetId, game);§if (card == null) {§return false;§}§paid |= player.discard(card, null, game);§}§}§return paid;§}§@Override§public boolean canPay(Ability ability, UUID sourceId, UUID controllerId, Game game) {§return targets.canChoose(controllerId, game);§}§@Override§public HisokaMinamoSenseiDiscardTargetCost copy() {§return new HisokaMinamoSenseiDiscardTargetCost(this);§}§public Card getDiscardedCard() {§return card;§}§}§class HisokaMinamoSenseiCounterEffect extends OneShotEffect {§HisokaMinamoSenseiCounterEffect() {§super(Outcome.Detriment);§staticText = "Counter target spell if it has the same converted mana cost as the discarded card";§}§HisokaMinamoSenseiCounterEffect(final HisokaMinamoSenseiCounterEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Spell spell = game.getStack().getSpell(targetPointer.getFirst(game, source));§if (spell != null) {§HisokaMinamoSenseiDiscardTargetCost cost = (HisokaMinamoSenseiDiscardTargetCost) source.getCosts().get(0);§if (cost != null && CardUtil.convertedManaCostsIsEqual(cost.getDiscardedCard(), spell)) {§return game.getStack().counter(targetPointer.getFirst(game, source), source.getSourceId(), game);§}§}§return false;§}§@Override§public HisokaMinamoSenseiCounterEffect copy() {§return new HisokaMinamoSenseiCounterEffect(this);§}§}§
public class IsamaruHoundofKonda extends CardImpl {§public IsamaruHoundofKonda (UUID ownerId) {§super(ownerId, 19, "Isamaru, Hound of Konda", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{W}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Hound");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§}§public IsamaruHoundofKonda (final IsamaruHoundofKonda card) {§super(card);§}§@Override§public IsamaruHoundofKonda copy() {§return new IsamaruHoundofKonda(this);§}§}§
public class KeigaTheTideStar extends CardImpl {§public KeigaTheTideStar(UUID ownerId) {§super(ownerId, 72, "Keiga, the Tide Star", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{U}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Dragon");§this.subtype.add("Spirit");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new DiesTriggeredAbility(new GainControlTargetEffect(Duration.Custom));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public KeigaTheTideStar(final KeigaTheTideStar card) {§super(card);§}§@Override§public KeigaTheTideStar copy() {§return new KeigaTheTideStar(this);§}§}§
public class LanternLitGraveyard extends CardImpl {§public LanternLitGraveyard(UUID ownerId) {§super(ownerId, 278, "Lantern-Lit Graveyard", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "CHK";§this.addAbility(new ColorlessManaAbility());§Ability blackManaAbility = new BlackManaAbility();§blackManaAbility.addEffect(new DontUntapInControllersNextUntapStepSourceEffect());§this.addAbility(blackManaAbility);§Ability redManaAbility = new RedManaAbility();§redManaAbility.addEffect(new DontUntapInControllersNextUntapStepSourceEffect());§this.addAbility(redManaAbility);§}§public LanternLitGraveyard(final LanternLitGraveyard card) {§super(card);§}§@Override§public LanternLitGraveyard copy() {§return new LanternLitGraveyard(this);§}§}§
public class MyojinOfSeeingWinds extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("permanent you control");§static {§filter.add(new ControllerPredicate(TargetController.YOU));§}§public MyojinOfSeeingWinds(UUID ownerId) {§super(ownerId, 75, "Myojin of Seeing Winds", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{7}{U}{U}{U}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Spirit");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.getSpellAbility().addWatcher(new CastFromHandWatcher());§this.addAbility(new EntersBattlefieldAbility(new ConditionalOneShotEffect(new AddCountersSourceEffect(CounterType.DIVINITY.createInstance()), new CastFromHandCondition(), ""), "{this} enters the battlefield with a divinity counter on it if you cast it from your hand"));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(new GainAbilitySourceEffect(IndestructibleAbility.getInstance(), Duration.WhileOnBattlefield),§new SourceHasCounterCondition(CounterType.DIVINITY), "{this} is indestructible as long as it has a divinity counter on it")));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(new PermanentsOnBattlefieldCount(filter, 1)), new RemoveCountersSourceCost(CounterType.DIVINITY.createInstance()));§this.addAbility(ability);§}§public MyojinOfSeeingWinds(final MyojinOfSeeingWinds card) {§super(card);§}§@Override§public MyojinOfSeeingWinds copy() {§return new MyojinOfSeeingWinds(this);§}§}§
public class OrochiEggwatcher extends CardImpl {§public OrochiEggwatcher(UUID ownerId) {§super(ownerId, 233, "Orochi Eggwatcher", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Snake");§this.subtype.add("Shaman");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.flipCard = true;§this.flipCardName = "Shidako, Broodmistress";§Ability ability;§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CreateTokenEffect(new SnakeToken()),new ManaCostsImpl("{2}{G}"));§ability.addCost(new TapSourceCost());§ability.addEffect(new ConditionalOneShotEffect(new FlipSourceEffect(new ShidakoBroodmistress()),§new PermanentsOnTheBattlefieldCondition(new FilterControlledCreaturePermanent(),PermanentsOnTheBattlefieldCondition.CountType.MORE_THAN, 9),"If you control ten or more creatures, flip {this}"));§this.addAbility(ability);§}§public OrochiEggwatcher(final OrochiEggwatcher card) {§super(card);§}§@Override§public OrochiEggwatcher copy() {§return new OrochiEggwatcher(this);§}§}§class ShidakoBroodmistress extends Token {§ShidakoBroodmistress() {§super("Shidako, Broodmistress", "");§supertype.add("Legendary");§cardType.add(CardType.CREATURE);§color.setGreen(true);§subtype.add("Snake");§subtype.add("Shaman");§power = new MageInt(3);§toughness = new MageInt(3);§Ability ability;§ability = new SimpleActivatedAbility(§Zone.BATTLEFIELD,§new BoostTargetEffect(3,3, Duration.EndOfTurn),§new ManaCostsImpl("{G}"));§ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent()));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§}§
public class RendFlesh extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Non-Spirit");§static {§filter.add(Predicates.not(new SubtypePredicate("Spirit")));§}§public RendFlesh(UUID ownerId) {§super(ownerId, 140, "Rend Flesh", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§Target target = new TargetCreaturePermanent(filter);§this.getSpellAbility().addTarget(target);§this.getSpellAbility().addEffect(new DestroyTargetEffect());§}§public RendFlesh(final RendFlesh card) {§super(card);§}§@Override§public RendFlesh copy() {§return new RendFlesh(this);§}§}§
public class ShinkaTheBloodsoakedKeep extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("legendary creature");§static {§filter.add(new SupertypePredicate("Legendary"));§}§public ShinkaTheBloodsoakedKeep(UUID ownerId) {§super(ownerId, 282, "Shinka, the Bloodsoaked Keep", Rarity.RARE, new CardType[]{CardType.LAND}, null);§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.addAbility(new RedManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilityTargetEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn), new ColoredManaCost(ColoredManaSymbol.R));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§}§public ShinkaTheBloodsoakedKeep(final ShinkaTheBloodsoakedKeep card) {§super(card);§}§@Override§public ShinkaTheBloodsoakedKeep copy() {§return new ShinkaTheBloodsoakedKeep(this);§}§}§
public class StrengthOfCedars extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledLandPermanent("the number of lands you control");§public StrengthOfCedars (UUID ownerId) {§super(ownerId, 245, "Strength of Cedars", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{4}{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§DynamicValue controlledLands = new PermanentsOnBattlefieldCount(filter, null);§this.getSpellAbility().addEffect(new BoostTargetEffect(controlledLands, controlledLands, Duration.EndOfTurn, true));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public StrengthOfCedars (final StrengthOfCedars card) {§super(card);§}§@Override§public StrengthOfCedars copy() {§return new StrengthOfCedars(this);§}§}§
public class UntaidakeTheCloudKeeper extends CardImpl {§public UntaidakeTheCloudKeeper(UUID ownerId) {§super(ownerId, 285, "Untaidake, the Cloud Keeper", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.addAbility(new EntersBattlefieldTappedAbility());§Ability ability = new ConditionalColorlessManaAbility(new TapSourceCost(), 2, new LegendarySpellManaBuilder());§ability.addCost(new PayLifeCost(2));§this.addAbility(ability);§}§public UntaidakeTheCloudKeeper(final UntaidakeTheCloudKeeper card) {§super(card);§}§@Override§public UntaidakeTheCloudKeeper copy() {§return new UntaidakeTheCloudKeeper(this);§}§}§class LegendarySpellManaBuilder extends ConditionalManaBuilder {§@Override§public ConditionalMana build(Object... options) {§return new LegendaryCastConditionalMana(this.mana);§}§@Override§public String getRule() {§return "Spend this mana only to cast legendary spells";§}§}§class LegendaryCastConditionalMana extends ConditionalMana {§public LegendaryCastConditionalMana(Mana mana) {§super(mana);§staticText = "Spend this mana only to cast legendary spells";§addCondition(new LegendaryCastManaCondition());§}§}§class LegendaryCastManaCondition extends ManaCondition implements Condition {§@Override§public boolean apply(Game game, Ability source) {§if (source instanceof SpellAbility) {§MageObject object = game.getObject(source.getSourceId());§if (object != null && object.getSupertype().contains("Legendary")) {§return true;§}§}§return false;§}§@Override§public boolean apply(Game game, Ability source, UUID originalId, Cost costsToPay) {§return apply(game, source);§}§}§
public class ArcticFlats extends CardImpl {§public ArcticFlats(UUID ownerId) {§super(ownerId, 143, "Arctic Flats", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "CSP";§this.supertype.add("Snow");§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new GreenManaAbility());§this.addAbility(new WhiteManaAbility());§}§public ArcticFlats(final ArcticFlats card) {§super(card);§}§@Override§public ArcticFlats copy() {§return new ArcticFlats(this);§}§}§
public class DiscipleOfTeveshSzat extends CardImpl {§public DiscipleOfTeveshSzat(UUID ownerId) {§super(ownerId, 55, "Disciple of Tevesh Szat", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B}{B}");§this.expansionSetCode = "CSP";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(3);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(-1, -1, Duration.EndOfTurn), new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(-6, -6, Duration.EndOfTurn), new ManaCostsImpl("{4}{B}{B}"));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public DiscipleOfTeveshSzat(final DiscipleOfTeveshSzat card) {§super(card);§}§@Override§public DiscipleOfTeveshSzat copy() {§return new DiscipleOfTeveshSzat(this);§}§}§
public class KjeldoranGargoyle extends CardImpl {§public KjeldoranGargoyle(UUID ownerId) {§super(ownerId, 10, "Kjeldoran Gargoyle", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{5}{W}");§this.expansionSetCode = "CSP";§this.subtype.add("Gargoyle");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(FirstStrikeAbility.getInstance());§this.addAbility(new DealsDamageGainLifeSourceTriggeredAbility());§}§public KjeldoranGargoyle(final KjeldoranGargoyle card) {§super(card);§}§@Override§public KjeldoranGargoyle copy() {§return new KjeldoranGargoyle(this);§}§}§
public class PhyrexianSoulgorger extends CardImpl {§public PhyrexianSoulgorger(UUID ownerId) {§super(ownerId, 141, "Phyrexian Soulgorger", Rarity.RARE, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{3}");§this.expansionSetCode = "CSP";§this.supertype.add("Snow");§this.subtype.add("Construct");§this.power = new MageInt(8);§this.toughness = new MageInt(8);§this.addAbility(new CumulativeUpkeepAbility(new SacrificeTargetCost(new TargetControlledCreaturePermanent(new FilterControlledCreaturePermanent("a creature")))));§}§public PhyrexianSoulgorger(final PhyrexianSoulgorger card) {§super(card);§}§@Override§public PhyrexianSoulgorger copy() {§return new PhyrexianSoulgorger(this);§}§}§
public class SurgingAEther extends CardImpl {§public SurgingAEther(UUID ownerId) {§super(ownerId, 47, "Surging AEther", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{3}{U}");§this.expansionSetCode = "CSP";§this.addAbility(new RippleAbility(4));§this.getSpellAbility().addEffect(new ReturnToHandTargetEffect());§this.getSpellAbility().addTarget(new TargetPermanent());§}§public SurgingAEther(final SurgingAEther card) {§super(card);§}§@Override§public SurgingAEther copy() {§return new SurgingAEther(this);§}§}§
public class AuraShards extends CardImpl {§public AuraShards(UUID ownerId) {§super(ownerId, 182, "Aura Shards", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{G}{W}");§this.expansionSetCode = "CMD";§Ability ability = new EntersBattlefieldControlledTriggeredAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new FilterCreaturePermanent(), true, "Whenever a creature enters the battlefield under your control, you may destroy target artifact or enchantment");§ability.addTarget(new TargetPermanent(new FilterArtifactOrEnchantmentPermanent()));§this.addAbility(ability);§}§public AuraShards(final AuraShards card) {§super(card);§}§@Override§public AuraShards copy() {§return new AuraShards(this);§}§}§
public class EdricSpymasterOfTrest extends CardImpl {§public EdricSpymasterOfTrest(UUID ownerId) {§super(ownerId, 196, "Edric, Spymaster of Trest", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{G}{U}");§this.expansionSetCode = "CMD";§this.supertype.add("Legendary");§this.subtype.add("Elf");§this.subtype.add("Rogue");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new EdricSpymasterOfTrestTriggeredAbility());§}§public EdricSpymasterOfTrest(final EdricSpymasterOfTrest card) {§super(card);§}§@Override§public EdricSpymasterOfTrest copy() {§return new EdricSpymasterOfTrest(this);§}§}§class EdricSpymasterOfTrestTriggeredAbility extends TriggeredAbilityImpl {§public EdricSpymasterOfTrestTriggeredAbility() {§super(Zone.BATTLEFIELD, new DrawCardTargetEffect(1, true), false);§}§public EdricSpymasterOfTrestTriggeredAbility(final EdricSpymasterOfTrestTriggeredAbility ability) {§super(ability);§}§@Override§public EdricSpymasterOfTrestTriggeredAbility copy() {§return new EdricSpymasterOfTrestTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_PLAYER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (((DamagedPlayerEvent) event).isCombatDamage() &&§game.getOpponents(this.controllerId).contains(((DamagedPlayerEvent) event).getPlayerId())) {§for (Effect effect : this.getEffects()) {§effect.setTargetPointer(new FixedTarget(game.getPermanent(event.getSourceId()).getControllerId()));§}§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever a creature deals combat damage to one of your opponents, its controller may draw a card";§}§}§
public class Mulldrifter extends CardImpl {§public Mulldrifter(UUID ownerId) {§super(ownerId, 52, "Mulldrifter", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{U}");§this.expansionSetCode = "CMD";§this.subtype.add("Elemental");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new DrawCardSourceControllerEffect(2)));§this.addAbility(new EvokeAbility(this, "{2}{U}"));§}§public Mulldrifter(final Mulldrifter card) {§super(card);§}§@Override§public Mulldrifter copy() {§return new Mulldrifter(this);§}§}§
public class SpurnmageAdvocate extends CardImpl {§private static final FilterCard filter = new FilterCard("two target cards from an opponent's graveyard");§static {§filter.add(new OwnerPredicate(TargetController.OPPONENT));§}§public SpurnmageAdvocate(UUID ownerId) {§super(ownerId, 33, "Spurnmage Advocate", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{W}");§this.expansionSetCode = "CMD";§this.subtype.add("Human");§this.subtype.add("Nomad");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ReturnToHandTargetEffect(), new TapSourceCost());§ability.addTarget(new TargetCardInASingleGraveyard(2, 2, filter));§Effect effect = new DestroyTargetEffect();§effect.setTargetPointer(new SecondTargetPointer());§ability.addEffect(effect);§ability.addTarget(new TargetAttackingCreature());§this.addAbility(ability);§}§public SpurnmageAdvocate(final SpurnmageAdvocate card) {§super(card);§}§@Override§public SpurnmageAdvocate copy() {§return new SpurnmageAdvocate(this);§}§}§
public class WhirlpoolWhelm extends CardImpl {§public WhirlpoolWhelm(UUID ownerId) {§super(ownerId, 69, "Whirlpool Whelm", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "CMD";§this.getSpellAbility().addEffect(new WhirlpoolWhelmEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public WhirlpoolWhelm(final WhirlpoolWhelm card) {§super(card);§}§@Override§public WhirlpoolWhelm copy() {§return new WhirlpoolWhelm(this);§}§}§class WhirlpoolWhelmEffect extends OneShotEffect {§public WhirlpoolWhelmEffect() {§super(Outcome.ReturnToHand);§this.staticText = "Clash with an opponent, then return target creature to its owner's hand. If you win, you may put that creature on top of its owner's library instead";§}§public WhirlpoolWhelmEffect(final WhirlpoolWhelmEffect effect) {§super(effect);§}§@Override§public WhirlpoolWhelmEffect copy() {§return new WhirlpoolWhelmEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Permanent creature = game.getPermanent(getTargetPointer().getFirst(game, source));§if (controller != null) {§boolean topOfLibrary = false;§if (ClashEffect.getInstance().apply(game, source)) {§topOfLibrary = controller.chooseUse(outcome, "Put " + creature.getLogName() + " to top of libraray instead?", source, game);§}§if (topOfLibrary) {§controller.moveCardToLibraryWithInfo(creature, source.getSourceId(), game, Zone.BATTLEFIELD, true, true);§} else {§controller.moveCards(creature, null, Zone.HAND, source, game);§}§return true;§}§return false;§}§}§
public class CurseOfPredation extends CardImpl {§public CurseOfPredation(UUID ownerId) {§super(ownerId, 140, "Curse of Predation", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{G}");§this.expansionSetCode = "C13";§this.subtype.add("Aura");§this.subtype.add("Curse");§TargetPlayer auraTarget = new TargetPlayer();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));§this.addAbility(new EnchantAbility(auraTarget.getTargetName()));§this.addAbility(new CurseOfPredationTriggeredAbility());§}§public CurseOfPredation(final CurseOfPredation card) {§super(card);§}§@Override§public CurseOfPredation copy() {§return new CurseOfPredation(this);§}§}§class CurseOfPredationTriggeredAbility extends TriggeredAbilityImpl {§public CurseOfPredationTriggeredAbility() {§super(Zone.BATTLEFIELD, new AddCountersTargetEffect(CounterType.P1P1.createInstance(), Outcome.BoostCreature), false);§}§public CurseOfPredationTriggeredAbility(Effect effect, boolean optional, String text) {§super(Zone.BATTLEFIELD, effect, optional);§}§public CurseOfPredationTriggeredAbility(final CurseOfPredationTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ATTACKER_DECLARED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Player defender = game.getPlayer(event.getTargetId());§if (defender == null) {§Permanent planeswalker = game.getPermanent(event.getTargetId());§if (planeswalker != null) {§defender = game.getPlayer(planeswalker.getControllerId());§}§}§if (defender != null) {§Permanent enchantment = game.getPermanent(this.getSourceId());§if (enchantment != null§&& enchantment.getAttachedTo() != null§&& enchantment.getAttachedTo().equals(defender.getId())) {§for (Effect effect: this.getEffects()) {§effect.setTargetPointer(new FixedTarget(event.getSourceId()));§}§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever a creature attacks enchanted player, put a +1/+1 counter on it.";§}§@Override§public CurseOfPredationTriggeredAbility copy() {§return new CurseOfPredationTriggeredAbility(this);§}§}§
public class Greed extends CardImpl {§public Greed(UUID ownerId) {§super(ownerId, 79, "Greed", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{3}{B}");§this.expansionSetCode = "C13";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1), new ManaCostsImpl("{B}"));§ability.addCost(new PayLifeCost(2));§this.addAbility(ability);§}§public Greed(final Greed card) {§super(card);§}§@Override§public Greed copy() {§return new Greed(this);§}§}§
public class MurkfiendLiege extends CardImpl {§private static final FilterCreaturePermanent filterGreen = new FilterCreaturePermanent("green creatures");§private static final FilterCreaturePermanent filterBlue = new FilterCreaturePermanent("blue creatures");§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("green and/or blue creatures you control");§static {§filterGreen.add(new ColorPredicate(ObjectColor.GREEN));§filterBlue.add(new ColorPredicate(ObjectColor.BLUE));§filter.add(Predicates.or(new ColorPredicate(ObjectColor.GREEN), new ColorPredicate(ObjectColor.BLUE)));§}§public MurkfiendLiege(UUID ownerId) {§super(ownerId, 231, "Murkfiend Liege", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{G/U}{G/U}{G/U}");§this.expansionSetCode = "C13";§this.subtype.add("Horror");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostControlledEffect(1,1, Duration.WhileOnBattlefield, filterGreen, true)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostControlledEffect(1,1, Duration.WhileOnBattlefield, filterBlue, true)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new UntapAllDuringEachOtherPlayersUntapStepEffect(filter)));§}§public MurkfiendLiege(final MurkfiendLiege card) {§super(card);§}§@Override§public MurkfiendLiege copy() {§return new MurkfiendLiege(this);§}§}§
public class SaltcrustedSteppe extends CardImpl {§public SaltcrustedSteppe(UUID ownerId) {§super(ownerId, 316, "Saltcrusted Steppe", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "C13";§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.STORAGE.createInstance()),new GenericManaCost(1));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new AddManaInAnyCombinationEffect(new RemovedCountersForCostValue(), ColoredManaSymbol.G, ColoredManaSymbol.W),§new GenericManaCost(1));§ability.addCost(new RemoveVariableCountersSourceCost(CounterType.STORAGE.createInstance()));§this.addAbility(ability);§}§public SaltcrustedSteppe(final SaltcrustedSteppe card) {§super(card);§}§@Override§public SaltcrustedSteppe copy() {§return new SaltcrustedSteppe(this);§}§}§
public class TemptWithGlory extends CardImpl {§public TemptWithGlory(UUID ownerId) {§super(ownerId, 24, "Tempt with Glory", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{5}{W}");§this.expansionSetCode = "C13";§this.getSpellAbility().addEffect(new TemptWithGloryEffect());§}§public TemptWithGlory(final TemptWithGlory card) {§super(card);§}§@Override§public TemptWithGlory copy() {§return new TemptWithGlory(this);§}§}§class TemptWithGloryEffect extends OneShotEffect {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent();§private static final Counter counter = CounterType.P1P1.createInstance();§public TemptWithGloryEffect() {§super(Outcome.PutLandInPlay);§this.staticText = "<i>Tempting offer</i> - Put a +1/+1 counter on each creature you control. Each opponent may put a +1/+1 counter on each creature he or she controls. For each opponent who does, put a +1/+1 counter on each creature you control";§}§public TemptWithGloryEffect(final TemptWithGloryEffect effect) {§super(effect);§}§@Override§public TemptWithGloryEffect copy() {§return new TemptWithGloryEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§addCounterToEachCreature(controller.getId(), counter, game);§int opponentsAddedCounters = 0;§for (UUID playerId : game.getOpponents(controller.getId())) {§Player opponent = game.getPlayer(playerId);§if (opponent != null) {§if (opponent.chooseUse(outcome, "Put a +1/+1 counter on each creature you control?", source, game)) {§opponentsAddedCounters++;§addCounterToEachCreature(playerId, counter, game);§game.informPlayers(opponent.getLogName() + " added a +1/+1 counter on each of its creatures");§}§}§}§if (opponentsAddedCounters > 0) {§addCounterToEachCreature(controller.getId(), CounterType.P1P1.createInstance(opponentsAddedCounters), game);§}§return true;§}§return false;§}§private void addCounterToEachCreature(UUID playerId, Counter counter, Game game) {§for(Permanent permanent: game.getBattlefield().getAllActivePermanents(filter, playerId, game)) {§permanent.addCounters(counter, game);§}§}§}§
public class AngelOfTheDireHour extends CardImpl {§public AngelOfTheDireHour(UUID ownerId) {§super(ownerId, 1, "Angel of the Dire Hour", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{W}{W}");§this.expansionSetCode = "C14";§this.subtype.add("Angel");§this.power = new MageInt(5);§this.toughness = new MageInt(4);§this.addAbility(FlashAbility.getInstance());§this.addAbility(FlyingAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(§new ConditionalOneShotEffect(new ExileAllEffect(new FilterAttackingCreature("attacking creatures")), new CastFromHandCondition(),§" if you cast it from your hand, exile all attacking creatures"));§this.addAbility(ability, new CastFromHandWatcher());§}§public AngelOfTheDireHour(final AngelOfTheDireHour card) {§super(card);§}§@Override§public AngelOfTheDireHour copy() {§return new AngelOfTheDireHour(this);§}§}§
public class DregsOfSorrow extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("nonblack creatures");§static {§filter.add(Predicates.not(new ColorPredicate(ObjectColor.BLACK)));§}§public DregsOfSorrow(UUID ownerId) {§super(ownerId, 143, "Dregs of Sorrow", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{X}{4}{B}");§this.expansionSetCode = "C14";§this.getSpellAbility().addEffect(new DestroyTargetEffect("Destroy X target nonblack creatures"));§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(new ManacostVariableValue()));§this.getSpellAbility().addTarget(new TargetCreaturePermanent(filter));§}§@Override§public void adjustTargets(Ability ability, Game game) {§if (ability instanceof SpellAbility) {§ability.getTargets().clear();§int xValue = ability.getManaCostsToPay().getX();§ability.addTarget(new TargetCreaturePermanent(xValue, xValue, filter, false));§}§}§public DregsOfSorrow(final DregsOfSorrow card) {§super(card);§}§@Override§public DregsOfSorrow copy() {§return new DregsOfSorrow(this);§}§}§
public class JazalGoldmane extends CardImpl {§public JazalGoldmane(UUID ownerId) {§super(ownerId, 9, "Jazal Goldmane", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{2}{W}{W}");§this.expansionSetCode = "C14";§this.supertype.add("Legendary");§this.subtype.add("Cat");§this.subtype.add("Warrior");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FirstStrikeAbility.getInstance());§DynamicValue xValue = new AttackingCreatureCount("the number of attacking creatures");§this.addAbility(new SimpleActivatedAbility(§Zone.BATTLEFIELD,§new BoostControlledEffect(xValue, xValue , Duration.EndOfTurn, new FilterAttackingCreature("Attacking creatures"), false),§new ManaCostsImpl("{3}{W}{W}")));§}§public JazalGoldmane(final JazalGoldmane card) {§super(card);§}§@Override§public JazalGoldmane copy() {§return new JazalGoldmane(this);§}§}§
public class RushOfKnowledge extends CardImpl {§public RushOfKnowledge(UUID ownerId) {§super(ownerId, 123, "Rush of Knowledge", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{4}{U}");§this.expansionSetCode = "C14";§DrawCardSourceControllerEffect effect = new DrawCardSourceControllerEffect(new HighestConvertedManaCostValue());§effect.setText("Draw cards equal to the highest converted mana cost among permanents you control");§this.getSpellAbility().addEffect(effect);§}§public RushOfKnowledge(final RushOfKnowledge card) {§super(card);§}§@Override§public RushOfKnowledge copy() {§return new RushOfKnowledge(this);§}§}§
public class WhitemaneLion extends CardImpl {§public WhitemaneLion(UUID ownerId) {§super(ownerId, 96, "Whitemane Lion", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "C14";§this.subtype.add("Cat");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlashAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new ReturnToHandChosenControlledPermanentEffect(new FilterControlledCreaturePermanent())));§}§public WhitemaneLion(final WhitemaneLion card) {§super(card);§}§@Override§public WhitemaneLion copy() {§return new WhitemaneLion(this);§}§}§
public class CrystalChimes extends CardImpl {§public CrystalChimes(UUID ownerId) {§super(ownerId, 250, "Crystal Chimes", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "C15";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CrystalChimesEffect(), new GenericManaCost(3));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public CrystalChimes(final CrystalChimes card) {§super(card);§}§@Override§public CrystalChimes copy() {§return new CrystalChimes(this);§}§}§class CrystalChimesEffect extends OneShotEffect {§CrystalChimesEffect() {§super(Outcome.PutCardInPlay);§this.staticText = "Return all enchantment cards from your graveyard to your hand";§}§CrystalChimesEffect(final CrystalChimesEffect effect) {§super(effect);§}§@Override§public CrystalChimesEffect copy() {§return new CrystalChimesEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§return controller.moveCards(controller.getGraveyard().getCards(new FilterEnchantmentCard(), source.getSourceId(),§source.getControllerId(), game), Zone.HAND, source, game);§}§return false;§}§}§
public class MazirekKraulDeathPriest extends CardImpl {§public MazirekKraulDeathPriest(UUID ownerId) {§super(ownerId, 48, "Mazirek, Kraul Death Priest", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{3}{B}{G}");§this.expansionSetCode = "C15";§this.supertype.add("Legendary");§this.subtype.add("Insect");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new PlayerSacrificesPermanentTriggeredAbility(new AddCountersAllEffect(CounterType.P1P1.createInstance(), new FilterControlledCreaturePermanent()), false));§}§public MazirekKraulDeathPriest(final MazirekKraulDeathPriest card) {§super(card);§}§@Override§public MazirekKraulDeathPriest copy() {§return new MazirekKraulDeathPriest(this);§}§}§class PlayerSacrificesPermanentTriggeredAbility extends TriggeredAbilityImpl {§public PlayerSacrificesPermanentTriggeredAbility(Effect effect, boolean optional) {§super(Zone.BATTLEFIELD, effect, optional);§}§public PlayerSacrificesPermanentTriggeredAbility(final PlayerSacrificesPermanentTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.SACRIFICED_PERMANENT;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§MageObject mageObject = game.getLastKnownInformation(event.getTargetId(), Zone.BATTLEFIELD);§return mageObject != null && !event.getTargetId().equals(this.getSourceId());§}§@Override§public String getRule() {§return "Whenever a player sacrifices another permanent, " + super.getRule();§}§@Override§public PlayerSacrificesPermanentTriggeredAbility copy() {§return new PlayerSacrificesPermanentTriggeredAbility(this);§}§}§
public class VerdantConfluence extends CardImpl {§public VerdantConfluence(UUID ownerId) {§super(ownerId, 40, "Verdant Confluence", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{4}{G}{G}");§this.expansionSetCode = "C15";§this.getSpellAbility().getModes().setMinModes(3);§this.getSpellAbility().getModes().setMaxModes(3);§this.getSpellAbility().getModes().setEachModeMoreThanOnce(true);§this.getSpellAbility().addEffect(new AddCountersTargetEffect(CounterType.P1P1.createInstance(2)));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§Mode mode = new Mode();§mode.getEffects().add(new ReturnFromGraveyardToHandTargetEffect());§mode.getTargets().add(new TargetCardInYourGraveyard(new FilterPermanentCard()));§this.getSpellAbility().getModes().addMode(mode);§TargetCardInLibrary target = new TargetCardInLibrary(new FilterBasicLandCard());§mode = new Mode();§mode.getEffects().add(new SearchLibraryPutInPlayEffect(target, true));§this.getSpellAbility().getModes().addMode(mode);§}§public VerdantConfluence(final VerdantConfluence card) {§super(card);§}§@Override§public VerdantConfluence copy() {§return new VerdantConfluence(this);§}§}§
public class ChildOfAlara extends CardImpl {§public ChildOfAlara(UUID ownerId) {§super(ownerId, 101, "Child of Alara", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{W}{U}{B}{R}{G}");§this.expansionSetCode = "CON";§this.supertype.add("Legendary");§this.subtype.add("Avatar");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new DiesTriggeredAbility(new DestroyAllEffect(new FilterNonlandPermanent("nonland permanents"), true)));§}§public ChildOfAlara(final ChildOfAlara card) {§super(card);§}§@Override§public ChildOfAlara copy() {§return new ChildOfAlara(this);§}§}§
public class ExoticOrchard extends CardImpl {§public ExoticOrchard(UUID ownerId) {§super(ownerId, 142, "Exotic Orchard", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "CON";§this.addAbility(new AnyColorLandsProduceManaAbility(TargetController.OPPONENT));§}§public ExoticOrchard(final ExoticOrchard card) {§super(card);§}§@Override§public ExoticOrchard copy() {§return new ExoticOrchard(this);§}§}§
public class InfectiousHorror extends CardImpl {§public InfectiousHorror (UUID ownerId) {§super(ownerId, 47, "Infectious Horror", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{B}");§this.expansionSetCode = "CON";§this.subtype.add("Zombie");§this.subtype.add("Horror");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new AttacksTriggeredAbility(new InfectiousHorrorEffect(), false));§}§public InfectiousHorror (final InfectiousHorror card) {§super(card);§}§@Override§public InfectiousHorror copy() {§return new InfectiousHorror(this);§}§}§class InfectiousHorrorEffect extends OneShotEffect {§InfectiousHorrorEffect() {§super(Outcome.Damage);§staticText = "each opponent loses 2 life";§}§InfectiousHorrorEffect(final InfectiousHorrorEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§for (UUID opponentId : game.getOpponents(source.getControllerId())) {§Player opponent = game.getPlayer(opponentId);§if (opponent != null) {§opponent.loseLife(2, game);§}§}§return true;§}§@Override§public InfectiousHorrorEffect copy() {§return new InfectiousHorrorEffect(this);§}§}§
public class MightOfAlara extends CardImpl {§public MightOfAlara(UUID ownerId) {§super(ownerId, 85, "Might of Alara", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{G}");§this.expansionSetCode = "CON";§this.getSpellAbility().addEffect(new BoostTargetEffect(new DomainValue(), new DomainValue(), Duration.EndOfTurn, true));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public MightOfAlara(final MightOfAlara card) {§super(card);§}§@Override§public MightOfAlara copy() {§return new MightOfAlara(this);§}§}§
public class RhoxMeditant extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("green permanent");§static {§filter.add(new ColorPredicate(ObjectColor.GREEN));§}§private static final String rule = "When {this} enters the battlefield, if you control a green permanent, draw a card.";§public RhoxMeditant(UUID ownerId) {§super(ownerId, 16, "Rhox Meditant", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "CON";§this.subtype.add("Rhino");§this.subtype.add("Monk");§this.power = new MageInt(2);§this.toughness = new MageInt(4);§TriggeredAbility ability = new EntersBattlefieldTriggeredAbility(new DrawCardSourceControllerEffect(1), false);§this.addAbility(new ConditionalTriggeredAbility(ability, new PermanentsOnTheBattlefieldCondition(filter), rule));§}§public RhoxMeditant(final RhoxMeditant card) {§super(card);§}§@Override§public RhoxMeditant copy() {§return new RhoxMeditant(this);§}§}§
public class SuicidalCharge extends CardImpl {§public SuicidalCharge(UUID ownerId) {§super(ownerId, 128, "Suicidal Charge", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{3}{B}{R}");§this.expansionSetCode = "CON";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostOpponentsEffect(-1, -1, Duration.EndOfTurn), new SacrificeSourceCost());§ability.addEffect(new SuicidalChargeEffect());§this.addAbility(ability);§}§public SuicidalCharge(final SuicidalCharge card) {§super(card);§}§@Override§public SuicidalCharge copy() {§return new SuicidalCharge(this);§}§}§class SuicidalChargeEffect extends RequirementEffect {§public SuicidalChargeEffect() {§super(Duration.EndOfTurn);§staticText = "Those creatures attack this turn if able";§}§public SuicidalChargeEffect(final SuicidalChargeEffect effect) {§super(effect);§}§@Override§public SuicidalChargeEffect copy() {§return new SuicidalChargeEffect(this);§}§@Override§public boolean applies(Permanent permanent, Ability source, Game game) {§if (game.getOpponents(source.getControllerId()).contains(permanent.getControllerId())) {§return true;§}§return false;§}§@Override§public boolean mustAttack(Game game) {§return true;§}§@Override§public boolean mustBlock(Game game) {§return false;§}§}§
public class WildLeotau extends CardImpl {§public WildLeotau(UUID ownerId) {§super(ownerId, 97, "Wild Leotau", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{G}{G}");§this.expansionSetCode = "CON";§this.subtype.add("Cat");§this.power = new MageInt(5);§this.toughness = new MageInt(4);§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new SacrificeSourceUnlessPaysEffect(new ColoredManaCost(ColoredManaSymbol.G)), TargetController.YOU, false));§}§public WildLeotau(final WildLeotau card) {§super(card);§}§@Override§public WildLeotau copy() {§return new WildLeotau(this);§}§}§
public class MagusOfTheMirror extends CardImpl {§public MagusOfTheMirror(UUID ownerId) {§super(ownerId, 117, "Magus of the Mirror", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{B}{B}");§this.expansionSetCode = "CNS";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(4);§this.toughness = new MageInt(2);§Ability ability = new ConditionalActivatedAbility(§Zone.BATTLEFIELD,§new MagusOfTheMirrorEffect(),§new TapSourceCost(),§new IsStepCondition(PhaseStep.UPKEEP),§null);§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§}§public MagusOfTheMirror(final MagusOfTheMirror card) {§super(card);§}§@Override§public MagusOfTheMirror copy() {§return new MagusOfTheMirror(this);§}§}§class MagusOfTheMirrorEffect extends OneShotEffect {§public MagusOfTheMirrorEffect() {§super(Outcome.Neutral);§this.staticText = "Exchange life totals with target opponent";§}§public MagusOfTheMirrorEffect(final MagusOfTheMirrorEffect effect) {§super(effect);§}§@Override§public MagusOfTheMirrorEffect copy() {§return new MagusOfTheMirrorEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Player opponent = game.getPlayer(source.getFirstTarget());§if (controller != null && opponent != null) {§int lifeController = controller.getLife();§int lifeOpponent = opponent.getLife();§if (lifeController == lifeOpponent)§return false;§if (!controller.isLifeTotalCanChange() || !opponent.isLifeTotalCanChange())§return false;§if (lifeController < lifeOpponent && (!controller.isCanGainLife() || !opponent.isCanLoseLife()))§return false;§if (lifeController > lifeOpponent && (!controller.isCanLoseLife() || !opponent.isCanGainLife()))§return false;§controller.setLife(lifeOpponent, game);§opponent.setLife(lifeController, game);§return true;§}§return false;§}§}§
public class ValorMadeReal extends CardImpl {§public ValorMadeReal(UUID ownerId) {§super(ownerId, 86, "Valor Made Real", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{W}");§this.expansionSetCode = "CNS";§Ability gainedAbility = new SimpleStaticAbility(Zone.BATTLEFIELD, new CanBlockAdditionalCreatureEffect(0));§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(gainedAbility, Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public ValorMadeReal(final ValorMadeReal card) {§super(card);§}§@Override§public ValorMadeReal copy() {§return new ValorMadeReal(this);§}§}§
public class BurningOil extends CardImpl {§public BurningOil(UUID ownerId) {§super(ownerId, 84, "Burning Oil", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{R}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addTarget(new TargetAttackingOrBlockingCreature());§this.getSpellAbility().addEffect(new DamageTargetEffect(3));§this.addAbility(new FlashbackAbility(new ManaCostsImpl("{3}{W}"), TimingRule.INSTANT));§}§public BurningOil(final BurningOil card) {§super(card);§}§@Override§public BurningOil copy() {§return new BurningOil(this);§}§}§
public class DrogskolCaptain extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Spirit");§static {§filter.add(new SubtypePredicate("Spirit"));§}§public DrogskolCaptain(UUID ownerId) {§super(ownerId, 136, "Drogskol Captain", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{W}{U}");§this.expansionSetCode = "DKA";§this.subtype.add("Spirit");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostControlledEffect(1, 1, Duration.WhileOnBattlefield, filter, true)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityControlledEffect(HexproofAbility.getInstance(), Duration.WhileOnBattlefield, filter, true)));§}§public DrogskolCaptain(final DrogskolCaptain card) {§super(card);§}§@Override§public DrogskolCaptain copy() {§return new DrogskolCaptain(this);§}§}§
public class GeralfsMessenger extends CardImpl {§public GeralfsMessenger(UUID ownerId) {§super(ownerId, 63, "Geralf's Messenger", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{B}{B}{B}");§this.expansionSetCode = "DKA";§this.subtype.add("Zombie");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(new EntersBattlefieldTappedAbility());§Ability ability = new EntersBattlefieldTriggeredAbility(new LoseLifeTargetEffect(2));§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§this.addAbility(new UndyingAbility());§}§public GeralfsMessenger(final GeralfsMessenger card) {§super(card);§}§@Override§public GeralfsMessenger copy() {§return new GeralfsMessenger(this);§}§}§
public class Helvault extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature you don't control");§static {§filter.add(new ControllerPredicate(TargetController.NOT_YOU));§}§public Helvault(UUID ownerId) {§super(ownerId, 151, "Helvault", Rarity.MYTHIC, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "DKA";§this.supertype.add("Legendary");§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ExileTargetForSourceEffect(), new GenericManaCost(1));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetControlledCreaturePermanent());§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ExileTargetForSourceEffect(), new GenericManaCost(7));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§this.addAbility(new DiesTriggeredAbility(new ReturnFromExileForSourceEffect(Zone.BATTLEFIELD)));§}§public Helvault(final Helvault card) {§super(card);§}§@Override§public Helvault copy() {§return new Helvault(this);§}§}§
public class LoyalCathar extends CardImpl {§public LoyalCathar(UUID ownerId) {§super(ownerId, 13, "Loyal Cathar", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{W}{W}");§this.expansionSetCode = "DKA";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.canTransform = true;§this.secondSideCard = new UnhallowedCathar(ownerId);§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(new TransformAbility());§this.addAbility(new DiesTriggeredAbility(new LoyalCatharEffect()));§}§public LoyalCathar(final LoyalCathar card) {§super(card);§}§@Override§public LoyalCathar copy() {§return new LoyalCathar(this);§}§}§class LoyalCatharEffect extends OneShotEffect {§private static final String effectText = "return it to the battlefield transformed under your control at the beginning of the next end step";§LoyalCatharEffect() {§super(Outcome.Benefit);§staticText = effectText;§}§LoyalCatharEffect(LoyalCatharEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§AtTheBeginOfNextEndStepDelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(new ReturnLoyalCatharEffect(source.getSourceId()));§game.addDelayedTriggeredAbility(delayedAbility, source);§return true;§}§@Override§public LoyalCatharEffect copy() {§return new LoyalCatharEffect(this);§}§}§class ReturnLoyalCatharEffect extends OneShotEffect {§private UUID cardId;§public ReturnLoyalCatharEffect(UUID cardId) {§super(Outcome.PutCardInPlay);§this.cardId = cardId;§this.staticText = "return it to the battlefield transformed under your control";§}§public ReturnLoyalCatharEffect(final ReturnLoyalCatharEffect effect) {§super(effect);§this.cardId = effect.cardId;§}§@Override§public ReturnLoyalCatharEffect copy() {§return new ReturnLoyalCatharEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Card card = game.getCard(cardId);§if (card != null) {§card.putOntoBattlefield(game, Zone.GRAVEYARD, source.getSourceId(), source.getControllerId());§Permanent perm = game.getPermanent(cardId);§if (perm != null && perm.canTransform()) {§perm.transform(game);§return true;§}§}§return false;§}§}§
public class ReapTheSeagraf extends CardImpl {§public ReapTheSeagraf(UUID ownerId) {§super(ownerId, 72, "Reap the Seagraf", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{B}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addEffect(new CreateTokenEffect(new ZombieToken()));§this.addAbility(new FlashbackAbility(new ManaCostsImpl("{4}{U}"), TimingRule.SORCERY));§}§public ReapTheSeagraf(final ReapTheSeagraf card) {§super(card);§}§@Override§public ReapTheSeagraf copy() {§return new ReapTheSeagraf(this);§}§}§
public class SoulSeizer extends CardImpl {§public SoulSeizer(UUID ownerId) {§super(ownerId, 50, "Soul Seizer", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{U}{U}");§this.expansionSetCode = "DKA";§this.subtype.add("Spirit");§this.canTransform = true;§this.secondSideCard = new GhastlyHaunting(ownerId);§this.power = new MageInt(1);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new TransformAbility());§this.addAbility(new SoulSeizerTriggeredAbility());§}§public SoulSeizer(final SoulSeizer card) {§super(card);§}§@Override§public SoulSeizer copy() {§return new SoulSeizer(this);§}§}§class SoulSeizerTriggeredAbility extends TriggeredAbilityImpl {§public SoulSeizerTriggeredAbility() {§super(Zone.BATTLEFIELD, new SoulSeizerEffect(), true);§}§public SoulSeizerTriggeredAbility(SoulSeizerTriggeredAbility ability) {§super(ability);§}§@Override§public SoulSeizerTriggeredAbility copy() {§return new SoulSeizerTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_PLAYER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§DamagedPlayerEvent damageEvent = (DamagedPlayerEvent)event;§if (damageEvent.isCombatDamage() && event.getSourceId().equals(this.getSourceId())) {§Player opponent = game.getPlayer(event.getPlayerId());§if (opponent != null) {§FilterCreaturePermanent filter = new FilterCreaturePermanent("creature " + opponent.getLogName() + " controls");§filter.add(new ControllerIdPredicate(opponent.getId()));§this.getTargets().clear();§this.addTarget(new TargetCreaturePermanent(filter));§return true;§}§}§return false;§}§@Override§public String getRule() {§return "When {this} deals combat damage to a player, you may transform it. If you do, attach it to target creature that player controls";§}§}§class SoulSeizerEffect extends OneShotEffect {§public SoulSeizerEffect() {§super(Outcome.GainControl);§}§public SoulSeizerEffect(final SoulSeizerEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(source.getSourceId());§if (permanent != null && permanent.canTransform()) {§if (permanent.transform(game)) {§game.informPlayers(new StringBuilder(permanent.getName()).append(" transforms into ").append(permanent.getSecondCardFace().getName()).toString());§Permanent attachTo = game.getPermanent(targetPointer.getFirst(game, source));§if (attachTo != null) {§return attachTo.addAttachment(source.getSourceId(), game);§}§}§}§return false;§}§@Override§public SoulSeizerEffect copy() {§return new SoulSeizerEffect(this);§}§}§
public class VengefulVampire extends CardImpl {§public VengefulVampire(UUID ownerId) {§super(ownerId, 78, "Vengeful Vampire", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{B}{B}");§this.expansionSetCode = "DKA";§this.subtype.add("Vampire");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new UndyingAbility());§}§public VengefulVampire(final VengefulVampire card) {§super(card);§}§@Override§public VengefulVampire copy() {§return new VengefulVampire(this);§}§}§
public class ArcboundReclaimer extends CardImpl {§public ArcboundReclaimer(UUID ownerId) {§super(ownerId, 101, "Arcbound Reclaimer", Rarity.RARE, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{4}");§this.expansionSetCode = "DST";§this.subtype.add("Golem");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PutOnLibraryTargetEffect(true),new RemoveCountersSourceCost(CounterType.P1P1.createInstance()));§ability.addTarget(new TargetCardInYourGraveyard(new FilterArtifactCard("artifact card from your graveyard")));§this.addAbility(ability);§this.addAbility(new ModularAbility(this, 2));§}§public ArcboundReclaimer(final ArcboundReclaimer card) {§super(card);§}§@Override§public ArcboundReclaimer copy() {§return new ArcboundReclaimer(this);§}§}§
public class EchoingCalm extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("enchantment");§static {§filter.add(new CardTypePredicate(CardType.ENCHANTMENT));§}§public EchoingCalm(UUID ownerId) {§super(ownerId, 2, "Echoing Calm", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{W}");§this.expansionSetCode = "DST";§this.getSpellAbility().addTarget(new TargetPermanent(filter));§this.getSpellAbility().addEffect(new EchoingCalmEffect());§}§public EchoingCalm(final EchoingCalm card) {§super(card);§}§@Override§public EchoingCalm copy() {§return new EchoingCalm(this);§}§}§class EchoingCalmEffect extends OneShotEffect {§EchoingCalmEffect() {§super(Outcome.DestroyPermanent);§staticText = "Destroy target enchantment and all other enchantments with the same name as that enchantment";§}§EchoingCalmEffect(final EchoingCalmEffect effect) {§super(effect);§}§@Override§public EchoingCalmEffect copy() {§return new EchoingCalmEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Permanent permanent = game.getPermanent(getTargetPointer().getFirst(game, source));§if (controller != null && permanent != null) {§permanent.destroy(source.getSourceId(), game, false);§if (!permanent.getName().isEmpty()) { §
public class LeoninShikari extends CardImpl {§public LeoninShikari(UUID ownerId) {§super(ownerId, 6, "Leonin Shikari", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "DST";§this.subtype.add("Cat");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new LeoninShikariEffect()));§}§public LeoninShikari(final LeoninShikari card) {§super(card);§}§@Override§public LeoninShikari copy() {§return new LeoninShikari(this);§}§}§class LeoninShikariEffect extends AsThoughEffectImpl {§LeoninShikariEffect() {§super(AsThoughEffectType.ACTIVATE_AS_INSTANT, Duration.EndOfGame, Outcome.Benefit);§staticText = "You may activate equip abilities any time you could cast an instant";§}§LeoninShikariEffect(final LeoninShikariEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public LeoninShikariEffect copy() {§return new LeoninShikariEffect(this);§}§@Override§public boolean applies(UUID objectId, Ability affectedAbility, Ability source, Game game) {§return affectedAbility.getControllerId().equals(source.getControllerId()) && affectedAbility instanceof EquipAbility;§}§@Override§public boolean applies(UUID objectId, Ability source, UUID affectedControllerId, Game game) {§return false; §
public class Purge extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("artifact creature or black creature");§static {§filter.add(Predicates.or(new CardTypePredicate(CardType.ARTIFACT),§(new ColorPredicate(ObjectColor.BLACK))));§}§public Purge(UUID ownerId) {§super(ownerId, 12, "Purge", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{W}");§this.expansionSetCode = "DST";§this.getSpellAbility().addTarget(new TargetCreaturePermanent(filter));§this.getSpellAbility().addEffect(new DestroyTargetEffect(true));§}§public Purge(final Purge card) {§super(card);§}§@Override§public Purge copy() {§return new Purge(this);§}§}§
public class SwordOfLightAndShadow extends CardImpl {§private static final FilterCard filter = new FilterCard("white and from black");§static {§filter.add(Predicates.or(§new ColorPredicate(ObjectColor.WHITE),§new ColorPredicate(ObjectColor.BLACK)));§}§public SwordOfLightAndShadow(UUID ownerId) {§super(ownerId, 149, "Sword of Light and Shadow", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "DST";§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(2, 2)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(new ProtectionAbility(filter), AttachmentType.EQUIPMENT)));§this.addAbility(new SwordOfLightAndShadowAbility());§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(2)));§}§public SwordOfLightAndShadow(final SwordOfLightAndShadow card) {§super(card);§}§@Override§public SwordOfLightAndShadow copy() {§return new SwordOfLightAndShadow(this);§}§@Override§public void adjustTargets(Ability ability, Game game) {§if (ability instanceof SwordOfLightAndShadowAbility) {§Player controller = game.getPlayer(ability.getControllerId());§if (controller != null) {§if (controller.getGraveyard().count(new FilterCreatureCard(), ability.getSourceId(), ability.getControllerId(), game) > 0) {§ability.addTarget(new TargetCardInYourGraveyard(0, 1, new FilterCreatureCard("creature card from your graveyard")));§}§}§}§}§}§class SwordOfLightAndShadowAbility extends TriggeredAbilityImpl {§public SwordOfLightAndShadowAbility() {§super(Zone.BATTLEFIELD, new GainLifeEffect(3), false);§this.addEffect(new SwordOfLightAndShadowReturnToHandTargetEffect());§}§public SwordOfLightAndShadowAbility(final SwordOfLightAndShadowAbility ability) {§super(ability);§}§@Override§public SwordOfLightAndShadowAbility copy() {§return new SwordOfLightAndShadowAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_PLAYER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§DamagedPlayerEvent damageEvent = (DamagedPlayerEvent) event;§Permanent p = game.getPermanent(event.getSourceId());§return damageEvent.isCombatDamage() && p != null && p.getAttachments().contains(this.getSourceId());§}§@Override§public String getRule() {§return "Whenever equipped creature deals combat damage to a player, you gain 3 life and you may return up to one target creature card from your graveyard to your hand.";§}§}§class SwordOfLightAndShadowReturnToHandTargetEffect extends OneShotEffect {§public SwordOfLightAndShadowReturnToHandTargetEffect() {§super(Outcome.ReturnToHand);§staticText = "and you may return up to one target creature card from your graveyard to your hand";§}§public SwordOfLightAndShadowReturnToHandTargetEffect(final SwordOfLightAndShadowReturnToHandTargetEffect effect) {§super(effect);§}§@Override§public SwordOfLightAndShadowReturnToHandTargetEffect copy() {§return new SwordOfLightAndShadowReturnToHandTargetEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§boolean result = true; §
public class AzoriusChancery extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledLandPermanent();§public AzoriusChancery(UUID ownerId) {§super(ownerId, 170, "Azorius Chancery", Rarity.COMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "DIS";§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new EntersBattlefieldTriggeredAbility(new ReturnToHandChosenControlledPermanentEffect(filter), false));§this.addAbility(new SimpleManaAbility(Zone.BATTLEFIELD, new Mana(0, 0, 1, 1, 0, 0, 0, 0), new TapSourceCost()));§}§public AzoriusChancery(final AzoriusChancery card) {§super(card);§}§@Override§public AzoriusChancery copy() {§return new AzoriusChancery(this);§}§}§
public class DemonsJester extends CardImpl {§public DemonsJester(UUID ownerId) {§super(ownerId, 42, "Demon's Jester", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{B}");§this.expansionSetCode = "DIS";§this.subtype.add("Imp");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(§new BoostSourceEffect(2,1,Duration.WhileOnBattlefield), HellbentCondition.getInstance(),§"<i>Hellbent</i> - {this} gets +2/+1 as long as you have no cards in hand")));§}§public DemonsJester(final DemonsJester card) {§super(card);§}§@Override§public DemonsJester copy() {§return new DemonsJester(this);§}§}§
public class InfernalTutor extends CardImpl {§public InfernalTutor(UUID ownerId) {§super(ownerId, 46, "Infernal Tutor", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{1}{B}");§this.expansionSetCode = "DIS";§this.getSpellAbility().addEffect(new InfernalTutorEffect());§Effect effect = new ConditionalOneShotEffect(§new SearchLibraryPutInHandEffect(new TargetCardInLibrary(new FilterCard()), false, true),§HellbentCondition.getInstance(),§"<br/><br/><i>Hellbent</i> - If you have no cards in hand, instead search your library for a card, put it into your hand, then shuffle your library");§this.getSpellAbility().addEffect(effect);§}§public InfernalTutor(final InfernalTutor card) {§super(card);§}§@Override§public InfernalTutor copy() {§return new InfernalTutor(this);§}§}§class InfernalTutorEffect extends OneShotEffect {§public InfernalTutorEffect() {§super(Outcome.Benefit);§this.staticText = "Reveal a card from your hand. Search your library for a card with the same name as that card, reveal it, put it into your hand, then shuffle your library";§}§public InfernalTutorEffect(final InfernalTutorEffect effect) {§super(effect);§}§@Override§public InfernalTutorEffect copy() {§return new InfernalTutorEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = game.getObject(source.getSourceId());§if (controller != null && sourceObject != null) {§if (controller.getHand().size() > 0) {§Card cardToReveal = null;§if (controller.getHand().size() > 1) {§Target target = new TargetCardInHand(new FilterCard());§target.setNotTarget(true);§if (controller.chooseTarget(outcome, target, source, game)) {§cardToReveal = game.getCard(target.getFirstTarget());§}§} else {§cardToReveal = controller.getHand().getRandom(game);§}§FilterCard filterCard;§if (cardToReveal != null) {§controller.revealCards("from hand :" + sourceObject.getName(), new CardsImpl(cardToReveal), game);§filterCard = new FilterCard("card named " + cardToReveal.getName());§filterCard.add(new NamePredicate(cardToReveal.getName()));§} else {§filterCard = new FilterCard();§}§return new SearchLibraryPutInHandEffect(new TargetCardInLibrary(filterCard), true, true).apply(game, source);§}§return true;§}§return false;§}§}§
public class Plaxmanta extends CardImpl {§public Plaxmanta(UUID ownerId) {§super(ownerId, 29, "Plaxmanta", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "DIS";§this.subtype.add("Beast");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlashAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(§new GainAbilityControlledEffect(ShroudAbility.getInstance(), Duration.EndOfTurn, new FilterCreaturePermanent("creatures"))));§this.addAbility(new EntersBattlefieldTriggeredAbility(new SacrificeSourceUnlessConditionEffect(new ManaWasSpentCondition(ColoredManaSymbol.G)), false), new ManaSpentToCastWatcher());§}§public Plaxmanta(final Plaxmanta card) {§super(card);§}§@Override§public Plaxmanta copy() {§return new Plaxmanta(this);§}§}§
public class ShieldingPlax extends CardImpl {§private static final FilterObject filter = new FilterStackObject("spells or abilities your opponents control");§public ShieldingPlax(UUID ownerId) {§super(ownerId, 147, "Shielding Plax", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{G/U}");§this.expansionSetCode = "DIS";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new EntersBattlefieldTriggeredAbility(new DrawCardSourceControllerEffect(1)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD,§new CantBeTargetedAttachedEffect(filter, Duration.WhileOnBattlefield, AttachmentType.AURA, TargetController.OPPONENT)));§}§public ShieldingPlax(final ShieldingPlax card) {§super(card);§}§@Override§public ShieldingPlax copy() {§return new ShieldingPlax(this);§}§}§
public class UtopiaSprawl extends CardImpl {§private static final FilterLandPermanent filter = new FilterLandPermanent("Forest", "Forest");§public UtopiaSprawl(UUID ownerId) {§super(ownerId, 99, "Utopia Sprawl", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{G}");§this.expansionSetCode = "DIS";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetLandPermanent(filter);§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new AsEntersBattlefieldAbility(new ChooseColorEffect(Outcome.Detriment)));§this.addAbility(new UtopiaSprawlTriggeredAbility());§}§public UtopiaSprawl(final UtopiaSprawl card) {§super(card);§}§@Override§public UtopiaSprawl copy() {§return new UtopiaSprawl(this);§}§}§class UtopiaSprawlTriggeredAbility extends TriggeredManaAbility {§public UtopiaSprawlTriggeredAbility() {§super(Zone.BATTLEFIELD, new UtopiaSprawlEffect());§}§public UtopiaSprawlTriggeredAbility(UtopiaSprawlTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.TAPPED_FOR_MANA;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent enchantment = game.getPermanent(this.getSourceId());§return enchantment != null && event.getSourceId().equals(enchantment.getAttachedTo());§}§@Override§public UtopiaSprawlTriggeredAbility copy() {§return new UtopiaSprawlTriggeredAbility(this);§}§@Override§public String getRule() {§return "Whenever enchanted Forest is tapped for mana, its controller adds one mana of the chosen color to his or her mana pool.";§}§}§class UtopiaSprawlEffect extends ManaEffect {§public UtopiaSprawlEffect() {§super();§staticText = "its controller adds one mana of the chosen color to his or her mana pool";§}§public UtopiaSprawlEffect(final UtopiaSprawlEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent enchantment = game.getPermanent(source.getSourceId());§if (enchantment != null) {§Permanent land = game.getPermanent(enchantment.getAttachedTo());§if (land != null) {§Player player = game.getPlayer(land.getControllerId());§if (player != null) {§player.getManaPool().addMana(getMana(game, source), game, source);§return true;§}§}§}§return false;§}§@Override§public Mana getMana(Game game, Ability source) {§ObjectColor color = (ObjectColor) game.getState().getValue(source.getSourceId() + "_color");§if (color != null) {§return new Mana(ColoredManaSymbol.lookup(color.toString().charAt(0)));§} else {§return null;§}§}§@Override§public UtopiaSprawlEffect copy() {§return new UtopiaSprawlEffect(this);§}§}§
public class AscendedLawmage extends CardImpl {§public AscendedLawmage (UUID ownerId) {§super(ownerId, 53, "Ascended Lawmage", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{W}{U}");§this.expansionSetCode = "DGM";§this.subtype.add("Vedalken");§this.subtype.add("Wizard");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(HexproofAbility.getInstance());§}§public AscendedLawmage (final AscendedLawmage card) {§super(card);§}§@Override§public AscendedLawmage copy() {§return new AscendedLawmage(this);§}§}§
public class DebtToTheDeathless extends CardImpl {§public DebtToTheDeathless(UUID ownerId) {§super(ownerId, 64, "Debt to the Deathless", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{X}{W}{W}{B}{B}");§this.expansionSetCode = "DGM";§this.getSpellAbility().addEffect(new DebtToTheDeathlessEffect());§}§public DebtToTheDeathless(final DebtToTheDeathless card) {§super(card);§}§@Override§public DebtToTheDeathless copy() {§return new DebtToTheDeathless(this);§}§}§class DebtToTheDeathlessEffect extends OneShotEffect {§public DebtToTheDeathlessEffect() {§super(Outcome.Benefit);§this.staticText = "Each opponent loses two times X life. You gain life equal to the life lost this way";§}§public DebtToTheDeathlessEffect(final DebtToTheDeathlessEffect effect) {§super(effect);§}§@Override§public DebtToTheDeathlessEffect copy() {§return new DebtToTheDeathlessEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§int damage = 0;§int xValue = source.getManaCostsToPay().getX();§for (UUID opponentId: game.getOpponents(source.getControllerId())) {§damage += game.getPlayer(opponentId).damage(xValue * 2, source.getSourceId(), game, false, true);§}§game.getPlayer(source.getControllerId()).gainLife(damage, game);§return true;§}§}§
public class JelennSphinx extends CardImpl {§public JelennSphinx(UUID ownerId) {§super(ownerId, 77, "Jelenn Sphinx", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{W}{U}");§this.expansionSetCode = "DGM";§this.subtype.add("Sphinx");§this.power = new MageInt(1);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(new AttacksTriggeredAbility(new BoostAllEffect(1,1, Duration.EndOfTurn,new FilterAttackingCreature(),true), false));§}§public JelennSphinx(final JelennSphinx card) {§super(card);§}§@Override§public JelennSphinx copy() {§return new JelennSphinx(this);§}§}§
public class MurmuringPhantasm extends CardImpl {§public MurmuringPhantasm (UUID ownerId) {§super(ownerId, 15, "Murmuring Phantasm", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "DGM";§this.subtype.add("Spirit");§this.power = new MageInt(0);§this.toughness = new MageInt(5);§this.addAbility(DefenderAbility.getInstance());§}§public MurmuringPhantasm (final MurmuringPhantasm card) {§super(card);§}§@Override§public MurmuringPhantasm copy() {§return new MurmuringPhantasm(this);§}§}§
public class RenegadeKrasis extends CardImpl {§public RenegadeKrasis(UUID ownerId) {§super(ownerId, 47, "Renegade Krasis", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{G}{G}");§this.expansionSetCode = "DGM";§this.subtype.add("Beast");§this.subtype.add("Mutant");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(new EvolveAbility());§this.addAbility(new RenegadeKrasisTriggeredAbility());§}§public RenegadeKrasis(final RenegadeKrasis card) {§super(card);§}§@Override§public RenegadeKrasis copy() {§return new RenegadeKrasis(this);§}§}§class RenegadeKrasisTriggeredAbility extends TriggeredAbilityImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent();§static {§filter.add(new AnotherPredicate());§filter.add(new CounterPredicate(CounterType.P1P1));§}§public RenegadeKrasisTriggeredAbility() {§super(Zone.BATTLEFIELD, new AddCountersAllEffect(CounterType.P1P1.createInstance(1), filter), false);§}§public RenegadeKrasisTriggeredAbility(final RenegadeKrasisTriggeredAbility ability) {§super(ability);§}§@Override§public RenegadeKrasisTriggeredAbility copy() {§return new RenegadeKrasisTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.EVOLVED_CREATURE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§return event.getTargetId().equals(getSourceId());§}§@Override§public String getRule() {§return "Whenever {this} evolves, put a +1/+1 counter on each other creature you control with a +1/+1 counter on it.";§}§}§
public class SmeltWardGatekeepers extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent();§private static final FilterCreaturePermanent targetFilter = new FilterCreaturePermanent("creature an opponent controls");§static {§filter.add(new SubtypePredicate("Gate"));§targetFilter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public SmeltWardGatekeepers (UUID ownerId) {§super(ownerId, 39, "Smelt-Ward Gatekeepers", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "DGM";§this.subtype.add("Human");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(4);§Ability ability = new ConditionalTriggeredAbility(§new EntersBattlefieldTriggeredAbility(new GainControlTargetEffect(Duration.EndOfTurn)),§new PermanentsOnTheBattlefieldCondition(filter, PermanentsOnTheBattlefieldCondition.CountType.MORE_THAN, 1),§"When {this} enters the battlefield, if you control two or more Gates, gain control of target creature an opponent controls until end of turn. Untap that creature. That creature gains haste until end of turn.");§ability.addEffect(new UntapTargetEffect());§ability.addEffect(new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.EndOfTurn));§Target target = new TargetCreaturePermanent(targetFilter);§ability.addTarget(target);§this.addAbility(ability);§}§public SmeltWardGatekeepers (final SmeltWardGatekeepers card) {§super(card);§}§@Override§public SmeltWardGatekeepers copy() {§return new SmeltWardGatekeepers(this);§}§}§
public class WeaponSurge extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("All creature you control");§static {§filter.add(new ControllerPredicate(TargetController.YOU));§}§public WeaponSurge(UUID ownerId) {§super(ownerId, 40, "Weapon Surge", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{R}");§this.expansionSetCode = "DGM";§this.getSpellAbility().addEffect(new BoostTargetEffect(1,0, Duration.EndOfTurn));§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetControlledCreaturePermanent());§Ability ability = new OverloadAbility(this, new BoostAllEffect(1,0, Duration.EndOfTurn, filter, false), new ManaCostsImpl("{1}{R}"));§ability.addEffect(new GainAbilityAllEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn, filter, false));§this.addAbility(ability);§}§public WeaponSurge(final WeaponSurge card) {§super(card);§}§@Override§public WeaponSurge copy() {§return new WeaponSurge(this);§}§}§
public class AtarkaPummeler extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Creatures you control");§static {§filter.add(new ControllerPredicate(TargetController.YOU));§}§public AtarkaPummeler(UUID ownerId) {§super(ownerId, 129, "Atarka Pummeler", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{R}");§this.expansionSetCode = "DTK";§this.subtype.add("Ogre");§this.subtype.add("Warrior");§this.power = new MageInt(4);§this.toughness = new MageInt(5);§Ability ability = new ActivateIfConditionActivatedAbility(§Zone.BATTLEFIELD,§new GainAbilityAllEffect(new MenaceAbility(), Duration.EndOfTurn, filter),§new ManaCostsImpl("{3}{R}{R}"),§FormidableCondition.getInstance());§ability.setAbilityWord(AbilityWord.FORMIDABLE);§this.addAbility(ability);§}§public AtarkaPummeler(final AtarkaPummeler card) {§super(card);§}§@Override§public AtarkaPummeler copy() {§return new AtarkaPummeler(this);§}§}§
public class ConiferStrider extends CardImpl {§public ConiferStrider(UUID ownerId) {§super(ownerId, 179, "Conifer Strider", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "DTK";§this.subtype.add("Elemental");§this.power = new MageInt(5);§this.toughness = new MageInt(1);§this.addAbility(HexproofAbility.getInstance());§}§public ConiferStrider(final ConiferStrider card) {§super(card);§}§@Override§public ConiferStrider copy() {§return new ConiferStrider(this);§}§}§
public class DragonlordDromoka extends CardImpl {§public DragonlordDromoka(UUID ownerId) {§super(ownerId, 217, "Dragonlord Dromoka", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{4}{G}{W}");§this.expansionSetCode = "DTK";§this.supertype.add("Legendary");§this.subtype.add("Elder");§this.subtype.add("Dragon");§this.power = new MageInt(5);§this.toughness = new MageInt(7);§this.addAbility(new CantBeCounteredAbility());§this.addAbility(FlyingAbility.getInstance());§this.addAbility(LifelinkAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new DragonlordDromokaEffect()));§}§public DragonlordDromoka(final DragonlordDromoka card) {§super(card);§}§@Override§public DragonlordDromoka copy() {§return new DragonlordDromoka(this);§}§}§class DragonlordDromokaEffect extends ContinuousRuleModifyingEffectImpl {§public DragonlordDromokaEffect() {§super(Duration.WhileOnBattlefield, Outcome.Benefit);§staticText = "Your opponents can't cast spells during your turn";§}§public DragonlordDromokaEffect(final DragonlordDromokaEffect effect) {§super(effect);§}§@Override§public DragonlordDromokaEffect copy() {§return new DragonlordDromokaEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.CAST_SPELL;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (game.getActivePlayerId().equals(source.getControllerId()) &&§game.getPlayer(source.getControllerId()).hasOpponent(event.getPlayerId(), game)) {§return true;§}§return false;§}§}§
public class EnduringScalelord extends CardImpl {§public EnduringScalelord(UUID ownerId) {§super(ownerId, 222, "Enduring Scalelord", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{G}{W}");§this.expansionSetCode = "DTK";§this.subtype.add("Dragon");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EnduringScalelordTriggeredAbility());§}§public EnduringScalelord(final EnduringScalelord card) {§super(card);§}§@Override§public EnduringScalelord copy() {§return new EnduringScalelord(this);§}§}§class EnduringScalelordTriggeredAbility extends TriggeredAbilityImpl {§EnduringScalelordTriggeredAbility() {§super(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.P1P1.createInstance()), true);§}§EnduringScalelordTriggeredAbility(final EnduringScalelordTriggeredAbility ability) {§super(ability);§}§@Override§public EnduringScalelordTriggeredAbility copy() {§return new EnduringScalelordTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.COUNTERS_ADDED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getData().equals(CounterType.P1P1.getName())) {§Permanent permanent = game.getPermanentOrLKIBattlefield(event.getTargetId());§if (permanent == null) {§permanent = game.getPermanentEntering(event.getTargetId());§}§return (permanent != null§&& !event.getTargetId().equals(this.getSourceId())§&& permanent.getCardType().contains(CardType.CREATURE)§&& permanent.getControllerId().equals(this.getControllerId()));§}§return false;§}§@Override§public String getRule() {§return "Whenever one or more +1/+1 counters are place on another creature you control, you may put a +1/+1 counter on {this}.";§}§}§
public class HarbingerOfTheHunt extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature without flying");§private static final FilterCreaturePermanent filter2 = new FilterCreaturePermanent("other creature with flying");§static {§filter.add(Predicates.not(new AbilityPredicate(FlyingAbility.class)));§filter2.add(new AbilityPredicate(FlyingAbility.class));§filter2.add(new AnotherPredicate());§}§public HarbingerOfTheHunt(UUID ownerId) {§super(ownerId, 223, "Harbinger of the Hunt", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{R}{G}");§this.expansionSetCode = "DTK";§this.subtype.add("Dragon");§this.power = new MageInt(5);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageAllEffect(1, filter), new ManaCostsImpl("{2}{R}")));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageAllEffect(1, filter2), new ManaCostsImpl("{2}{G}")));§}§public HarbingerOfTheHunt(final HarbingerOfTheHunt card) {§super(card);§}§@Override§public HarbingerOfTheHunt copy() {§return new HarbingerOfTheHunt(this);§}§}§
public class LightningBerserker extends CardImpl {§public LightningBerserker(UUID ownerId) {§super(ownerId, 146, "Lightning Berserker", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "DTK";§this.subtype.add("Human");§this.subtype.add("Berserker");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD,§new BoostSourceEffect(1, 0, Duration.EndOfTurn),§new ManaCostsImpl("{R}")));§this.addAbility(new DashAbility(this, "{R}"));§}§public LightningBerserker(final LightningBerserker card) {§super(card);§}§@Override§public LightningBerserker copy() {§return new LightningBerserker(this);§}§}§
public class OjutaisBreath extends CardImpl {§public OjutaisBreath(UUID ownerId) {§super(ownerId, 67, "Ojutai's Breath", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{U}");§this.expansionSetCode = "DTK";§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new TapTargetEffect());§this.getSpellAbility().addEffect(new DontUntapInControllersNextUntapStepTargetEffect("It"));§this.addAbility(new ReboundAbility());§}§public OjutaisBreath(final OjutaisBreath card) {§super(card);§}§@Override§public OjutaisBreath copy() {§return new OjutaisBreath(this);§}§}§
public class RevealingWind extends CardImpl {§public RevealingWind(UUID ownerId) {§super(ownerId, 197, "Revealing Wind", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{G}");§this.expansionSetCode = "DTK";§this.getSpellAbility().addEffect(new PreventAllDamageByAllEffect(Duration.EndOfTurn, true));§this.getSpellAbility().addEffect(new RevealingWindEffect());§}§public RevealingWind(final RevealingWind card) {§super(card);§}§@Override§public RevealingWind copy() {§return new RevealingWind(this);§}§}§class RevealingWindEffect extends OneShotEffect {§private static final FilterCreaturePermanent filter = new FilterAttackingOrBlockingCreature("face-down creature that's attacking or blocking");§static {§filter.add(new FaceDownPredicate());§}§public RevealingWindEffect() {§super(Outcome.Benefit);§this.staticText = "You may look at each face-down creature that's attacking or blocking";§}§public RevealingWindEffect(final RevealingWindEffect effect) {§super(effect);§}§@Override§public RevealingWindEffect copy() {§return new RevealingWindEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = source.getSourceObject(game);§if (controller != null && sourceObject != null) {§while (game.getBattlefield().count(filter, source.getOriginalId(), source.getControllerId(), game) > 0 &&§controller.chooseUse(outcome, "Look at a face-down attacking creature?", source, game)) {§if (!controller.canRespond()) {§return false;§}§Target target = new TargetCreaturePermanent(filter);§if (controller.chooseTarget(outcome, target, source, game)) {§Card card = game.getCard(target.getFirstTarget());§if (card != null) {§Cards cards = new CardsImpl();§cards.add(card);§controller.lookAtCards(sourceObject.getName(), cards, game);§game.informPlayers(controller.getLogName() + " look at a face-down attacking creature");§}§}§}§}§return true;§}§}§
public class SelfInflictedWound extends CardImpl {§public SelfInflictedWound(UUID ownerId) {§super(ownerId, 117, "Self-Inflicted Wound", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{1}{B}");§this.expansionSetCode = "DTK";§this.getSpellAbility().addTarget(new TargetOpponent());§this.getSpellAbility().addEffect(new SelfInflictedWoundEffect());§}§public SelfInflictedWound(final SelfInflictedWound card) {§super(card);§}§@Override§public SelfInflictedWound copy() {§return new SelfInflictedWound(this);§}§}§class SelfInflictedWoundEffect extends OneShotEffect {§SelfInflictedWoundEffect() {§super(Outcome.Sacrifice);§staticText = "Target opponent sacrifices a green or white creature. If that player does, he or she loses 2 life";§}§SelfInflictedWoundEffect(SelfInflictedWoundEffect effect) {§super(effect);§}§@Override§public SelfInflictedWoundEffect copy() {§return new SelfInflictedWoundEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player targetOpponent = game.getPlayer(source.getTargets().getFirstTarget());§Player controller = game.getPlayer(source.getControllerId());§if (targetOpponent == null || controller == null) {§return false;§}§FilterControlledPermanent filter = new FilterControlledPermanent("a green or white creature");§filter.add(new CardTypePredicate(CardType.CREATURE));§filter.add(new ControllerPredicate(TargetController.YOU));§filter.add(Predicates.or(new ColorPredicate(ObjectColor.GREEN), new ColorPredicate(ObjectColor.WHITE)));§TargetControlledPermanent target = new TargetControlledPermanent(1, 1, filter, true);§if (target.canChoose(source.getSourceId(), targetOpponent.getId(), game)) {§targetOpponent.chooseTarget(Outcome.Sacrifice, target, source, game);§Permanent permanent = game.getPermanent(target.getFirstTarget());§if (permanent != null) {§if (permanent.sacrifice(source.getSourceId(), game)) {§targetOpponent.loseLife(2, game);§}§}§}§return true;§}§}§
public class SilumgarsScorn extends CardImpl {§private static final FilterCard filter = new FilterCard("a Dragon card from your hand (you don't have to)");§static {§filter.add(new SubtypePredicate("Dragon"));§}§public SilumgarsScorn(UUID ownerId) {§super(ownerId, 78, "Silumgar's Scorn", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{U}{U}");§this.expansionSetCode = "DTK";§this.getSpellAbility().addEffect(new InfoEffect("As an additional cost to cast {this}, you may reveal a Dragon card from your hand"));§this.getSpellAbility().addEffect(new SilumgarsScornCounterEffect());§this.getSpellAbility().addTarget(new TargetSpell());§this.getSpellAbility().addWatcher(new DragonOnTheBattlefieldWhileSpellWasCastWatcher());§}§@Override§public void adjustCosts(Ability ability, Game game) {§if (ability.getAbilityType().equals(AbilityType.SPELL)) {§Player controller = game.getPlayer(ability.getControllerId());§if (controller != null) {§if (controller.getHand().count(filter, game) > 0) {§ability.addCost(new RevealTargetFromHandCost(new TargetCardInHand(0,1, filter)));§}§}§}§}§public SilumgarsScorn(final SilumgarsScorn card) {§super(card);§}§@Override§public SilumgarsScorn copy() {§return new SilumgarsScorn(this);§}§}§class SilumgarsScornCounterEffect extends OneShotEffect {§public SilumgarsScornCounterEffect() {§super(Outcome.Detriment);§staticText = "<br/>Counter target spell unless its controller pays {1}. If you revealed a Dragon card or controlled a Dragon as you cast {this}, counter that spell instead";§}§public SilumgarsScornCounterEffect(final SilumgarsScornCounterEffect effect) {§super(effect);§}§@Override§public SilumgarsScornCounterEffect copy() {§return new SilumgarsScornCounterEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§StackObject spell = game.getStack().getStackObject(targetPointer.getFirst(game, source));§if (spell != null) {§Player player = game.getPlayer(spell.getControllerId());§if (player != null) {§DragonOnTheBattlefieldWhileSpellWasCastWatcher watcher = (DragonOnTheBattlefieldWhileSpellWasCastWatcher) game.getState().getWatchers().get("DragonOnTheBattlefieldWhileSpellWasCastWatcher");§boolean condition = watcher != null && watcher.castWithConditionTrue(source.getId());§if (!condition) {§for (Cost cost: source.getCosts()) {§if (cost instanceof RevealTargetFromHandCost) {§condition = ((RevealTargetFromHandCost)cost).getNumberRevealedCards() > 0;§}§}§}§if (condition) {§return game.getStack().counter(spell.getId(), source.getSourceId(), game);§}§if (!(player.chooseUse(Outcome.Benefit, "Would you like to pay {1} to prevent counter effect?", source, game) &&§new GenericManaCost(1).pay(source, game, spell.getSourceId(), spell.getControllerId(), false))) {§return game.getStack().counter(spell.getId(), source.getSourceId(), game);§}§}§}§return true;§}§}§
public class TwinBolt extends CardImpl {§public TwinBolt(UUID ownerId) {§super(ownerId, 164, "Twin Bolt", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{R}");§this.expansionSetCode = "DTK";§Effect effect = new DamageMultiEffect(2);§effect.setText("{this} deals 2 damage divided as you choose among one or two target creatures and/or players");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCreatureOrPlayerAmount(2));§}§public TwinBolt(final TwinBolt card) {§super(card);§}§@Override§public TwinBolt copy() {§return new TwinBolt(this);§}§}§
public class DivingGriffin extends CardImpl {§public DivingGriffin(UUID ownerId) {§super(ownerId, 17, "Diving Griffin", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}{W}");§this.expansionSetCode = "8ED";§this.subtype.add("Griffin");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(VigilanceAbility.getInstance());§}§public DivingGriffin(final DivingGriffin card) {§super(card);§}§@Override§public DivingGriffin copy() {§return new DivingGriffin(this);§}§}§
public class BurrentonBombardier extends CardImpl {§public BurrentonBombardier (UUID ownerId) {§super(ownerId, 11, "Burrenton Bombardier", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "DDF";§this.subtype.add("Kithkin");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new ReinforceAbility(2, new ManaCostsImpl("{2}{W}")));§}§public BurrentonBombardier (final BurrentonBombardier card) {§super(card);§}§@Override§public BurrentonBombardier copy() {§return new BurrentonBombardier(this);§}§}§
public class SynodCenturion extends CardImpl {§public SynodCenturion(UUID ownerId) {§super(ownerId, 53, "Synod Centurion", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{4}");§this.expansionSetCode = "DDF";§this.subtype.add("Construct");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new SynodCenturionStateTriggeredAbility());§}§public SynodCenturion(final SynodCenturion card) {§super(card);§}§@Override§public SynodCenturion copy() {§return new SynodCenturion(this);§}§class SynodCenturionStateTriggeredAbility extends StateTriggeredAbility {§public SynodCenturionStateTriggeredAbility() {§super(Zone.BATTLEFIELD, new SacrificeSourceEffect());§}§public SynodCenturionStateTriggeredAbility(final SynodCenturionStateTriggeredAbility ability) {§super(ability);§}§@Override§public SynodCenturionStateTriggeredAbility copy() {§return new SynodCenturionStateTriggeredAbility(this);§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§for (Permanent perm : game.getBattlefield().getAllActivePermanents(controllerId)) {§if (!perm.getId().equals(this.getSourceId()) && perm.getCardType().contains(CardType.ARTIFACT)) {§return false;§}§}§return true;§}§@Override§public String getRule() {§return "When you control no other artifacts, sacrifice {this}.";§}§}§}§
public class BalefireLiege extends CardImpl {§private static final FilterCreaturePermanent filterRedCreature = new FilterCreaturePermanent("red creatures");§private static final FilterCreaturePermanent filterWhiteCreature = new FilterCreaturePermanent("white creatures");§private static final FilterSpell filterRedSpell = new FilterSpell("a red spell");§private static final FilterSpell filterWhiteSpell = new FilterSpell("a white spell");§static {§filterRedCreature.add(new ColorPredicate(ObjectColor.RED));§filterWhiteCreature.add(new ColorPredicate(ObjectColor.WHITE));§filterRedSpell.add(new ColorPredicate(ObjectColor.RED));§filterWhiteSpell.add(new ColorPredicate(ObjectColor.WHITE));§}§public BalefireLiege(UUID ownerId) {§super(ownerId, 132, "Balefire Liege", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{R/W}{R/W}{R/W}");§this.expansionSetCode = "EVE";§this.subtype.add("Spirit");§this.subtype.add("Horror");§this.power = new MageInt(2);§this.toughness = new MageInt(4);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostControlledEffect(1, 1, Duration.WhileOnBattlefield, filterRedCreature, true)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostControlledEffect(1, 1, Duration.WhileOnBattlefield, filterWhiteCreature, true)));§Ability ability = new SpellCastControllerTriggeredAbility(new DamageTargetEffect(3), filterRedSpell, false);§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§this.addAbility(new SpellCastControllerTriggeredAbility(new GainLifeEffect(3), filterWhiteSpell, false));§}§public BalefireLiege(final BalefireLiege card) {§super(card);§}§@Override§public BalefireLiege copy() {§return new BalefireLiege(this);§}§}§
public class CragPuca extends CardImpl {§public CragPuca(UUID ownerId) {§super(ownerId, 101, "Crag Puca", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{U/R}{U/R}{U/R}");§this.expansionSetCode = "EVE";§this.subtype.add("Shapeshifter");§this.power = new MageInt(2);§this.toughness = new MageInt(4);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new SwitchPowerToughnessSourceEffect(Duration.EndOfTurn), new ManaCostsImpl("{U/R}")));§}§public CragPuca(final CragPuca card) {§super(card);§}§@Override§public CragPuca copy() {§return new CragPuca(this);§}§}§
public class FableOfWolfAndOwl extends CardImpl {§private static final FilterSpell filterGreenSpell = new FilterSpell("a green spell");§private static final FilterSpell filterBlueSpell = new FilterSpell("a blue spell");§static {§filterGreenSpell.add(new ColorPredicate(ObjectColor.GREEN));§filterBlueSpell.add(new ColorPredicate(ObjectColor.BLUE));§}§public FableOfWolfAndOwl(UUID ownerId) {§super(ownerId, 150, "Fable of Wolf and Owl", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{3}{G/U}{G/U}{G/U}");§this.expansionSetCode = "EVE";§this.addAbility(new SpellCastControllerTriggeredAbility(new CreateTokenEffect(new WolfToken(), 1), filterGreenSpell, true));§this.addAbility(new SpellCastControllerTriggeredAbility(new CreateTokenEffect(new OwlToken(), 1), filterBlueSpell, true));§}§public FableOfWolfAndOwl(final FableOfWolfAndOwl card) {§super(card);§}§@Override§public FableOfWolfAndOwl copy() {§return new FableOfWolfAndOwl(this);§}§}§class OwlToken extends Token {§OwlToken() {§super("Bird", "1/1 blue Bird creature token with flying");§cardType.add(CardType.CREATURE);§color.setBlue(true);§subtype.add("Bird");§power = new MageInt(1);§toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§}§}§
public class HearthfireHobgoblin extends CardImpl {§public HearthfireHobgoblin(UUID ownerId) {§super(ownerId, 141, "Hearthfire Hobgoblin", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{R/W}{R/W}{R/W}");§this.expansionSetCode = "EVE";§this.subtype.add("Goblin");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(DoubleStrikeAbility.getInstance());§}§public HearthfireHobgoblin(final HearthfireHobgoblin card) {§super(card);§}§@Override§public HearthfireHobgoblin copy() {§return new HearthfireHobgoblin(this);§}§}§
public class MerrowBonegnawer extends CardImpl {§private UUID exileId = UUID.randomUUID();§private static final FilterSpell filter = new FilterSpell("black spell");§static {§filter.add(new ColorPredicate(ObjectColor.BLACK));§}§public MerrowBonegnawer(UUID ownerId) {§super(ownerId, 37, "Merrow Bonegnawer", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{B}");§this.expansionSetCode = "EVE";§this.subtype.add("Merfolk");§this.subtype.add("Rogue");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ExileFromZoneTargetEffect(Zone.GRAVEYARD, exileId, getIdName(), new FilterCard()), new TapSourceCost());§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§this.addAbility(new SpellCastControllerTriggeredAbility(Zone.BATTLEFIELD, new UntapSourceEffect(), filter, true, false));§}§public MerrowBonegnawer(final MerrowBonegnawer card) {§super(card);§}§@Override§public MerrowBonegnawer copy() {§return new MerrowBonegnawer(this);§}§}§
public class OutrageShaman extends CardImpl {§public OutrageShaman(UUID ownerId) {§super(ownerId, 59, "Outrage Shaman", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{R}{R}");§this.expansionSetCode = "EVE";§this.subtype.add("Goblin");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Effect effect = new DamageTargetEffect(new ChromaOutrageShamanCount());§effect.setText("<i>Chroma</i> - When Outrage Shaman enters the battlefield, it deals damage to target creature equal to the number of red mana symbols in the mana costs of permanents you control.");§Ability ability = new EntersBattlefieldTriggeredAbility(effect, false, true);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public OutrageShaman(final OutrageShaman card) {§super(card);§}§@Override§public OutrageShaman copy() {§return new OutrageShaman(this);§}§}§class ChromaOutrageShamanCount implements DynamicValue {§private int chroma;§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§chroma = 0;§for (Card card : game.getBattlefield().getAllActivePermanents(new FilterControlledPermanent(), sourceAbility.getControllerId(), game)) {§chroma += card.getManaCost().getMana().getRed();§}§return chroma;§}§@Override§public DynamicValue copy() {§return new ChromaOutrageShamanCount();§}§@Override§public String toString() {§return "1";§}§@Override§public String getMessage() {§return "";§}§}§
public class SavageConception extends CardImpl {§public SavageConception(UUID ownerId) {§super(ownerId, 75, "Savage Conception", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{3}{G}{G}");§this.expansionSetCode = "EVE";§this.getSpellAbility().addEffect(new CreateTokenEffect(new BeastToken()));§this.addAbility(new RetraceAbility(this));§}§public SavageConception(final SavageConception card) {§super(card);§}§@Override§public SavageConception copy() {§return new SavageConception(this);§}§}§
public class StreamHopper extends CardImpl {§public StreamHopper(UUID ownerId) {§super(ownerId, 113, "Stream Hopper", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{U/R}");§this.expansionSetCode = "EVE";§this.subtype.add("Goblin");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(FlyingAbility.getInstance(), Duration.EndOfTurn), new ManaCostsImpl("{U/R}")));§}§public StreamHopper(final StreamHopper card) {§super(card);§}§@Override§public StreamHopper copy() {§return new StreamHopper(this);§}§}§
public class WavesOfAggression extends CardImpl {§public WavesOfAggression(UUID ownerId) {§super(ownerId, 148, "Waves of Aggression", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{R/W}{R/W}");§this.expansionSetCode = "EVE";§this.getSpellAbility().addWatcher(new AttackedThisTurnWatcher());§this.getSpellAbility().addEffect(new WavesOfAggressionUntapEffect());§this.getSpellAbility().addEffect(new WavesOfAggressionAddPhasesEffect());§this.addAbility(new RetraceAbility(this));§}§public WavesOfAggression(final WavesOfAggression card) {§super(card);§}§@Override§public WavesOfAggression copy() {§return new WavesOfAggression(this);§}§}§class WavesOfAggressionUntapEffect extends OneShotEffect {§public WavesOfAggressionUntapEffect() {§super(Outcome.Benefit);§staticText = "Untap all creatures that attacked this turn";§}§public WavesOfAggressionUntapEffect(final WavesOfAggressionUntapEffect effect) {§super(effect);§}§@Override§public WavesOfAggressionUntapEffect copy() {§return new WavesOfAggressionUntapEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Watcher watcher = game.getState().getWatchers().get("AttackedThisTurn");§if (watcher != null && watcher instanceof AttackedThisTurnWatcher) {§Set<UUID> attackedThisTurn = ((AttackedThisTurnWatcher) watcher).getAttackedThisTurnCreatures();§for (UUID uuid : attackedThisTurn) {§Permanent permanent = game.getPermanent(uuid);§if (permanent != null && permanent.getCardType().contains(CardType.CREATURE)) {§permanent.untap(game);§}§}§return true;§}§return false;§}§}§class WavesOfAggressionAddPhasesEffect extends OneShotEffect {§public WavesOfAggressionAddPhasesEffect() {§super(Outcome.Benefit);§staticText = "After this main phase, there is an additional combat phase followed by an additional main phase";§}§public WavesOfAggressionAddPhasesEffect(final WavesOfAggressionAddPhasesEffect effect) {§super(effect);§}§@Override§public WavesOfAggressionAddPhasesEffect copy() {§return new WavesOfAggressionAddPhasesEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§if (TurnPhase.PRECOMBAT_MAIN.equals(game.getTurn().getPhaseType()) || TurnPhase.POSTCOMBAT_MAIN.equals(game.getTurn().getPhaseType())) {§TurnMod combat = new TurnMod(source.getControllerId(), TurnPhase.COMBAT, TurnPhase.POSTCOMBAT_MAIN, false);§game.getState().getTurnMods().add(combat);§WavesOfAggressionDelayedAddMainPhaseAbility delayedTriggeredAbility = new WavesOfAggressionDelayedAddMainPhaseAbility();§delayedTriggeredAbility.setConnectedTurnMod(combat.getId());§game.addDelayedTriggeredAbility(delayedTriggeredAbility, source);§return true;§}§return false;§}§}§class WavesOfAggressionDelayedAddMainPhaseAbility extends DelayedTriggeredAbility {§private UUID connectedTurnMod;§private boolean enabled;§public WavesOfAggressionDelayedAddMainPhaseAbility() {§super(null, Duration.EndOfTurn);§this.usesStack = false; §
public class ErraticPortal extends CardImpl {§public ErraticPortal(UUID ownerId) {§super(ownerId, 132, "Erratic Portal", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "EXO";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ErraticPortalEffect(new GenericManaCost(1)), new ManaCostsImpl("{1}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public ErraticPortal(final ErraticPortal card) {§super(card);§}§@Override§public ErraticPortal copy() {§return new ErraticPortal(this);§}§}§class ErraticPortalEffect extends OneShotEffect {§protected Cost cost;§public ErraticPortalEffect(Cost cost) {§super(Outcome.Detriment);§this.staticText = "Return target creature to its owner's hand unless its controller pays {1}";§this.cost = cost;§}§public ErraticPortalEffect(final ErraticPortalEffect effect) {§super(effect);§this.cost = effect.cost.copy();§}§@Override§public ErraticPortalEffect copy() {§return new ErraticPortalEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Permanent targetCreature = game.getPermanent(getTargetPointer().getFirst(game, source));§if (targetCreature != null) {§Player player = game.getPlayer(targetCreature.getControllerId());§if (player != null) {§cost.clearPaid();§if (player.chooseUse(Outcome.Benefit, "Pay {1}? (Otherwise " + targetCreature.getLogName() +" will be returned to its owner's hand)", source, game)) {§cost.pay(source, game, targetCreature.getControllerId(), targetCreature.getControllerId(), false, null);§}§if (!cost.isPaid()) {§controller.moveCards(targetCreature, Zone.BATTLEFIELD, Zone.HAND, source, game);§}§}§}§return true;§}§return false;§}§}§
public class PegasusStampede extends CardImpl {§public PegasusStampede(UUID ownerId) {§super(ownerId, 14, "Pegasus Stampede", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{1}{W}");§this.expansionSetCode = "EXO";§this.addAbility(new BuybackAbility(new SacrificeTargetCost(new TargetControlledPermanent(1,1, new FilterControlledLandPermanent(), true))));§this.getSpellAbility().addEffect(new CreateTokenEffect(new PegasusToken()));§}§public PegasusStampede(final PegasusStampede card) {§super(card);§}§@Override§public PegasusStampede copy() {§return new PegasusStampede(this);§}§}§
public class SpikeRogue extends CardImpl {§public SpikeRogue(UUID ownerId) {§super(ownerId, 127, "Spike Rogue", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{G}{G}");§this.expansionSetCode = "EXO";§this.subtype.add("Spike");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(new EntersBattlefieldAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance(2))));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersTargetEffect(CounterType.P1P1.createInstance()), new GenericManaCost(2));§ability.addCost(new RemoveCountersSourceCost(CounterType.P1P1.createInstance()));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§Ability ability2 = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.P1P1.createInstance(1)), new GenericManaCost(2));§ability2.addCost(new RemoveCounterCost(new TargetControlledCreaturePermanent(1,1, new FilterControlledCreaturePermanent(), true), CounterType.P1P1));§this.addAbility(ability2);§}§public SpikeRogue(final SpikeRogue card) {§super(card);§}§@Override§public SpikeRogue copy() {§return new SpikeRogue(this);§}§}§
public class DwarvenRuins extends CardImpl {§public DwarvenRuins(UUID ownerId) {§super(ownerId, 179, "Dwarven Ruins", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "FEM";§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new RedManaAbility());§Ability ability = new SimpleManaAbility(Zone.BATTLEFIELD, new BasicManaEffect(Mana.RedMana(2)), new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public DwarvenRuins(final DwarvenRuins card) {§super(card);§}§@Override§public DwarvenRuins copy() {§return new DwarvenRuins(this);§}§}§
public class IcatianMoneychanger1 extends CardImpl {§public IcatianMoneychanger1(UUID ownerId) {§super(ownerId, 152, "Icatian Moneychanger", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{W}");§this.expansionSetCode = "FEM";§this.subtype.add("Human");§this.power = new MageInt(0);§this.toughness = new MageInt(2);§Effect effect = new AddCountersSourceEffect(CounterType.CREDIT.createInstance(3));§effect.setText("with three credit counters on it");§this.addAbility(new EntersBattlefieldAbility(effect));§effect = new DamageControllerEffect(3);§effect.setText("it deals 3 damage to you");§this.addAbility(new EntersBattlefieldTriggeredAbility(effect, false));§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new AddCountersSourceEffect(CounterType.CREDIT.createInstance()), TargetController.YOU, false));§this.addAbility(new ConditionalActivatedAbility(Zone.BATTLEFIELD,§new GainLifeEffect(new CountersCount(CounterType.CREDIT)), new SacrificeSourceCost(), new IsStepCondition(PhaseStep.UPKEEP), null));§}§public IcatianMoneychanger1(final IcatianMoneychanger1 card) {§super(card);§}§@Override§public IcatianMoneychanger1 copy() {§return new IcatianMoneychanger1(this);§}§}§
public class AbzanBeastmaster extends CardImpl {§public AbzanBeastmaster(UUID ownerId) {§super(ownerId, 119, "Abzan Beastmaster", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "FRF";§this.subtype.add("Hound");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new ConditionalTriggeredAbility(§new BeginningOfUpkeepTriggeredAbility(new DrawCardSourceControllerEffect(1), TargetController.YOU, false),§ControlsCreatureGreatestToughnessCondition.getInstance(),§"At the beginning of your upkeep, draw a card if you control the creature with the greatest toughness or tied for the greatest toughness."§));§}§public AbzanBeastmaster(final AbzanBeastmaster card) {§super(card);§}§@Override§public AbzanBeastmaster copy() {§return new AbzanBeastmaster(this);§}§}§
public class BloodfireEnforcers extends CardImpl {§public BloodfireEnforcers(UUID ownerId) {§super(ownerId, 93, "Bloodfire Enforcers", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "FRF";§this.subtype.add("Human");§this.subtype.add("Monk");§this.power = new MageInt(5);§this.toughness = new MageInt(2);§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD,§new ConditionalContinuousEffect(new GainAbilitySourceEffect(FirstStrikeAbility.getInstance(), Duration.WhileOnBattlefield),§new BloodfireEnforcersCondition(), "{this} has first strike"));§ability.addEffect(new ConditionalContinuousEffect(new GainAbilitySourceEffect(TrampleAbility.getInstance(), Duration.WhileOnBattlefield),§new BloodfireEnforcersCondition(), "and trample as long as an instant card and a sorcery card are in your graveyard"));§this.addAbility(ability);§}§public BloodfireEnforcers(final BloodfireEnforcers card) {§super(card);§}§@Override§public BloodfireEnforcers copy() {§return new BloodfireEnforcers(this);§}§}§class BloodfireEnforcersCondition implements Condition {§private static final FilterInstantOrSorceryCard filter = new FilterInstantOrSorceryCard();§@Override§public boolean apply(Game game, Ability source) {§boolean instantFound = false;§boolean sorceryFound = false;§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§for(Card card : player.getGraveyard().getCards(game)) {§if (card.getCardType().contains(CardType.INSTANT)) {§if (sorceryFound) {§return true;§}§instantFound = true;§} else if (card.getCardType().contains(CardType.SORCERY)) {§if (instantFound) {§return true;§}§sorceryFound = true;§}§}§}§return false;§}§}§
public class EliteScaleguard extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("creature you control with a +1/+1 counter on it");§static {§filter.add(new CounterPredicate(CounterType.P1P1));§}§public EliteScaleguard(UUID ownerId) {§super(ownerId, 12, "Elite Scaleguard", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{W}");§this.expansionSetCode = "FRF";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(new EntersBattlefieldTriggeredAbility(new BolsterEffect(2)));§Ability ability = new AttacksCreatureYouControlTriggeredAbility(new EliteScaleguardTapEffect(), false, filter, true);§ability.addTarget(new TargetCreaturePermanent(new FilterCreaturePermanent("creature defending player controls")));§this.addAbility(ability);§}§public EliteScaleguard(final EliteScaleguard card) {§super(card);§}§@Override§public void adjustTargets(Ability ability, Game game) {§if (ability instanceof AttacksCreatureYouControlTriggeredAbility) {§FilterCreaturePermanent filterDefender = new FilterCreaturePermanent("creature defending player controls");§for (Effect effect : ability.getEffects()) {§if (effect instanceof EliteScaleguardTapEffect) {§filterDefender.add(new ControllerIdPredicate(game.getCombat().getDefendingPlayerId(effect.getTargetPointer().getFirst(game, ability), game)));§break;§}§}§ability.getTargets().clear();§TargetCreaturePermanent target = new TargetCreaturePermanent(filterDefender);§ability.addTarget(target);§}§}§@Override§public EliteScaleguard copy() {§return new EliteScaleguard(this);§}§}§class EliteScaleguardTapEffect extends TapTargetEffect {§EliteScaleguardTapEffect() {§super();§}§EliteScaleguardTapEffect(final EliteScaleguardTapEffect effect) {§super(effect);§}§@Override§public EliteScaleguardTapEffect copy() {§return new EliteScaleguardTapEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(source.getFirstTarget());§if (permanent != null) {§permanent.tap(game);§return true;§}§return false;§}§}§
public class GreatHornKrushok extends CardImpl {§public GreatHornKrushok(UUID ownerId) {§super(ownerId, 13, "Great-Horn Krushok", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{W}");§this.expansionSetCode = "FRF";§this.subtype.add("Beast");§this.power = new MageInt(3);§this.toughness = new MageInt(5);§}§public GreatHornKrushok(final GreatHornKrushok card) {§super(card);§}§@Override§public GreatHornKrushok copy() {§return new GreatHornKrushok(this);§}§}§
public class MarangRiverProwler extends CardImpl {§public MarangRiverProwler(UUID ownerId) {§super(ownerId, 40, "Marang River Prowler", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "FRF";§this.subtype.add("Human");§this.subtype.add("Rogue");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new CantBlockSourceEffect(Duration.WhileOnBattlefield));§Effect effect = new CantBeBlockedSourceEffect();§effect.setText("and can't be blocked");§ability.addEffect(effect);§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.GRAVEYARD, new MarangRiverProwlerCastEffect()));§}§public MarangRiverProwler(final MarangRiverProwler card) {§super(card);§}§@Override§public MarangRiverProwler copy() {§return new MarangRiverProwler(this);§}§}§class MarangRiverProwlerCastEffect extends AsThoughEffectImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("a black or green permanent");§static {§filter.add(Predicates.or(new ColorPredicate(ObjectColor.BLACK), new ColorPredicate(ObjectColor.GREEN)));§}§MarangRiverProwlerCastEffect() {§super(AsThoughEffectType.PLAY_FROM_NOT_OWN_HAND_ZONE, Duration.EndOfGame, Outcome.Benefit);§staticText = "You may cast {this} from your graveyard as long as you control a black or green permanent";§}§MarangRiverProwlerCastEffect(final MarangRiverProwlerCastEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public MarangRiverProwlerCastEffect copy() {§return new MarangRiverProwlerCastEffect(this);§}§@Override§public boolean applies(UUID sourceId, Ability source, UUID affectedControllerId, Game game) {§if (sourceId.equals(source.getSourceId())) {§Card card = game.getCard(source.getSourceId());§if (card != null§&& card.getOwnerId().equals(affectedControllerId)§&& game.getState().getZone(source.getSourceId()) == Zone.GRAVEYARD§&& game.getBattlefield().count(filter, source.getSourceId(), source.getControllerId(), game) > 0) {§return true;§}§}§return false;§}§}§
public class PressurePoint extends CardImpl {§public PressurePoint(UUID ownerId) {§super(ownerId, 21, "Pressure Point", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{W}");§this.expansionSetCode = "FRF";§this.getSpellAbility().addEffect(new TapTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));§}§public PressurePoint(final PressurePoint card) {§super(card);§}§@Override§public PressurePoint copy() {§return new PressurePoint(this);§}§}§
public class ShiftingLoyalties extends CardImpl {§public ShiftingLoyalties(UUID ownerId) {§super(ownerId, 51, "Shifting Loyalties", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{5}{U}");§this.expansionSetCode = "FRF";§this.getSpellAbility().addEffect(new ExchangeControlTargetEffect(Duration.EndOfGame, "Exchange control of two target permanents that share a card type. <i>(Artifact, creature, enchantment, land, and planeswalker are card types.)</i>"));§this.getSpellAbility().addTarget(new TargetPermanentsThatShareCardType());§}§public ShiftingLoyalties(final ShiftingLoyalties card) {§super(card);§}§@Override§public ShiftingLoyalties copy() {§return new ShiftingLoyalties(this);§}§}§class TargetPermanentsThatShareCardType extends TargetPermanent {§public TargetPermanentsThatShareCardType() {§super(2, 2, new FilterPermanent(), false);§targetName = "permanents that share a card type";§}§public TargetPermanentsThatShareCardType(final TargetPermanentsThatShareCardType target) {§super(target);§}§@Override§public boolean canTarget(UUID controllerId, UUID id, Ability source, Game game) {§if (super.canTarget(controllerId, id, source, game)) {§if (!getTargets().isEmpty()) {§Permanent targetOne = game.getPermanent(getTargets().get(0));§Permanent targetTwo = game.getPermanent(id);§if (targetOne == null || targetTwo == null) {§return false;§}§return CardUtil.shareTypes(targetOne, targetTwo);§}§return true;§}§return false;§}§@Override§public boolean canChoose(UUID sourceId, UUID sourceControllerId, Game game) {§Set<CardType> cardTypes = new HashSet<>();§MageObject targetSource = game.getObject(sourceId);§for (Permanent permanent: game.getBattlefield().getActivePermanents(filter, sourceControllerId, sourceId, game)) {§if (permanent.canBeTargetedBy(targetSource, sourceControllerId, game)) {§for (CardType cardType :permanent.getCardType()) {§if (cardTypes.contains(cardType)) {§return true;§}§}§cardTypes.addAll(permanent.getCardType());§}§}§return false;§}§@Override§public TargetPermanentsThatShareCardType copy() {§return new TargetPermanentsThatShareCardType(this);§}§}§
public class TemurSabertooth extends CardImpl {§public TemurSabertooth(UUID ownerId) {§super(ownerId, 141, "Temur Sabertooth", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{G}{G}");§this.expansionSetCode = "FRF";§this.subtype.add("Cat");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new TemurSabertoothEffect(), new ManaCostsImpl("{1}{G}")));§}§public TemurSabertooth(final TemurSabertooth card) {§super(card);§}§@Override§public TemurSabertooth copy() {§return new TemurSabertooth(this);§}§}§class TemurSabertoothEffect extends OneShotEffect {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("another creature you control");§static {§filter.add(new AnotherPredicate());§}§public TemurSabertoothEffect() {§super(Outcome.Detriment);§this.staticText = "You may return another creature you control to its owner's hand. If you do, {this} gains indestructible until end of turn";§}§public TemurSabertoothEffect(final TemurSabertoothEffect effect) {§super(effect);§}§@Override§public TemurSabertoothEffect copy() {§return new TemurSabertoothEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Target target = new TargetPermanent(1, 1, filter, true);§if (target.canChoose(source.getSourceId(), controller.getId(), game)) {§if (controller.chooseUse(outcome, "Return another creature to hand?", source, game)§&& controller.chooseTarget(outcome, target, source, game)) {§Permanent toHand = game.getPermanent(target.getFirstTarget());§if (toHand != null) {§controller.moveCards(toHand, null, Zone.HAND, source, game);§}§game.addEffect(new GainAbilitySourceEffect(IndestructibleAbility.getInstance(), Duration.EndOfTurn), source);§}§}§return true;§}§return false;§}§}§
public class AbunasChant extends CardImpl {§public AbunasChant(UUID ownerId) {§super(ownerId, 1, "Abuna's Chant", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{3}{W}");§this.expansionSetCode = "5DN";§this.getSpellAbility().getModes().setMinModes(1);§this.getSpellAbility().getModes().setMaxModes(1);§this.getSpellAbility().addEffect(new GainLifeEffect(5));§Mode mode = new Mode();§mode.getEffects().add(new PreventDamageToTargetEffect(Duration.EndOfTurn, 5));§mode.getTargets().add(new TargetCreaturePermanent());§this.getSpellAbility().getModes().addMode(mode);§this.addAbility(new EntwineAbility("{2}"));§}§public AbunasChant(final AbunasChant card) {§super(card);§}§@Override§public AbunasChant copy() {§return new AbunasChant(this);§}§}§
public class BringerOfTheRedDawn extends CardImpl {§public BringerOfTheRedDawn(UUID ownerId) {§super(ownerId, 62, "Bringer of the Red Dawn", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{7}{R}{R}");§this.expansionSetCode = "5DN";§this.subtype.add("Bringer");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(new AlternativeCostSourceAbility(new ManaCostsImpl("{W}{U}{B}{R}{G}")));§this.addAbility(TrampleAbility.getInstance());§Effect effect = new UntapTargetEffect();§effect.setText("untap target creature");§Ability ability = new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, effect, TargetController.YOU, true);§effect = new GainControlTargetEffect(Duration.EndOfTurn);§effect.setText("and gain control of it until end of turn.");§ability.addEffect(effect);§effect = new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.EndOfTurn);§effect.setText("That creature gains haste until end of turn.");§ability.addEffect(effect);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public BringerOfTheRedDawn(final BringerOfTheRedDawn card) {§super(card);§}§@Override§public BringerOfTheRedDawn copy() {§return new BringerOfTheRedDawn(this);§}§}§
public class EyesOfTheWatcher extends CardImpl {§private static final FilterSpell filter = new FilterSpell("an instant or sorcery spell");§static{§filter.add(Predicates.or(new CardTypePredicate(CardType.INSTANT), new CardTypePredicate(CardType.SORCERY)));§}§public EyesOfTheWatcher(UUID ownerId) {§super(ownerId, 30, "Eyes of the Watcher", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{U}");§this.expansionSetCode = "5DN";§this.addAbility(new SpellCastControllerTriggeredAbility(new DoIfCostPaid(new ScryEffect(2), new ManaCostsImpl("{1}")), filter, true));§}§public EyesOfTheWatcher(final EyesOfTheWatcher card) {§super(card);§}§@Override§public EyesOfTheWatcher copy() {§return new EyesOfTheWatcher(this);§}§}§
public class HoverguardSweepers extends CardImpl {§public HoverguardSweepers(UUID ownerId) {§super(ownerId, 32, "Hoverguard Sweepers", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{6}{U}{U}");§this.expansionSetCode = "5DN";§this.subtype.add("Drone");§this.power = new MageInt(5);§this.toughness = new MageInt(6);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new ReturnToHandTargetEffect(), true);§ability.addTarget(new TargetCreaturePermanent(0, 2));§this.addAbility(ability);§}§public HoverguardSweepers(final HoverguardSweepers card) {§super(card);§}§@Override§public HoverguardSweepers copy() {§return new HoverguardSweepers(this);§}§}§
public class MyrServitor extends CardImpl {§public MyrServitor(UUID ownerId) {§super(ownerId, 139, "Myr Servitor", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{1}");§this.expansionSetCode = "5DN";§this.subtype.add("Myr");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new ConditionalTriggeredAbility(§new BeginningOfUpkeepTriggeredAbility(new MyrServitorReturnEffect(), TargetController.YOU, false),§SourceOnBattlefieldCondition.getInstance(),§"At the beginning of your upkeep, if {this} is on the battlefield, each player returns all cards named Myr Servitor from his or her graveyard to the battlefield"§));§}§public MyrServitor(final MyrServitor card) {§super(card);§}§@Override§public MyrServitor copy() {§return new MyrServitor(this);§}§}§class MyrServitorReturnEffect extends OneShotEffect {§private static final FilterCard filter = new FilterCard("cards named Myr Servitor");§static {§filter.add(new NamePredicate("Myr Servitor"));§}§public MyrServitorReturnEffect() {§super(Outcome.PutCardInPlay);§this.staticText = "if {this} is on the battlefield, each player returns all cards named Myr Servitor from his or her graveyard to the battlefield";§}§public MyrServitorReturnEffect(final MyrServitorReturnEffect effect) {§super(effect);§}§@Override§public MyrServitorReturnEffect copy() {§return new MyrServitorReturnEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§controller.moveCards(player.getGraveyard().getCards(filter, game), Zone.BATTLEFIELD, source, game);§}§}§return true;§}§return false;§}§}§
public class ShatteredDreams extends CardImpl {§private static final FilterCard filter = new FilterCard("an artifact card from it");§static {§filter.add(new CardTypePredicate(CardType.ARTIFACT));§}§public ShatteredDreams(UUID ownerId) {§super(ownerId, 59, "Shattered Dreams", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{B}");§this.expansionSetCode = "5DN";§this.getSpellAbility().addTarget(new TargetOpponent());§this.getSpellAbility().addEffect(new DiscardCardYouChooseTargetEffect(filter));§}§public ShatteredDreams(final ShatteredDreams card) {§super(card);§}§@Override§public ShatteredDreams copy() {§return new ShatteredDreams(this);§}§}§
public class Vanquish extends CardImpl {§public Vanquish(UUID ownerId) {§super(ownerId, 20, "Vanquish", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{2}{W}");§this.expansionSetCode = "5DN";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent(new FilterBlockingCreature()));§}§public Vanquish(final Vanquish card) {§super(card);§}§@Override§public Vanquish copy() {§return new Vanquish(this);§}§}§
public class BogImp extends CardImpl {§public BogImp(UUID ownerId) {§super(ownerId, 7, "Bog Imp", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "5ED";§this.subtype.add("Imp");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§}§public BogImp(final BogImp card) {§super(card);§}§@Override§public BogImp copy() {§return new BogImp(this);§}§}§
public class FireDrake extends CardImpl {§public FireDrake(UUID ownerId) {§super(ownerId, 226, "Fire Drake", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{R}{R}");§this.expansionSetCode = "5ED";§this.subtype.add("Drake");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new LimitedTimesPerTurnActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 0, Duration.EndOfTurn), new ManaCostsImpl("{R}")));§}§public FireDrake(final FireDrake card) {§super(card);§}§@Override§public FireDrake copy() {§return new FireDrake(this);§}§}§
public class LordOfAtlantis extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Merfolk creatures");§static {§filter.add(new SubtypePredicate("Merfolk"));§}§public LordOfAtlantis(UUID ownerId) {§super(ownerId, 100, "Lord of Atlantis", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{U}{U}");§this.expansionSetCode = "5ED";§this.subtype.add("Merfolk");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Effect effect = new BoostAllEffect(1, 1, Duration.WhileOnBattlefield, filter, true);§effect.setText("Other Merfolk creatures get +1/+1");§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, effect);§effect = new GainAbilityAllEffect(new IslandwalkAbility(), Duration.WhileOnBattlefield, filter, true);§effect.setText("and have islandwalk");§ability.addEffect(effect);§this.addAbility(ability);§}§public LordOfAtlantis(final LordOfAtlantis card) {§super(card);§}§@Override§public LordOfAtlantis copy() {§return new LordOfAtlantis(this);§}§}§
public class SabretoothTiger extends CardImpl {§public SabretoothTiger(UUID ownerId) {§super(ownerId, 264, "Sabretooth Tiger", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "5ED";§this.subtype.add("Cat");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(FirstStrikeAbility.getInstance());§}§public SabretoothTiger(final SabretoothTiger card) {§super(card);§}§@Override§public SabretoothTiger copy() {§return new SabretoothTiger(this);§}§}§
public class WarpArtifact extends CardImpl {§public WarpArtifact(UUID ownerId) {§super(ownerId, 66, "Warp Artifact", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{B}{B}");§this.expansionSetCode = "5ED";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetArtifactPermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));§this.addAbility(new EnchantAbility(auraTarget.getTargetName()));§Effect effect = new DamageTargetEffect(1);§effect.setText("{this} deals 1 damage to that player");§this.addAbility(new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, effect,§TargetController.CONTROLLER_ATTACHED_TO, false, true));§}§public WarpArtifact(final WarpArtifact card) {§super(card);§}§@Override§public WarpArtifact copy() {§return new WarpArtifact(this);§}§}§
public class IslandFishJasconius extends CardImpl {§public IslandFishJasconius(UUID ownerId) {§super(ownerId, 78, "Island Fish Jasconius", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{U}{U}{U}");§this.expansionSetCode = "4ED";§this.subtype.add("Fish");§this.power = new MageInt(6);§this.toughness = new MageInt(8);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new DontUntapInControllersUntapStepSourceEffect()));§this.addAbility(new BeginningOfUpkeepTriggeredAbility(§Zone.BATTLEFIELD,§new DoIfCostPaid(new UntapSourceEffect(), new ManaCostsImpl("{U}{U}{U}")),§TargetController.YOU,§false));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CantAttackUnlessDefenderControllsPermanent(new FilterLandPermanent("Island", "an Island"))));§this.addAbility(new ControlsPermanentsControllerTriggeredAbility(§new FilterLandPermanent("Island", "no Islands"), Filter.ComparisonType.Equal, 0,§new SacrificeSourceEffect()));§}§public IslandFishJasconius(final IslandFishJasconius card) {§super(card);§}§@Override§public IslandFishJasconius copy() {§return new IslandFishJasconius(this);§}§}§
public class AugurIlVec extends CardImpl {§public AugurIlVec(UUID ownerId) {§super(ownerId, 2, "Augur il-Vec", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "FUT";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§this.addAbility(ShadowAbility.getInstance());§this.addAbility(new ConditionalActivatedAbility(Zone.BATTLEFIELD,§new GainLifeEffect(4),§new SacrificeSourceCost(),§new IsStepCondition(PhaseStep.UPKEEP), null));§}§public AugurIlVec(final AugurIlVec card) {§super(card);§}§@Override§public AugurIlVec copy() {§return new AugurIlVec(this);§}§}§
public class DakmorSalvage extends CardImpl {§public DakmorSalvage(UUID ownerId) {§super(ownerId, 169, "Dakmor Salvage", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "FUT";§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new BlackManaAbility());§this.addAbility(new DredgeAbility(2));§}§public DakmorSalvage(final DakmorSalvage card) {§super(card);§}§@Override§public DakmorSalvage copy() {§return new DakmorSalvage(this);§}§}§
public class HomingSliver extends CardImpl {§private static final FilterCard filter = new FilterCard("Sliver card");§static {§filter.add(new SubtypePredicate("Sliver"));§}§public HomingSliver(UUID ownerId) {§super(ownerId, 118, "Homing Sliver", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "FUT";§this.subtype.add("Sliver");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new HomingSliverEffect()));§this.addAbility(new CyclingAbility(new ManaCostsImpl("{3}"), filter, "Slivercycling"));§}§public HomingSliver(final HomingSliver card) {§super(card);§}§@Override§public HomingSliver copy() {§return new HomingSliver(this);§}§}§class HomingSliverEffect extends ContinuousEffectImpl {§private static final FilterCard filter = new FilterCard("Sliver card");§static {§filter.add(new SubtypePredicate("Sliver"));§}§public HomingSliverEffect() {§super(Duration.WhileOnBattlefield, Layer.AbilityAddingRemovingEffects_6, SubLayer.NA, Outcome.AddAbility);§this.staticText = "each Sliver card in each player's hand has slivercycling {3}";§}§public HomingSliverEffect(final HomingSliverEffect effect) {§super(effect);§}§@Override§public HomingSliverEffect copy() {§return new HomingSliverEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§for (UUID playerId: game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§for (Card card : player.getHand().getCards(filter, game)) {§game.getState().addOtherAbility(card, new CyclingAbility(new GenericManaCost(3), filter, "Slivercycling"));§}§}§}§return true;§}§return false;§}§}§
public class MagusOfTheMoon extends CardImpl {§private static final FilterLandPermanent filter = new FilterLandPermanent();§static {§filter.add(Predicates.not(new SupertypePredicate("Basic")));§}§public MagusOfTheMoon(UUID ownerId) {§super(ownerId, 101, "Magus of the Moon", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "FUT";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new MagusOfTheMoonEffect()));§}§public MagusOfTheMoon(final MagusOfTheMoon card) {§super(card);§}§@Override§public MagusOfTheMoon copy() {§return new MagusOfTheMoon(this);§}§class MagusOfTheMoonEffect extends ContinuousEffectImpl {§MagusOfTheMoonEffect() {§super(Duration.WhileOnBattlefield, Outcome.Detriment);§this.staticText = "Nonbasic lands are Mountains";§dependencyTypes.add(DependencyType.BecomeMountain);§}§MagusOfTheMoonEffect(final MagusOfTheMoonEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§return false;§}§@Override§public MagusOfTheMoonEffect copy() {§return new MagusOfTheMoonEffect(this);§}§@Override§public boolean apply(Layer layer, SubLayer sublayer, Ability source, Game game) {§for (Permanent land : game.getBattlefield().getActivePermanents(filter, source.getControllerId(), game)) {§switch (layer) {§case TypeChangingEffects_4:§land.removeAllAbilities(source.getSourceId(), game);§land.getSubtype().removeAll(CardRepository.instance.getLandTypes());§land.getSubtype().add("Mountain");§break;§case AbilityAddingRemovingEffects_6:§land.addAbility(new RedManaAbility(), source.getSourceId(), game);§break;§}§}§return true;§}§@Override§public boolean hasLayer(Layer layer) {§return layer == Layer.AbilityAddingRemovingEffects_6 || layer == Layer.TypeChangingEffects_4;§}§}§}§
public class ScourgeOfKherRidges extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature without flying");§private static final FilterCreaturePermanent filter2 = new FilterCreaturePermanent("other creature with flying");§static {§filter.add(Predicates.not(new AbilityPredicate(FlyingAbility.class)));§filter2.add(new AbilityPredicate(FlyingAbility.class));§filter2.add(new AnotherPredicate());§}§public ScourgeOfKherRidges(UUID ownerId) {§super(ownerId, 107, "Scourge of Kher Ridges", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{6}{R}{R}");§this.expansionSetCode = "FUT";§this.subtype.add("Dragon");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageAllEffect(2, filter), new ManaCostsImpl("{1}{R}"));§this.addAbility(ability);§Ability ability2 = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageAllEffect(6, filter2), new ManaCostsImpl("{5}{R}"));§this.addAbility(ability2);§}§public ScourgeOfKherRidges(final ScourgeOfKherRidges card) {§super(card);§}§@Override§public ScourgeOfKherRidges copy() {§return new ScourgeOfKherRidges(this);§}§}§
public class TolariaWest extends CardImpl {§public TolariaWest(UUID ownerId) {§super(ownerId, 173, "Tolaria West", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "FUT";§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new BlueManaAbility());§this.addAbility(new TransmuteAbility("{1}{U}{U}"));§}§public TolariaWest(final TolariaWest card) {§super(card);§}§@Override§public TolariaWest copy() {§return new TolariaWest(this);§}§}§
public class AngelicSkirmisher extends CardImpl {§private static final Choice abilityChoice = new ChoiceImpl(true);§private static final Set<String> abilityChoices = new HashSet<String>();§static {§abilityChoice.setMessage("Choose ability for your creatures");§abilityChoices.add("First strike");§abilityChoices.add("Vigilance");§abilityChoices.add("Lifelink");§abilityChoice.setChoices(abilityChoices);§}§public AngelicSkirmisher(UUID ownerId) {§super(ownerId, 3, "Angelic Skirmisher", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{W}{W}");§this.expansionSetCode = "GTC";§this.subtype.add("Angel");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new BeginningOfCombatTriggeredAbility(new AngelicSkirmisherEffect(), TargetController.ANY, false);§ability.addChoice(abilityChoice);§this.addAbility(ability);§}§public AngelicSkirmisher(final AngelicSkirmisher card) {§super(card);§}§@Override§public AngelicSkirmisher copy() {§return new AngelicSkirmisher(this);§}§}§class AngelicSkirmisherEffect extends OneShotEffect {§AngelicSkirmisherEffect() {§super(Outcome.AddAbility);§staticText = "choose first strike, vigilance or lifelink. Creatures you control gain that ability until end of turn";§}§AngelicSkirmisherEffect(final AngelicSkirmisherEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Choice abilityChoice = source.getChoices().get(0);§Player controller = game.getPlayer(source.getControllerId());§Permanent sourcePermanent = game.getPermanent(source.getSourceId());§if (controller != null && sourcePermanent != null && abilityChoice != null && abilityChoice.isChosen()) {§Ability ability = null;§if (abilityChoice.getChoice().equals("First strike")) {§ability = FirstStrikeAbility.getInstance();§} else if (abilityChoice.getChoice().equals("Vigilance")) {§ability = VigilanceAbility.getInstance();§} else if (abilityChoice.getChoice().equals("Lifelink")) {§ability = LifelinkAbility.getInstance();§}§if (ability != null) {§GainAbilityControlledEffect effect = new GainAbilityControlledEffect(ability, Duration.EndOfTurn, new FilterControlledCreaturePermanent());§game.addEffect(effect, source);§game.informPlayers(new StringBuilder(sourcePermanent.getName())§.append(": ")§.append(controller.getLogName())§.append(" has chosen ")§.append(abilityChoice.getChoice().toLowerCase()).toString());§return true;§}§}§return false;§}§@Override§public AngelicSkirmisherEffect copy() {§return new AngelicSkirmisherEffect(this);§}§}§
public class BorosReckoner extends CardImpl {§public BorosReckoner(UUID ownerId) {§super(ownerId, 215, "Boros Reckoner", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{R/W}{R/W}{R/W}");§this.expansionSetCode = "GTC";§this.subtype.add("Minotaur");§this.subtype.add("Wizard");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§Ability ability = new DealtDamageToSourceTriggeredAbility(Zone.BATTLEFIELD, new BorosReckonerDealDamageEffect(), false);§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§this.addAbility(new SimpleActivatedAbility(§Zone.BATTLEFIELD, new GainAbilitySourceEffect(FirstStrikeAbility.getInstance(),Duration.EndOfTurn), new ManaCostsImpl("{R/W}")));§}§public BorosReckoner(final BorosReckoner card) {§super(card);§}§@Override§public BorosReckoner copy() {§return new BorosReckoner(this);§}§}§class BorosReckonerDealDamageEffect extends OneShotEffect {§public BorosReckonerDealDamageEffect() {§super(Outcome.Damage);§this.staticText = "it deals that much damage to target creature or player";§}§public BorosReckonerDealDamageEffect(final BorosReckonerDealDamageEffect effect) {§super(effect);§}§@Override§public BorosReckonerDealDamageEffect copy() {§return new BorosReckonerDealDamageEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§int amount = (Integer) getValue("damage");§if (amount > 0) {§Player player = game.getPlayer(targetPointer.getFirst(game, source));§if (player != null) {§player.damage(amount, source.getSourceId(), game, false, true);§return true;§}§Permanent creature = game.getPermanent(targetPointer.getFirst(game, source));§if (creature != null) {§creature.damage(amount, source.getSourceId(), game, false, true);§return true;§}§}§return false;§}§}§
public class DeathsApproach extends CardImpl {§public DeathsApproach(UUID ownerId) {§super(ownerId, 62, "Death's Approach", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{B}");§this.expansionSetCode = "GTC";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.UnboostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§DynamicValue unboost = new SignInversionDynamicValue(§new CardsInEnchantedCreaturesControllerGraveyardCount(new FilterCreatureCard("creature cards in it's controller's graveyard")));§ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(unboost,unboost, Duration.WhileOnBattlefield));§this.addAbility(ability);§}§public DeathsApproach(final DeathsApproach card) {§super(card);§}§@Override§public DeathsApproach copy() {§return new DeathsApproach(this);§}§}§class CardsInEnchantedCreaturesControllerGraveyardCount implements DynamicValue {§private FilterCard filter;§public CardsInEnchantedCreaturesControllerGraveyardCount(FilterCard filter) {§this.filter = filter;§}§public CardsInEnchantedCreaturesControllerGraveyardCount(final CardsInEnchantedCreaturesControllerGraveyardCount dynamicValue) {§this.filter = dynamicValue.filter;§}§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§Permanent attachment = game.getPermanent(sourceAbility.getSourceId());§if (attachment != null) {§Permanent creature = game.getPermanent(attachment.getAttachedTo());§if (creature != null) {§Player player = game.getPlayer(creature.getControllerId());§if (player != null) {§return player.getGraveyard().count(filter, game);§}§}§}§return 0;§}§@Override§public DynamicValue copy() {§return new CardsInEnchantedCreaturesControllerGraveyardCount(this);§}§@Override§public String toString() {§return "X";§}§@Override§public String getMessage() {§return filter.getMessage();§}§}§
public class FathomMage extends CardImpl {§public FathomMage(UUID ownerId) {§super(ownerId, 162, "Fathom Mage", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{G}{U}");§this.expansionSetCode = "GTC";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new EvolveAbility());§this.addAbility(new FathomMageTriggeredAbility());§}§public FathomMage(final FathomMage card) {§super(card);§}§@Override§public FathomMage copy() {§return new FathomMage(this);§}§}§class FathomMageTriggeredAbility extends TriggeredAbilityImpl {§public FathomMageTriggeredAbility() {§super(Zone.ALL, new DrawCardSourceControllerEffect(1), true);§}§public FathomMageTriggeredAbility(FathomMageTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.COUNTER_ADDED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§return event.getTargetId().equals(this.getSourceId()) && event.getData().equals(CounterType.P1P1.getName());§}§@Override§public FathomMageTriggeredAbility copy() {§return new FathomMageTriggeredAbility(this);§}§@Override§public String getRule() {§return "Whenever a +1/+1 counter is placed on {this}, " + super.getRule();§}§}§
public class GroundAssault extends CardImpl {§public GroundAssault(UUID ownerId) {§super(ownerId, 168, "Ground Assault", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{R}{G}");§this.expansionSetCode = "GTC";§this.getSpellAbility().addEffect(new DamageTargetEffect(new PermanentsOnBattlefieldCount(new FilterControlledLandPermanent())));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public GroundAssault(final GroundAssault card) {§super(card);§}§@Override§public GroundAssault copy() {§return new GroundAssault(this);§}§}§
public class IllusionistsBracers extends CardImpl {§public IllusionistsBracers(UUID ownerId) {§super(ownerId, 231, "Illusionist's Bracers", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "GTC";§this.subtype.add("Equipment");§this.addAbility(new AbilityActivatedTriggeredAbility());§this.addAbility(new EquipAbility(Outcome.BoostCreature, new GenericManaCost(3)));§}§public IllusionistsBracers(final IllusionistsBracers card) {§super(card);§}§@Override§public IllusionistsBracers copy() {§return new IllusionistsBracers(this);§}§}§class AbilityActivatedTriggeredAbility extends TriggeredAbilityImpl {§AbilityActivatedTriggeredAbility() {§super(Zone.BATTLEFIELD, new CopyActivatedAbilityEffect());§}§AbilityActivatedTriggeredAbility(final AbilityActivatedTriggeredAbility ability) {§super(ability);§}§@Override§public AbilityActivatedTriggeredAbility copy() {§return new AbilityActivatedTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ACTIVATED_ABILITY;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent equipment = game.getPermanent(this.getSourceId());§if (equipment != null && equipment.getAttachedTo() != null && equipment.getAttachedTo().equals(event.getSourceId())) {§StackAbility stackAbility = (StackAbility) game.getStack().getStackObject(event.getSourceId());§if (!(stackAbility.getStackAbility() instanceof ManaAbility)) {§Effect effect = this.getEffects().get(0);§effect.setValue("stackAbility", stackAbility.getStackAbility());§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever an ability of equipped creature is activated, if it isn't a mana ability, copy that ability. You may choose new targets for the copy.";§}§}§class CopyActivatedAbilityEffect extends OneShotEffect {§public CopyActivatedAbilityEffect() {§super(Outcome.Benefit);§this.staticText = "copy that ability. You may choose new targets for the copy";§}§public CopyActivatedAbilityEffect(final CopyActivatedAbilityEffect effect) {§super(effect);§}§@Override§public CopyActivatedAbilityEffect copy() {§return new CopyActivatedAbilityEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Ability ability = (Ability) getValue("stackAbility");§Player controller = game.getPlayer(source.getControllerId());§Permanent sourcePermanent = game.getPermanent(source.getSourceId());§if (ability != null && controller != null && sourcePermanent != null) {§Ability newAbility = ability.copy();§newAbility.newId();§game.getStack().push(new StackAbility(newAbility, source.getControllerId()));§if (newAbility.getTargets().size() > 0) {§if (controller.chooseUse(newAbility.getEffects().get(0).getOutcome(), "Choose new targets?", source, game)) {§newAbility.getTargets().clearChosen();§if (newAbility.getTargets().chooseTargets(newAbility.getEffects().get(0).getOutcome(), source.getControllerId(), newAbility, false, game) == false) {§return false;§}§}§}§game.informPlayers(new StringBuilder(sourcePermanent.getName()).append(": ").append(controller.getLogName()).append(" copied activated ability").toString());§return true;§}§return false;§}§}§
public class MentalVapors extends CardImpl {§public MentalVapors (UUID ownerId) {§super(ownerId, 72, "Mental Vapors", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{3}{B}");§this.expansionSetCode = "GTC";§this.getSpellAbility().addEffect(new DiscardTargetEffect(1));§this.getSpellAbility().addTarget(new TargetPlayer());§this.getSpellAbility().addEffect(new CipherEffect());§}§public MentalVapors(final MentalVapors card) {§super(card);§}§@Override§public MentalVapors copy() {§return new MentalVapors(this);§}§}§
public class OozeFlux extends CardImpl {§public OozeFlux(UUID ownerId) {§super(ownerId, 128, "Ooze Flux", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{3}{G}");§this.expansionSetCode = "GTC";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new OozeFluxCreateTokenEffect(new OozeToken()),new ManaCostsImpl("{1}{G}"));§ability.addCost(new RemoveVariableCountersTargetCost(new FilterControlledCreaturePermanent("creatures you control"), CounterType.P1P1, "one or more", 1));§this.addAbility(ability);§}§public OozeFlux(final OozeFlux card) {§super(card);§}§@Override§public OozeFlux copy() {§return new OozeFlux(this);§}§}§class OozeFluxCreateTokenEffect extends OneShotEffect {§private final Token token;§public OozeFluxCreateTokenEffect(Token token) {§super(Outcome.PutCreatureInPlay);§this.token = token;§staticText = "Put an X/X green Ooze creature token onto the battlefield, where X is the number of +1/+1 counters removed this way";§}§public OozeFluxCreateTokenEffect(final OozeFluxCreateTokenEffect effect) {§super(effect);§this.token = effect.token.copy();§}§@Override§public OozeFluxCreateTokenEffect copy() {§return new OozeFluxCreateTokenEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§int xValue = 0;§for (Cost cost : source.getCosts()) {§if (cost instanceof RemoveVariableCountersTargetCost) {§xValue = ((RemoveVariableCountersTargetCost) cost).getAmount();§break;§}§}§Token tokenCopy = token.copy();§tokenCopy.getAbilities().newId();§tokenCopy.getPower().initValue(xValue);§tokenCopy.getToughness().initValue(xValue);§tokenCopy.putOntoBattlefield(1, game, source.getSourceId(), source.getControllerId());§return true;§}§}§
public class RuinationWurm extends CardImpl {§public RuinationWurm(UUID ownerId) {§super(ownerId, 192, "Ruination Wurm", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{R}{G}");§this.expansionSetCode = "GTC";§this.subtype.add("Wurm");§this.power = new MageInt(7);§this.toughness = new MageInt(6);§}§public RuinationWurm(final RuinationWurm card) {§super(card);§}§@Override§public RuinationWurm copy() {§return new RuinationWurm(this);§}§}§
public class SkarrgGoliath extends CardImpl {§public SkarrgGoliath(UUID ownerId) {§super(ownerId, 133, "Skarrg Goliath", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{6}{G}{G}");§this.expansionSetCode = "GTC";§this.subtype.add("Beast");§this.power = new MageInt(9);§this.toughness = new MageInt(9);§this.addAbility(TrampleAbility.getInstance());§Ability ability = new BloodrushAbility("{5}{G}{G}", new BoostTargetEffect(9,9, Duration.EndOfTurn));§ability.addEffect(new GainAbilityTargetEffect(TrampleAbility.getInstance(), Duration.EndOfTurn));§this.addAbility(ability);§}§public SkarrgGoliath(final SkarrgGoliath card) {§super(card);§}§@Override§public SkarrgGoliath copy() {§return new SkarrgGoliath(this);§}§}§
public class ThrullParasite extends CardImpl {§public ThrullParasite(UUID ownerId) {§super(ownerId, 81, "Thrull Parasite", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{B}");§this.expansionSetCode = "GTC";§this.subtype.add("Thrull");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new ExtortAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new RemoveCounterTargetEffect(), new TapSourceCost());§ability.addTarget(new TargetNonlandPermanent());§ability.addCost(new PayLifeCost(2));§this.addAbility(ability);§}§public ThrullParasite(final ThrullParasite card) {§super(card);§}§@Override§public ThrullParasite copy() {§return new ThrullParasite(this);§}§}§
public class WhisperingMadness extends CardImpl {§public WhisperingMadness(UUID ownerId) {§super(ownerId, 207, "Whispering Madness", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{2}{U}{B}");§this.expansionSetCode = "GTC";§this.getSpellAbility().addEffect(new WhisperingMadnessEffect());§this.getSpellAbility().addEffect(new CipherEffect());§}§public WhisperingMadness(final WhisperingMadness card) {§super(card);§}§@Override§public WhisperingMadness copy() {§return new WhisperingMadness(this);§}§}§class WhisperingMadnessEffect extends OneShotEffect {§WhisperingMadnessEffect() {§super(Outcome.Discard);§staticText = "Each player discards his or her hand, then draws cards equal to the greatest number of cards a player discarded this way";§}§WhisperingMadnessEffect(final WhisperingMadnessEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§int maxDiscarded = 0;§Player sourcePlayer = game.getPlayer(source.getControllerId());§if (sourcePlayer == null) {§return false;§}§for (UUID playerId : game.getState().getPlayersInRange(sourcePlayer.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§int discarded = 0;§for (Card c : player.getHand().getCards(game)) {§if (player.discard(c, source, game)) {§discarded++;§}§}§if (discarded > maxDiscarded) {§maxDiscarded = discarded;§}§}§}§for (UUID playerId : game.getState().getPlayersInRange(sourcePlayer.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§player.drawCards(maxDiscarded, game);§}§}§return true;§}§@Override§public WhisperingMadnessEffect copy() {§return new WhisperingMadnessEffect(this);§}§}§
public class CryOfContrition extends CardImpl {§public CryOfContrition(UUID ownerId) {§super(ownerId, 46, "Cry of Contrition", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{B}");§this.expansionSetCode = "GPT";§this.getSpellAbility().addEffect(new DiscardTargetEffect(1));§this.getSpellAbility().addTarget(new TargetPlayer());§HauntAbility ability = new HauntAbility(this, new DiscardTargetEffect(1));§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public CryOfContrition(final CryOfContrition card) {§super(card);§}§@Override§public CryOfContrition copy() {§return new CryOfContrition(this);§}§}§
public class GoblinFlectomancer extends CardImpl {§public GoblinFlectomancer(UUID ownerId) {§super(ownerId, 116, "Goblin Flectomancer", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{U}{R}{R}");§this.expansionSetCode = "GPT";§this.subtype.add("Goblin");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ChooseNewTargetsTargetEffect(), new SacrificeSourceCost());§ability.addTarget(new TargetSpell(new FilterInstantOrSorcerySpell()));§this.addAbility(ability);§}§public GoblinFlectomancer(final GoblinFlectomancer card) {§super(card);§}§@Override§public GoblinFlectomancer copy() {§return new GoblinFlectomancer(this);§}§}§
public class LeylineOfLightning extends CardImpl {§public LeylineOfLightning(UUID ownerId) {§super(ownerId, 68, "Leyline of Lightning", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{2}{R}{R}");§this.expansionSetCode = "GPT";§this.addAbility(LeylineAbility.getInstance());§Ability ability = new SpellCastControllerTriggeredAbility(new LeylineOfLightningEffect(), true);§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public LeylineOfLightning(final LeylineOfLightning card) {§super(card);§}§@Override§public LeylineOfLightning copy() {§return new LeylineOfLightning(this);§}§}§class LeylineOfLightningEffect extends DamageTargetEffect {§LeylineOfLightningEffect() {§super(1);§this.staticText = "you may pay {1}. If you do, {this} deals 1 damage to target player.";§}§LeylineOfLightningEffect(final LeylineOfLightningEffect effect) {§super(effect);§}§@Override§public LeylineOfLightningEffect copy() {§return new LeylineOfLightningEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§Cost cost = new GenericManaCost(1);§if (cost.pay(source, game, source.getSourceId(), source.getControllerId(), false, null)) {§super.apply(game, source);§}§return true;§}§return false;§}§}§
public class Pyromatics extends CardImpl {§public Pyromatics(UUID ownerId) {§super(ownerId, 72, "Pyromatics", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{R}");§this.expansionSetCode = "GPT";§this.addAbility(new ReplicateAbility(this, "{1}{R}"));§this.getSpellAbility().addEffect(new DamageTargetEffect(1));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§}§public Pyromatics(final Pyromatics card) {§super(card);§}§@Override§public Pyromatics copy() {§return new Pyromatics(this);§}§}§
public class SmogsteedRider extends CardImpl {§public SmogsteedRider(UUID ownerId) {§super(ownerId, 63, "Smogsteed Rider", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{B}{B}");§this.expansionSetCode = "GPT";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new AttacksTriggeredAbility(new GainAbilityControlledEffect(FearAbility.getInstance(), Duration.EndOfTurn, new FilterAttackingCreature(), true), false));§}§public SmogsteedRider(final SmogsteedRider card) {§super(card);§}§@Override§public SmogsteedRider copy() {§return new SmogsteedRider(this);§}§}§
public class WeeDragonauts extends CardImpl {§private static final FilterSpell filter = new FilterSpell("instant or sorcery spell");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.INSTANT),§new CardTypePredicate(CardType.SORCERY)));§}§public WeeDragonauts(UUID ownerId) {§super(ownerId, 137, "Wee Dragonauts", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{U}{R}");§this.expansionSetCode = "GPT";§this.subtype.add("Faerie");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SpellCastControllerTriggeredAbility(new BoostSourceEffect(2, 0, Duration.EndOfTurn), filter, false));§}§public WeeDragonauts(final WeeDragonauts card) {§super(card);§}§@Override§public WeeDragonauts copy() {§return new WeeDragonauts(this);§}§}§
public class Ambush extends CardImpl {§private static final FilterBlockingCreature filter = new FilterBlockingCreature("Blocking creatures");§public Ambush(UUID ownerId) {§super(ownerId, 78, "Ambush", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{3}{R}");§this.expansionSetCode = "HML";§this.getSpellAbility().addEffect(new GainAbilityAllEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn, filter, false));§}§public Ambush(final Ambush card) {§super(card);§}§@Override§public Ambush copy() {§return new Ambush(this);§}§}§
public class Evaporate extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("white and/or blue creature");§static {§filter.add(Predicates.or(new ColorPredicate(ObjectColor.WHITE),§new ColorPredicate(ObjectColor.BLUE)));§}§public Evaporate(UUID ownerId) {§super(ownerId, 94, "Evaporate", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{2}{R}");§this.expansionSetCode = "HML";§this.getSpellAbility().addEffect(new DamageAllEffect(1, filter));§}§public Evaporate(final Evaporate card) {§super(card);§}§@Override§public Evaporate copy() {§return new Evaporate(this);§}§}§
public class Roterothopter extends CardImpl {§public Roterothopter(UUID ownerId) {§super(ownerId, 134, "Roterothopter", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{1}");§this.expansionSetCode = "HML";§this.subtype.add("Thopter");§this.power = new MageInt(0);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new LimitedTimesPerTurnActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 0, Duration.EndOfTurn), new ManaCostsImpl("{2}"), 2));§}§public Roterothopter(final Roterothopter card) {§super(card);§}§@Override§public Roterothopter copy() {§return new Roterothopter(this);§}§}§
public class BarbedSextant extends CardImpl {§public BarbedSextant(UUID ownerId) {§super(ownerId, 287, "Barbed Sextant", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "ICE";§ManaAbility ability = new AnyColorManaAbility(new GenericManaCost(1));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§ability.addEffect(new CreateDelayedTriggeredAbilityEffect(§new AtTheBeginOfNextUpkeepDelayedTriggeredAbility(new DrawCardSourceControllerEffect(1), Duration.OneUse), false));§ability.setUndoPossible(false);§this.addAbility(ability);§}§public BarbedSextant(final BarbedSextant card) {§super(card);§}§@Override§public BarbedSextant copy() {§return new BarbedSextant(this);§}§}§
public class EnduringRenewal extends CardImpl {§private static final FilterPermanent filter = new FilterCreaturePermanent("a creature");§public EnduringRenewal(UUID ownerId) {§super(ownerId, 247, "Enduring Renewal", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{2}{W}{W}");§this.expansionSetCode = "ICE";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new PlayWithHandRevealedEffect()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new EnduringRenewalReplacementEffect()));§Effect effect = new ReturnFromGraveyardToHandTargetEffect();§effect.setText("return it to your hand");§this.addAbility(new PutIntoGraveFromBattlefieldAllTriggeredAbility(effect, false, filter, true, true));§}§public EnduringRenewal(final EnduringRenewal card) {§super(card);§}§@Override§public EnduringRenewal copy() {§return new EnduringRenewal(this);§}§}§class EnduringRenewalReplacementEffect extends ReplacementEffectImpl {§public EnduringRenewalReplacementEffect() {§super(Duration.WhileOnBattlefield, Outcome.Benefit);§staticText = "If you would draw a card, reveal the top card of your library instead. If it's a creature card, put it into your graveyard. Otherwise, draw a card";§}§public EnduringRenewalReplacementEffect(final EnduringRenewalReplacementEffect effect) {§super(effect);§}§@Override§public EnduringRenewalReplacementEffect copy() {§return new EnduringRenewalReplacementEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§Player controller = game.getPlayer(source.getControllerId());§if (controller == null) {§return false;§}§Card card = controller.getLibrary().getFromTop(game);§if (card != null) {§Cards cards = new CardsImpl();§cards.add(card);§controller.revealCards("Top card of " + controller.getName() + "'s library", cards, game);§if (card.getCardType().contains(CardType.CREATURE)) {§controller.moveCards(card, Zone.LIBRARY, Zone.GRAVEYARD, source, game);§return true;§}§}§return false;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.DRAW_CARD;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§return event.getPlayerId().equals(source.getControllerId());§}§}§class PlayWithHandRevealedEffect extends ContinuousEffectImpl {§public PlayWithHandRevealedEffect() {§super(Duration.WhileOnBattlefield, Layer.PlayerEffects, SubLayer.NA, Outcome.Detriment);§staticText = "Play with your hand revealed";§}§public PlayWithHandRevealedEffect(final PlayWithHandRevealedEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = game.getObject(source.getSourceId());§if (controller != null && sourceObject != null) {§controller.revealCards(controller.getName(), controller.getHand(), game, false);§return true;§}§return false;§}§@Override§public PlayWithHandRevealedEffect copy() {§return new PlayWithHandRevealedEffect(this);§}§}§class EnduringRenewalEffect extends OneShotEffect {§public EnduringRenewalEffect() {§super(Outcome.ReturnToHand);§staticText = "return it to your hand";§}§public EnduringRenewalEffect(final EnduringRenewalEffect effect) {§super(effect);§}§@Override§public EnduringRenewalEffect copy() {§return new EnduringRenewalEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§UUID creatureId = (UUID) getValue("returningCreature");§Permanent creature = game.getPermanent(creatureId);§if (creature != null) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§creature.moveToZone(Zone.HAND, source.getSourceId(), game, false);§}§return true;§}§return false;§}§}§
public class HoarShade extends CardImpl {§public HoarShade(UUID ownerId) {§super(ownerId, 19, "Hoar Shade", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{B}");§this.expansionSetCode = "ICE";§this.subtype.add("Shade");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 1, Duration.EndOfTurn), new ColoredManaCost(ColoredManaSymbol.B)));§}§public HoarShade(final HoarShade card) {§super(card);§}§@Override§public HoarShade copy() {§return new HoarShade(this);§}§}§
public class LightningBlow extends CardImpl {§public LightningBlow(UUID ownerId) {§super(ownerId, 266, "Lightning Blow", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{1}{W}");§this.expansionSetCode = "ICE";§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new CreateDelayedTriggeredAbilityEffect(§new AtTheBeginOfNextUpkeepDelayedTriggeredAbility(new DrawCardSourceControllerEffect(1), Duration.OneUse), false));§}§public LightningBlow(final LightningBlow card) {§super(card);§}§@Override§public LightningBlow copy() {§return new LightningBlow(this);§}§}§
public class Pyroblast extends CardImpl {§public Pyroblast(UUID ownerId) {§super(ownerId, 213, "Pyroblast", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{R}");§this.expansionSetCode = "ICE";§this.getSpellAbility().addEffect(new PyroblastCounterTargetEffect());§this.getSpellAbility().addTarget(new TargetSpell());§Mode mode = new Mode();§mode.getEffects().add(new DestroyTargetEffect());§mode.getTargets().add(new TargetPermanent());§this.getSpellAbility().addMode(mode);§}§public Pyroblast(final Pyroblast card) {§super(card);§}§@Override§public Pyroblast copy() {§return new Pyroblast(this);§}§}§class PyroblastCounterTargetEffect extends OneShotEffect {§public PyroblastCounterTargetEffect() {§super(Outcome.Detriment);§}§public PyroblastCounterTargetEffect(final PyroblastCounterTargetEffect effect) {§super(effect);§}§@Override§public PyroblastCounterTargetEffect copy() {§return new PyroblastCounterTargetEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Spell targetSpell = game.getStack().getSpell(source.getFirstTarget());§if(targetSpell != null && targetSpell.getColor(game).isBlue()){§game.getStack().counter(source.getFirstTarget(), source.getSourceId(), game);§}§return true;§}§@Override§public String getText(Mode mode) {§return "Counter target spell if it's blue";§}§}§class DestroyTargetEffect extends OneShotEffect {§public DestroyTargetEffect() {§super(Outcome.DestroyPermanent);§}§public DestroyTargetEffect(final DestroyTargetEffect effect) {§super(effect);§}§@Override§public DestroyTargetEffect copy() {§return new DestroyTargetEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(source.getTargets().getFirstTarget());§if (permanent != null && permanent.getColor(game).isBlue()) {§permanent.destroy(source.getSourceId(), game, false);§}§return true;§}§@Override§public String getText(Mode mode) {§return "Destroy target permanent if it's blue";§}§}§
public class SpoilsOfEvil extends CardImpl {§private static final FilterCard filter = new FilterCard("artifact or creature card in target opponents graveyard");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.ARTIFACT),§new CardTypePredicate(CardType.CREATURE)));§}§public SpoilsOfEvil(UUID ownerId) {§super(ownerId, 51, "Spoils of Evil", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{2}{B}");§this.expansionSetCode = "ICE";§this.getSpellAbility().addEffect(new SpoilsOfEvilEffect());§this.getSpellAbility().addTarget(new TargetOpponent());§}§public SpoilsOfEvil(final SpoilsOfEvil card) {§super(card);§}§@Override§public SpoilsOfEvil copy() {§return new SpoilsOfEvil(this);§}§class SpoilsOfEvilEffect extends OneShotEffect {§public SpoilsOfEvilEffect() {§super(Outcome.GainLife);§this.staticText = "For each artifact or creature card in target opponent's graveyard, add {C} to your mana pool and you gain 1 life.";§}§public SpoilsOfEvilEffect(final SpoilsOfEvilEffect effect) {§super(effect);§}§@Override§public SpoilsOfEvilEffect copy() {§return new SpoilsOfEvilEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player targetOpponent = game.getPlayer(targetPointer.getFirst(game, source));§Player controller = game.getPlayer(source.getControllerId());§if(targetOpponent != null && controller != null) {§int cardCount = targetOpponent.getGraveyard().count(filter, game);§controller.gainLife(cardCount, game);§controller.getManaPool().addMana(Mana.ColorlessMana(cardCount), game, source);§return true;§}§return false;§}§}§}§
public class WhiteScarab extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("white creatures");§static {§filter.add(new ColorPredicate(ObjectColor.WHITE));§}§public WhiteScarab(UUID ownerId) {§super(ownerId, 280, "White Scarab", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{W}");§this.expansionSetCode = "ICE";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§Effect effect = new CantBeBlockedByCreaturesAttachedEffect(Duration.WhileOnBattlefield, filter, AttachmentType.AURA);§ability = new SimpleStaticAbility(Zone.BATTLEFIELD, effect);§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD,§new ConditionalContinuousEffect(new BoostEnchantedEffect(2, 2, Duration.WhileOnBattlefield),§new WhiteScarabCondition(), "Enchanted creature gets +2/+2 as long as an opponent controls a white permanent")));§}§public WhiteScarab(final WhiteScarab card) {§super(card);§}§@Override§public WhiteScarab copy() {§return new WhiteScarab(this);§}§}§class WhiteScarabCondition implements Condition {§@Override§public boolean apply(Game game, Ability source) {§boolean conditionApplies = false;§FilterPermanent filter = new FilterPermanent();§filter.add(new ColorPredicate(ObjectColor.WHITE));§Set<UUID> opponents = game.getOpponents(source.getControllerId());§for (UUID opponentId : opponents) {§conditionApplies |= game.getBattlefield().countAll(filter, opponentId, game) > 0;§}§return conditionApplies;§}§}§
public class AvacynianPriest extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("non-Human creature");§static {§filter.add(Predicates.not(new SubtypePredicate("Human")));§}§public AvacynianPriest(UUID ownerId) {§super(ownerId, 4, "Avacynian Priest", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "ISD";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TapTargetEffect(), new GenericManaCost(1));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public AvacynianPriest(final AvacynianPriest card) {§super(card);§}§@Override§public AvacynianPriest copy() {§return new AvacynianPriest(this);§}§}§
public class CaravanVigil extends CardImpl {§public CaravanVigil(UUID ownerId) {§super(ownerId, 173, "Caravan Vigil", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{G}");§this.expansionSetCode = "ISD";§this.getSpellAbility().addEffect(new CaravanVigilEffect());§}§public CaravanVigil(final CaravanVigil card) {§super(card);§}§@Override§public CaravanVigil copy() {§return new CaravanVigil(this);§}§}§class CaravanVigilEffect extends OneShotEffect {§public CaravanVigilEffect() {§super(Outcome.PutLandInPlay);§this.staticText = "Search your library for a basic land card, reveal it, put it into your hand, then shuffle your library.<br>"§+ "<i>Morbid</i> &mdash; You may put that card onto the battlefield instead of putting it into your hand if a creature died this turn";§}§public CaravanVigilEffect(final CaravanVigilEffect effect) {§super(effect);§}§@Override§public CaravanVigilEffect copy() {§return new CaravanVigilEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = source.getSourceObject(game);§if (sourceObject != null && controller != null) {§TargetCardInLibrary target = new TargetCardInLibrary(new FilterBasicLandCard());§if (controller.searchLibrary(target, game)) {§Card card = controller.getLibrary().getCard(target.getFirstTarget(), game);§if (card != null) {§Cards cards = new CardsImpl(card);§if (MorbidCondition.getInstance().apply(game, source)§&& controller.chooseUse(Outcome.PutLandInPlay, "Do you wish to put the card onto the battlefield instead?", source, game)) {§controller.moveCards(card, Zone.BATTLEFIELD, source, game);§} else {§controller.moveCards(card, Zone.HAND, source, game);§}§controller.revealCards(sourceObject.getIdName(), cards, game);§}§}§controller.shuffleLibrary(game);§return true;§}§return false;§}§}§
public class CurseOfThePiercedHeart extends CardImpl {§public CurseOfThePiercedHeart(UUID ownerId) {§super(ownerId, 138, "Curse of the Pierced Heart", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{R}");§this.expansionSetCode = "ISD";§this.subtype.add("Aura");§this.subtype.add("Curse");§TargetPlayer target = new TargetPlayer();§this.getSpellAbility().addTarget(target);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(target.getTargetName());§this.addAbility(ability);§this.addAbility(new CurseOfThePiercedHeartAbility());§}§public CurseOfThePiercedHeart(final CurseOfThePiercedHeart card) {§super(card);§}§@Override§public CurseOfThePiercedHeart copy() {§return new CurseOfThePiercedHeart(this);§}§}§class CurseOfThePiercedHeartAbility extends TriggeredAbilityImpl {§public CurseOfThePiercedHeartAbility() {§super(Zone.BATTLEFIELD, new DamageTargetEffect(1));§}§public CurseOfThePiercedHeartAbility(final CurseOfThePiercedHeartAbility ability) {§super(ability);§}§@Override§public CurseOfThePiercedHeartAbility copy() {§return new CurseOfThePiercedHeartAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DRAW_STEP_PRE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent enchantment = game.getPermanent(this.sourceId);§if (enchantment != null && enchantment.getAttachedTo() != null) {§Player player = game.getPlayer(enchantment.getAttachedTo());§if (player != null && game.getActivePlayerId().equals(player.getId())) {§this.getEffects().get(0).setTargetPointer(new FixedTarget(player.getId()));§return true;§}§}§return false;§}§@Override§public String getRule() {§return "At the beginning of enchanted player's upkeep, Curse of the Pierced Heart deals 1 damage to that player.";§}§}§
public class EssenceOfTheWild extends CardImpl {§public EssenceOfTheWild(UUID ownerId) {§super(ownerId, 178, "Essence of the Wild", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{3}{G}{G}{G}");§this.expansionSetCode = "ISD";§this.subtype.add("Avatar");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new EssenceOfTheWildEffect()));§}§public EssenceOfTheWild(final EssenceOfTheWild card) {§super(card);§}§@Override§public EssenceOfTheWild copy() {§return new EssenceOfTheWild(this);§}§}§class EssenceOfTheWildEffect extends ReplacementEffectImpl {§public EssenceOfTheWildEffect() {§super(Duration.WhileOnBattlefield, Outcome.Copy, false);§staticText = "Creatures you control enter the battlefield as a copy of {this}";§}§public EssenceOfTheWildEffect(EssenceOfTheWildEffect effect) {§super(effect);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == EventType.ENTERS_THE_BATTLEFIELD;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§Permanent perm = ((EntersTheBattlefieldEvent) event).getTarget();§return perm != null && perm.getCardType().contains(CardType.CREATURE) && perm.getControllerId().equals(source.getControllerId());§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§Permanent sourceObject = ((EntersTheBattlefieldEvent) event).getTarget();§if (sourceObject != null) {§game.addEffect(new CopyEffect(Duration.Custom, sourceObject, event.getTargetId()), source);§}§return false;§}§@Override§public EssenceOfTheWildEffect copy() {§return new EssenceOfTheWildEffect(this);§}§}§
public class GeistcatchersRig extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature with flying");§static {§filter.add(new AbilityPredicate(FlyingAbility.class));§}§public GeistcatchersRig(UUID ownerId) {§super(ownerId, 223, "Geistcatcher's Rig", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{6}");§this.expansionSetCode = "ISD";§this.subtype.add("Construct");§this.power = new MageInt(4);§this.toughness = new MageInt(5);§Ability ability = new EntersBattlefieldTriggeredAbility(new DamageTargetEffect(4), true);§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public GeistcatchersRig(final GeistcatchersRig card) {§super(card);§}§@Override§public GeistcatchersRig copy() {§return new GeistcatchersRig(this);§}§}§
public class HarvestPyre extends CardImpl {§public HarvestPyre(UUID ownerId) {§super(ownerId, 146, "Harvest Pyre", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{R}");§this.expansionSetCode = "ISD";§this.getSpellAbility().addCost(new ExileXFromYourGraveCost(new FilterCard("cards from your graveyard")));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new DamageTargetEffect(new GetXValue()));§}§public HarvestPyre(final HarvestPyre card) {§super(card);§}§@Override§public HarvestPyre copy() {§return new HarvestPyre(this);§}§}§
public class KessigWolfRun extends CardImpl {§public KessigWolfRun(UUID ownerId) {§super(ownerId, 243, "Kessig Wolf Run", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "ISD";§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilityTargetEffect(TrampleAbility.getInstance(), Duration.EndOfTurn), new ManaCostsImpl("{X}{R}{G}"));§ability.addCost(new TapSourceCost());§ability.addEffect(new BoostTargetEffect(new ManacostVariableValue(), new StaticValue(0), Duration.EndOfTurn));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public KessigWolfRun(final KessigWolfRun card) {§super(card);§}§@Override§public KessigWolfRun copy() {§return new KessigWolfRun(this);§}§}§
public class MayorOfAvabruck extends CardImpl {§private static final String ruleText = "Other Human creatures you control get +1/+1";§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Human creatures");§static {§filter.add(new SubtypePredicate("Human"));§}§public MayorOfAvabruck(UUID ownerId) {§super(ownerId, 193, "Mayor of Avabruck", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "ISD";§this.subtype.add("Human");§this.subtype.add("Advisor");§this.subtype.add("Werewolf");§this.canTransform = true;§this.secondSideCard = new HowlpackAlpha(ownerId);§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Effect effect = new ConditionalContinuousEffect(new BoostControlledEffect(1, 1, Duration.WhileOnBattlefield, filter, true), new InvertCondition(new TransformedCondition()), ruleText);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§this.addAbility(new TransformAbility());§TriggeredAbility ability = new BeginningOfUpkeepTriggeredAbility(new TransformSourceEffect(true), TargetController.ANY, false);§this.addAbility(new ConditionalTriggeredAbility(ability, NoSpellsWereCastLastTurnCondition.getInstance(), TransformAbility.NO_SPELLS_TRANSFORM_RULE));§}§public MayorOfAvabruck(final MayorOfAvabruck card) {§super(card);§}§@Override§public MayorOfAvabruck copy() {§return new MayorOfAvabruck(this);§}§}§
public class NightfallPredator extends CardImpl {§public NightfallPredator(UUID ownerId) {§super(ownerId, 176, "Nightfall Predator", Rarity.RARE, new CardType[]{CardType.CREATURE}, "");§this.expansionSetCode = "ISD";§this.subtype.add("Werewolf");§this.color.setGreen(true);§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.nightCard = true;§this.canTransform = true;§Ability activatedAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new NightfallPredatorEffect(), new ManaCostsImpl("{R}"));§activatedAbility.addCost(new TapSourceCost());§activatedAbility.addTarget(new TargetCreaturePermanent());§this.addAbility(activatedAbility);§TriggeredAbility ability = new BeginningOfUpkeepTriggeredAbility(new TransformSourceEffect(false), TargetController.ANY, false);§this.addAbility(new ConditionalTriggeredAbility(ability, TwoOrMoreSpellsWereCastLastTurnCondition.getInstance(), TransformAbility.TWO_OR_MORE_SPELLS_TRANSFORM_RULE));§}§public NightfallPredator(final NightfallPredator card) {§super(card);§}§@Override§public NightfallPredator copy() {§return new NightfallPredator(this);§}§}§class NightfallPredatorEffect extends OneShotEffect {§public NightfallPredatorEffect() {§super(Outcome.Damage);§this.staticText = "{this} fights target creature";§}§public NightfallPredatorEffect(final NightfallPredatorEffect effect) {§super(effect);§}§@Override§public NightfallPredatorEffect copy() {§return new NightfallPredatorEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent creature1 = game.getPermanent(source.getSourceId());§Permanent creature2 = game.getPermanent(source.getFirstTarget());§if (creature1 != null && creature2 != null) {§if (creature1.getCardType().contains(CardType.CREATURE) && creature2.getCardType().contains(CardType.CREATURE)) {§return creature1.fight(creature2, source, game);§}§}§return false;§}§}§
public class RiotDevils extends CardImpl {§public RiotDevils(UUID ownerId) {§super(ownerId, 160, "Riot Devils", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "ISD";§this.subtype.add("Devil");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§}§public RiotDevils(final RiotDevils card) {§super(card);§}§@Override§public RiotDevils copy() {§return new RiotDevils(this);§}§}§
public class SkirsdagHighPriest extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("untapped creatures you control");§static {§filter.add(Predicates.not(new TappedPredicate()));§}§public SkirsdagHighPriest(UUID ownerId) {§super(ownerId, 117, "Skirsdag High Priest", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "ISD";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§Ability ability = new ConditionalActivatedAbility(Zone.BATTLEFIELD, new CreateTokenEffect(new DemonToken()),§new TapSourceCost(), MorbidCondition.getInstance());§ability.addCost(new TapTargetCost(new TargetControlledCreaturePermanent(2, 2, filter, false)));§ability.setAbilityWord(AbilityWord.MORBID);§this.addAbility(ability);§}§public SkirsdagHighPriest(final SkirsdagHighPriest card) {§super(card);§}§@Override§public SkirsdagHighPriest copy() {§return new SkirsdagHighPriest(this);§}§}§
public class TerrorOfKruinPass extends CardImpl {§private static final String ruleText = "Werewolves you control have menace. (They can't be blocked except by two or more creatures.)";§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Werewolf you control");§static {§filter.add(new ControllerPredicate(TargetController.YOU));§filter.add(new SubtypePredicate("Werewolf"));§}§public TerrorOfKruinPass(UUID ownerId) {§super(ownerId, 152, "Terror of Kruin Pass", Rarity.RARE, new CardType[]{CardType.CREATURE}, "");§this.expansionSetCode = "ISD";§this.subtype.add("Werewolf");§this.nightCard = true;§this.canTransform = true;§this.color.setRed(true);§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(DoubleStrikeAbility.getInstance());§Effect effect = new ConditionalContinuousEffect(new GainAbilityAllEffect(new MenaceAbility(), Duration.Custom, filter), new TransformedCondition(), ruleText);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§TriggeredAbility ability = new BeginningOfUpkeepTriggeredAbility(new TransformSourceEffect(false), TargetController.ANY, false);§this.addAbility(new ConditionalTriggeredAbility(ability, TwoOrMoreSpellsWereCastLastTurnCondition.getInstance(), TransformAbility.TWO_OR_MORE_SPELLS_TRANSFORM_RULE));§}§public TerrorOfKruinPass(final TerrorOfKruinPass card) {§super(card);§}§@Override§public TerrorOfKruinPass copy() {§return new TerrorOfKruinPass(this);§}§}§
public class UrgentExorcism extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("Spirit or enchantment");§static {§filter.add(Predicates.or(§new SubtypePredicate("Spirit"),§new CardTypePredicate(CardType.ENCHANTMENT)));§}§public UrgentExorcism(UUID ownerId) {§super(ownerId, 40, "Urgent Exorcism", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{W}");§this.expansionSetCode = "ISD";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addTarget(new TargetPermanent(filter));§}§public UrgentExorcism(final UrgentExorcism card) {§super(card);§}§@Override§public UrgentExorcism copy() {§return new UrgentExorcism(this);§}§}§
public class AncientKavu extends CardImpl {§public AncientKavu(UUID ownerId) {§super(ownerId, 136, "Ancient Kavu", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "INV";§this.subtype.add("Kavu");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BecomesColorSourceEffect(new ObjectColor(), Duration.EndOfTurn), new ManaCostsImpl("{2}")));§}§public AncientKavu(final AncientKavu card) {§super(card);§}§@Override§public AncientKavu copy() {§return new AncientKavu(this);§}§}§
public class BogInitiate extends CardImpl {§public BogInitiate(UUID ownerId) {§super(ownerId, 95, "Bog Initiate", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "INV";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SimpleManaAbility(Zone.BATTLEFIELD, Mana.BlackMana(1), new ManaCostsImpl("{1}")));§}§public BogInitiate(final BogInitiate card) {§super(card);§}§@Override§public BogInitiate copy() {§return new BogInitiate(this);§}§}§
public class DismantlingBlow extends CardImpl {§public DismantlingBlow(UUID ownerId) {§super(ownerId, 14, "Dismantling Blow", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{W}");§this.expansionSetCode = "INV";§this.addAbility(new KickerAbility("{2}{U}"));§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addTarget(new TargetPermanent(new FilterArtifactOrEnchantmentPermanent()));§this.getSpellAbility().addEffect(new ConditionalOneShotEffect(§new DrawCardSourceControllerEffect(2),§KickedCondition.getInstance(),§"If {this} was kicked, draw two cards"));§}§public DismantlingBlow(final DismantlingBlow card) {§super(card);§}§@Override§public DismantlingBlow copy() {§return new DismantlingBlow(this);§}§}§
public class GhituFire extends CardImpl {§public GhituFire(UUID ownerId) {§super(ownerId, 144, "Ghitu Fire", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{X}{R}");§this.expansionSetCode = "INV";§Effect effect = new DamageTargetEffect(new ManacostVariableValue());§Ability ability = new PayMoreToCastAsThoughtItHadFlashAbility(this, new ManaCostsImpl("{2}"));§ability.addEffect(effect);§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§}§public GhituFire(final GhituFire card) {§super(card);§}§@Override§public GhituFire copy() {§return new GhituFire(this);§}§}§
public class KeldonNecropolis extends CardImpl {§public KeldonNecropolis(UUID ownerId) {§super(ownerId, 325, "Keldon Necropolis", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "INV";§this.supertype.add("Legendary");§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(2), new ManaCostsImpl(new ManaCostsImpl("{4}{R}")));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent(new FilterControlledCreaturePermanent("a creature"))));§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public KeldonNecropolis(final KeldonNecropolis card) {§super(card);§}§@Override§public KeldonNecropolis copy() {§return new KeldonNecropolis(this);§}§}§
public class OrderedMigration extends CardImpl {§public OrderedMigration(UUID ownerId) {§super(ownerId, 258, "Ordered Migration", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{3}{W}{U}");§this.expansionSetCode = "INV";§this.getSpellAbility().addEffect(new CreateTokenEffect(new BirdToken(), new DomainValue()));§}§public OrderedMigration(final OrderedMigration card) {§super(card);§}§@Override§public OrderedMigration copy() {§return new OrderedMigration(this);§}§}§class BirdToken extends Token {§public BirdToken() {§super("Bird", "1/1 blue Bird creature token with flying");§cardType.add(CardType.CREATURE);§color.setBlue(true);§subtype.add("Bird");§power = new MageInt(1);§toughness = new MageInt(1);§addAbility(FlyingAbility.getInstance());§}§}§
public class RainbowCrow extends CardImpl {§public RainbowCrow(UUID ownerId) {§super(ownerId, 69, "Rainbow Crow", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "INV";§this.subtype.add("Bird");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BecomesColorSourceEffect(Duration.EndOfTurn), new ManaCostsImpl("{1}")));§}§public RainbowCrow(final RainbowCrow card) {§super(card);§}§@Override§public RainbowCrow copy() {§return new RainbowCrow(this);§}§}§
public class ScavengedWeaponry extends CardImpl {§public ScavengedWeaponry(UUID ownerId) {§super(ownerId, 123, "Scavenged Weaponry", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{B}");§this.expansionSetCode = "INV";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new EntersBattlefieldTriggeredAbility(new DrawCardSourceControllerEffect(1), false));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(1, 1, Duration.WhileOnBattlefield)));§}§public ScavengedWeaponry(final ScavengedWeaponry card) {§super(card);§}§@Override§public ScavengedWeaponry copy() {§return new ScavengedWeaponry(this);§}§}§
public class StalkingAssassin extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("tapped creature");§static {§filter.add(new TappedPredicate());§}§public StalkingAssassin(UUID ownerId) {§super(ownerId, 277, "Stalking Assassin", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{U}{B}");§this.expansionSetCode = "INV";§this.subtype.add("Human");§this.subtype.add("Assassin");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TapTargetEffect(), new ManaCostsImpl("{3}{U}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new ManaCostsImpl("{3}{B}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public StalkingAssassin(final StalkingAssassin card) {§super(card);§}§@Override§public StalkingAssassin copy() {§return new StalkingAssassin(this);§}§}§
public class TigereyeCameo extends CardImpl {§public TigereyeCameo(UUID ownerId) {§super(ownerId, 314, "Tigereye Cameo", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "INV";§this.addAbility(new GreenManaAbility());§this.addAbility(new WhiteManaAbility());§}§public TigereyeCameo(final TigereyeCameo card) {§super(card);§}§@Override§public TigereyeCameo copy() {§return new TigereyeCameo(this);§}§}§
public class UrborgVolcano extends CardImpl {§public UrborgVolcano(UUID ownerId) {§super(ownerId, 330, "Urborg Volcano", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "INV";§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new BlackManaAbility());§this.addAbility(new RedManaAbility());§}§public UrborgVolcano(final UrborgVolcano card) {§super(card);§}§@Override§public UrborgVolcano copy() {§return new UrborgVolcano(this);§}§}§
public class YavimayaBarbarian extends CardImpl {§private static final FilterCard filter = new FilterCard("blue");§static {§filter.add(new ColorPredicate(ObjectColor.BLUE));§}§public YavimayaBarbarian(UUID ownerId) {§super(ownerId, 290, "Yavimaya Barbarian", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{R}{G}");§this.expansionSetCode = "INV";§this.subtype.add("Elf");§this.subtype.add("Barbarian");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new ProtectionAbility(filter));§}§public YavimayaBarbarian(final YavimayaBarbarian card) {§super(card);§}§@Override§public YavimayaBarbarian copy() {§return new YavimayaBarbarian(this);§}§}§
public class DreamStalker extends CardImpl {§public DreamStalker(UUID ownerId) {§super(ownerId, 7, "Dream Stalker", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "DDM";§this.subtype.add("Illusion");§this.power = new MageInt(1);§this.toughness = new MageInt(5);§this.addAbility(new EntersBattlefieldTriggeredAbility(new ReturnToHandChosenControlledPermanentEffect(new FilterControlledPermanent()), false));§}§public DreamStalker(final DreamStalker card) {§super(card);§}§@Override§public DreamStalker copy() {§return new DreamStalker(this);§}§}§
public class BlindingFlare extends CardImpl {§public BlindingFlare(UUID ownerId) {§super(ownerId, 91, "Blinding Flare", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{R}");§this.expansionSetCode = "JOU";§this.addAbility(new StriveAbility("{R}"));§Effect effect = new CantBlockTargetEffect(Duration.EndOfTurn);§effect.setText("Any number of target creatures can't block this turn");§this.getSpellAbility().addEffect(new CantBlockTargetEffect(Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent(0, Integer.MAX_VALUE));§}§public BlindingFlare(final BlindingFlare card) {§super(card);§}§@Override§public BlindingFlare copy() {§return new BlindingFlare(this);§}§}§
public class DictateOfHeliod extends CardImpl {§public DictateOfHeliod(UUID ownerId) {§super(ownerId, 8, "Dictate of Heliod", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{3}{W}{W}");§this.expansionSetCode = "JOU";§this.addAbility(FlashAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostControlledEffect(2,2,Duration.WhileOnBattlefield)));§}§public DictateOfHeliod(final DictateOfHeliod card) {§super(card);§}§@Override§public DictateOfHeliod copy() {§return new DictateOfHeliod(this);§}§}§
public class FontOfReturn extends CardImpl {§public FontOfReturn(UUID ownerId) {§super(ownerId, 71, "Font of Return", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{B}");§this.expansionSetCode = "JOU";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ReturnFromGraveyardToHandTargetEffect(), new ManaCostsImpl("{3}{B}"));§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetCardInYourGraveyard(0, 3, new FilterCreatureCard("creature cards from your graveyard")));§this.addAbility(ability);§}§public FontOfReturn(final FontOfReturn card) {§super(card);§}§@Override§public FontOfReturn copy() {§return new FontOfReturn(this);§}§}§
public class InterpretTheSigns extends CardImpl {§public InterpretTheSigns(UUID ownerId) {§super(ownerId, 43, "Interpret the Signs", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{5}{U}");§this.expansionSetCode = "JOU";§this.getSpellAbility().addEffect(new ScryEffect(3));§this.getSpellAbility().addEffect(new InterpretTheSignsEffect());§}§public InterpretTheSigns(final InterpretTheSigns card) {§super(card);§}§@Override§public InterpretTheSigns copy() {§return new InterpretTheSigns(this);§}§}§class InterpretTheSignsEffect extends OneShotEffect {§public InterpretTheSignsEffect() {§super(Outcome.DrawCard);§this.staticText = ", then reveal the top card of your library. Draw cards equal to that card's converted mana cost";§}§public InterpretTheSignsEffect(final InterpretTheSignsEffect effect) {§super(effect);§}§@Override§public InterpretTheSignsEffect copy() {§return new InterpretTheSignsEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Card sourceCard = game.getCard(source.getSourceId());§if (controller != null && sourceCard != null) {§Card card = controller.getLibrary().getFromTop(game);§if (card != null) {§controller.revealCards(sourceCard.getName(), new CardsImpl(card), game);§controller.drawCards(card.getManaCost().convertedManaCost(), game);§}§return true;§}§return false;§}§}§
public class NyxFleeceRam extends CardImpl {§public NyxFleeceRam(UUID ownerId) {§super(ownerId, 18, "Nyx-Fleece Ram", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "JOU";§this.subtype.add("Sheep");§this.power = new MageInt(0);§this.toughness = new MageInt(5);§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new GainLifeEffect(1), TargetController.YOU, false));§}§public NyxFleeceRam(final NyxFleeceRam card) {§super(card);§}§@Override§public NyxFleeceRam copy() {§return new NyxFleeceRam(this);§}§}§
public class RevelOfTheFallenGod extends CardImpl {§public RevelOfTheFallenGod(UUID ownerId) {§super(ownerId, 155, "Revel of the Fallen God", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{R}{R}{G}{G}");§this.expansionSetCode = "JOU";§this.getSpellAbility().addEffect(new CreateTokenEffect(new RevelOfTheFallenGodSatyrToken(), 4));§}§public RevelOfTheFallenGod(final RevelOfTheFallenGod card) {§super(card);§}§@Override§public RevelOfTheFallenGod copy() {§return new RevelOfTheFallenGod(this);§}§}§class RevelOfTheFallenGodSatyrToken extends Token {§public RevelOfTheFallenGodSatyrToken() {§super("Satyr", "2/2 red and green Satyr creature tokens with haste");§this.setOriginalExpansionSetCode("THS");§cardType.add(CardType.CREATURE);§color.setColor(ObjectColor.RED);§color.setColor(ObjectColor.GREEN);§subtype.add("Satyr");§power = new MageInt(2);§toughness = new MageInt(2);§addAbility(HasteAbility.getInstance());§}§}§
public class SolidarityOfHeroes extends CardImpl {§public SolidarityOfHeroes(UUID ownerId) {§super(ownerId, 141, "Solidarity of Heroes", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{G}");§this.expansionSetCode = "JOU";§this.addAbility(new StriveAbility("{1}{G}"));§this.getSpellAbility().addEffect(new SolidarityOfHeroesEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent(0, Integer.MAX_VALUE));§}§public SolidarityOfHeroes(final SolidarityOfHeroes card) {§super(card);§}§@Override§public SolidarityOfHeroes copy() {§return new SolidarityOfHeroes(this);§}§}§class SolidarityOfHeroesEffect extends OneShotEffect {§public SolidarityOfHeroesEffect() {§super(Outcome.Benefit);§this.staticText = "Choose any number of target creatures. Double the number of +1/+1 counters on each of them";§}§public SolidarityOfHeroesEffect(final SolidarityOfHeroesEffect effect) {§super(effect);§}§@Override§public SolidarityOfHeroesEffect copy() {§return new SolidarityOfHeroesEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§for (UUID targetId: getTargetPointer().getTargets(game, source)) {§Permanent permanent = game.getPermanent(targetId);§if (permanent != null) {§int existingCounters = permanent.getCounters().getCount(CounterType.P1P1);§if (existingCounters > 0) {§permanent.addCounters(CounterType.P1P1.createInstance(existingCounters), game);§}§}§}§return true;§}§return false;§}§}§
public class TritonShorestalker extends CardImpl {§public TritonShorestalker(UUID ownerId) {§super(ownerId, 56, "Triton Shorestalker", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{U}");§this.expansionSetCode = "JOU";§this.subtype.add("Merfolk");§this.subtype.add("Rogue");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new CantBeBlockedSourceAbility("{this} can't be blocked"));§}§public TritonShorestalker(final TritonShorestalker card) {§super(card);§}§@Override§public TritonShorestalker copy() {§return new TritonShorestalker(this);§}§}§
public class BurningWish extends CardImpl {§public BurningWish(UUID ownerId) {§super(ownerId, 83, "Burning Wish", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{1}{R}");§this.expansionSetCode = "JUD";§this.getSpellAbility().addEffect(new BurningWishEffect());§}§public BurningWish(final BurningWish card) {§super(card);§}§@Override§public BurningWish copy() {§return new BurningWish(this);§}§}§class BurningWishEffect extends OneShotEffect {§private static final String choiceText = "Choose a sorcery card you own from outside the game, and put it into your hand";§private static final FilterCard filter = new FilterCard("sorcery card");§static{§filter.add(new CardTypePredicate(CardType.SORCERY));§}§public BurningWishEffect() {§super(Outcome.Benefit);§this.staticText = "You may choose a sorcery card you own from outside the game, reveal that card, and put it into your hand. Exile Burning Wish";§}§public BurningWishEffect(final BurningWishEffect effect) {§super(effect);§}§@Override§public BurningWishEffect copy() {§return new BurningWishEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§while (player.chooseUse(Outcome.Benefit, choiceText, source, game)) {§Cards cards = player.getSideboard();§if(cards.isEmpty()) {§game.informPlayer(player, "You have no cards outside the game.");§break;§}§Set<Card> filtered = cards.getCards(filter, game);§if (filtered.isEmpty()) {§game.informPlayer(player, "You have no " + filter.getMessage() + " outside the game.");§break;§}§Cards filteredCards = new CardsImpl();§for (Card card : filtered) {§filteredCards.add(card.getId());§}§TargetCard target = new TargetCard(Zone.OUTSIDE, filter);§if (player.choose(Outcome.Benefit, filteredCards, target, game)) {§Card card = player.getSideboard().get(target.getFirstTarget(), game);§if (card != null) {§card.moveToZone(Zone.HAND, source.getSourceId(), game, false);§Cards revealCard = new CardsImpl();§revealCard.add(card);§player.revealCards("Burning Wish", revealCard, game);§break;§}§}§}§Card cardToExile = game.getCard(source.getSourceId());§if(cardToExile != null)§{§cardToExile.moveToExile(null, "", source.getSourceId(), game);§}§}§return true;§}§}§
public class FledglingDragon extends CardImpl {§public FledglingDragon(UUID ownerId) {§super(ownerId, 90, "Fledgling Dragon", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "JUD";§this.subtype.add("Dragon");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(§new BoostSourceEffect(3, 3, Duration.WhileOnBattlefield), new CardsInControllerGraveCondition(7),§"As long as seven or more cards are in your graveyard, {this} gets +3/+3"));§Ability gainedAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 0, Duration.EndOfTurn), new ManaCostsImpl("{R}"));§ability.addEffect(new ConditionalContinuousEffect(new GainAbilitySourceEffect(gainedAbility),§new CardsInControllerGraveCondition(7), "and has \"{R}: {this} gets +1/+0 until end of turn.\""));§ability.setAbilityWord(AbilityWord.THRESHOLD);§this.addAbility(ability);§}§public FledglingDragon(final FledglingDragon card) {§super(card);§}§@Override§public FledglingDragon copy() {§return new FledglingDragon(this);§}§}§
public class MaskedGorgon extends CardImpl {§private static final FilterCreaturePermanent filter1 = new FilterCreaturePermanent("green creatures and white creatures");§private static final FilterCard filter2 = new FilterCard("Gorgons");§private static final FilterCard filter3 = new FilterCard("green and from white");§static {§filter1.add(Predicates.or(new ColorPredicate(ObjectColor.GREEN), new ColorPredicate(ObjectColor.WHITE)));§filter2.add(new SubtypePredicate("Gorgon"));§filter3.add(Predicates.or(new ColorPredicate(ObjectColor.GREEN), new ColorPredicate(ObjectColor.WHITE)));§}§public MaskedGorgon(UUID ownerId) {§super(ownerId, 69, "Masked Gorgon", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{B}");§this.expansionSetCode = "JUD";§this.subtype.add("Gorgon");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAllEffect(§new ProtectionAbility(filter2), Duration.WhileOnBattlefield, filter1)));§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(§new GainAbilitySourceEffect(new ProtectionAbility(filter3), Duration.WhileOnBattlefield), new CardsInControllerGraveCondition(7),§"{this} has protection from green and from white as long as seven or more cards are in your graveyard"));§ability.setAbilityWord(AbilityWord.THRESHOLD);§this.addAbility(ability);§}§public MaskedGorgon(final MaskedGorgon card) {§super(card);§}§@Override§public MaskedGorgon copy() {§return new MaskedGorgon(this);§}§}§
public class SwirlingSandstorm extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature without flying");§static {§filter.add(Predicates.not(new AbilityPredicate(FlyingAbility.class)));§}§public SwirlingSandstorm(UUID ownerId) {§super(ownerId, 102, "Swirling Sandstorm", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{3}{R}");§this.expansionSetCode = "JUD";§Effect effect = new ConditionalOneShotEffect(§new DamageAllEffect(5, filter),§new CardsInControllerGraveCondition(7),§"<i>Threshold</i> - {this} deals 5 damage to each creature without flying if seven or more cards are in your graveyard.");§this.getSpellAbility().addEffect(effect);§}§public SwirlingSandstorm(final SwirlingSandstorm card) {§super(card);§}§@Override§public SwirlingSandstorm copy() {§return new SwirlingSandstorm(this);§}§}§
public class AinokTracker extends CardImpl {§public AinokTracker(UUID ownerId) {§super(ownerId, 96, "Ainok Tracker", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{5}{R}");§this.expansionSetCode = "KTK";§this.subtype.add("Hound");§this.subtype.add("Scout");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FirstStrikeAbility.getInstance());§this.addAbility(new MorphAbility(this, new ManaCostsImpl("{4}{R}")));§}§public AinokTracker(final AinokTracker card) {§super(card);§}§@Override§public AinokTracker copy() {§return new AinokTracker(this);§}§}§
public class BloodfireMentor extends CardImpl {§public BloodfireMentor(UUID ownerId) {§super(ownerId, 102, "Bloodfire Mentor", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "KTK";§this.subtype.add("Efreet");§this.subtype.add("Shaman");§this.power = new MageInt(0);§this.toughness = new MageInt(5);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawDiscardControllerEffect(1,1), new ManaCostsImpl("{2}{U}"));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public BloodfireMentor(final BloodfireMentor card) {§super(card);§}§@Override§public BloodfireMentor copy() {§return new BloodfireMentor(this);§}§}§
public class DeflectingPalm extends CardImpl {§public DeflectingPalm(UUID ownerId) {§super(ownerId, 173, "Deflecting Palm", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{R}{W}");§this.expansionSetCode = "KTK";§this.getSpellAbility().addEffect(new DeflectingPalmEffect());§}§public DeflectingPalm(final DeflectingPalm card) {§super(card);§}§@Override§public DeflectingPalm copy() {§return new DeflectingPalm(this);§}§}§class DeflectingPalmEffect extends PreventionEffectImpl {§private final TargetSource target;§public DeflectingPalmEffect() {§super(Duration.EndOfTurn, Integer.MAX_VALUE, false, false);§this.staticText = "The next time a source of your choice would deal damage to you this turn, prevent that damage. If damage is prevented this way, {this} deals that much damage to that source's controller";§this.target = new TargetSource();§}§public DeflectingPalmEffect(final DeflectingPalmEffect effect) {§super(effect);§this.target = effect.target.copy();§}§@Override§public DeflectingPalmEffect copy() {§return new DeflectingPalmEffect(this);§}§@Override§public void init(Ability source, Game game) {§this.target.choose(Outcome.PreventDamage, source.getControllerId(), source.getSourceId(), game);§super.init(source, game);§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§PreventionEffectData preventionData = preventDamageAction(event, source, game);§this.used = true;§this.discard(); §
public class ForceAway extends CardImpl {§public ForceAway(UUID ownerId) {§super(ownerId, 40, "Force Away", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "KTK";§this.getSpellAbility().addEffect(new ReturnToHandTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§Effect effect = new ConditionalOneShotEffect(new DrawDiscardControllerEffect(1,1, true),§FerociousCondition.getInstance() , "<br><i>Ferocious</i> &mdash; If you control a creature with power 4 or greater, you may draw a card. If you do, discard a card");§this.getSpellAbility().addEffect(effect);§}§public ForceAway(final ForceAway card) {§super(card);§}§@Override§public ForceAway copy() {§return new ForceAway(this);§}§}§
public class IcyBlast extends CardImpl {§public IcyBlast(UUID ownerId) {§super(ownerId, 42, "Icy Blast", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{X}{U}");§this.expansionSetCode = "KTK";§this.getSpellAbility().addEffect(new TapTargetEffect("X target creatures"));§this.getSpellAbility().addTarget(new TargetCreaturePermanent(0, 1, new FilterCreaturePermanent(), false));§Effect effect = new ConditionalContinuousRuleModifyingEffect(§new DontUntapInControllersNextUntapStepTargetEffect(),§new LockedInCondition(FerociousCondition.getInstance()));§effect.setText("<br/><i>Ferocious</i> &mdash; If you control a creature with power 4 or greater, those creatures don't untap during their controllers' next untap steps");§this.getSpellAbility().addEffect(effect);§}§public IcyBlast(final IcyBlast card) {§super(card);§}§@Override§public void adjustTargets(Ability ability, Game game) {§if (ability instanceof SpellAbility) {§ability.getTargets().clear();§int numberToTap = ability.getManaCostsToPay().getX();§numberToTap = Math.min(game.getBattlefield().count(new FilterCreaturePermanent(), ability.getSourceId(), ability.getControllerId(), game), numberToTap);§ability.addTarget(new TargetCreaturePermanent(numberToTap));§}§}§@Override§public IcyBlast copy() {§return new IcyBlast(this);§}§}§
public class LongshotSquad extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent();§static {§filter.add(new CardTypePredicate(CardType.CREATURE));§filter.add(new ControllerPredicate(TargetController.YOU));§filter.add(new CounterPredicate(CounterType.P1P1));§}§public LongshotSquad(UUID ownerId) {§super(ownerId, 140, "Longshot Squad", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "KTK";§this.subtype.add("Hound");§this.subtype.add("Archer");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new OutlastAbility(new ManaCostsImpl("{1}{G}")));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAllEffect(ReachAbility.getInstance(), Duration.WhileOnBattlefield, filter,§"Each creature you control with a +1/+1 counter on it has reach")));§}§public LongshotSquad(final LongshotSquad card) {§super(card);§}§@Override§public LongshotSquad copy() {§return new LongshotSquad(this);§}§}§
public class MonasterySwiftspear extends CardImpl {§public MonasterySwiftspear(UUID ownerId) {§super(ownerId, 118, "Monastery Swiftspear", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "KTK";§this.subtype.add("Human");§this.subtype.add("Monk");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(HasteAbility.getInstance());§this.addAbility(new ProwessAbility());§}§public MonasterySwiftspear(final MonasterySwiftspear card) {§super(card);§}§@Override§public MonasterySwiftspear copy() {§return new MonasterySwiftspear(this);§}§}§
public class RiverwheelAerialists extends CardImpl {§public RiverwheelAerialists(UUID ownerId) {§super(ownerId, 51, "Riverwheel Aerialists", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{5}{U}");§this.expansionSetCode = "KTK";§this.subtype.add("Djinn");§this.subtype.add("Monk");§this.power = new MageInt(4);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new ProwessAbility());§}§public RiverwheelAerialists(final RiverwheelAerialists card) {§super(card);§}§@Override§public RiverwheelAerialists copy() {§return new RiverwheelAerialists(this);§}§}§
public class SeekerOfTheWay extends CardImpl {§private static final FilterSpell filter = new FilterSpell("a noncreature spell");§static {§filter.add(Predicates.not(new CardTypePredicate(CardType.CREATURE)));§}§public SeekerOfTheWay(UUID ownerId) {§super(ownerId, 22, "Seeker of the Way", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "KTK";§this.subtype.add("Human");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new ProwessAbility());§this.addAbility(new SpellCastControllerTriggeredAbility(new GainAbilitySourceEffect(LifelinkAbility.getInstance(), Duration.EndOfTurn), filter, false));§}§public SeekerOfTheWay(final SeekerOfTheWay card) {§super(card);§}§@Override§public SeekerOfTheWay copy() {§return new SeekerOfTheWay(this);§}§}§
public class SurrakDragonclaw extends CardImpl {§private static final FilterSpell filterTarget = new FilterSpell("Creature spells you control");§static {§filterTarget.add(new CardTypePredicate(CardType.CREATURE));§}§public SurrakDragonclaw(UUID ownerId) {§super(ownerId, 206, "Surrak Dragonclaw", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{2}{G}{U}{R}");§this.expansionSetCode = "KTK";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Warrior");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(FlashAbility.getInstance());§this.addAbility(new CantBeCounteredAbility());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CantBeCounteredControlledEffect(filterTarget, null, Duration.WhileOnBattlefield)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD,§new GainAbilityControlledEffect(TrampleAbility.getInstance(), Duration.WhileOnBattlefield, new FilterCreaturePermanent(), true)));§}§public SurrakDragonclaw(final SurrakDragonclaw card) {§super(card);§}§@Override§public SurrakDragonclaw copy() {§return new SurrakDragonclaw(this);§}§}§
public class TreasureCruise extends CardImpl {§public TreasureCruise(UUID ownerId) {§super(ownerId, 59, "Treasure Cruise", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{7}{U}");§this.expansionSetCode = "KTK";§this.addAbility(new DelveAbility());§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(3));§}§public TreasureCruise(final TreasureCruise card) {§super(card);§}§@Override§public TreasureCruise copy() {§return new TreasureCruise(this);§}§}§
public class WitnessOfTheAges extends CardImpl {§public WitnessOfTheAges(UUID ownerId) {§super(ownerId, 228, "Witness of the Ages", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{6}");§this.expansionSetCode = "KTK";§this.subtype.add("Golem");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new MorphAbility(this, new ManaCostsImpl("{5}")));§}§public WitnessOfTheAges(final WitnessOfTheAges card) {§super(card);§}§@Override§public WitnessOfTheAges copy() {§return new WitnessOfTheAges(this);§}§}§
public class AngusMackenzie extends CardImpl {§public AngusMackenzie(UUID ownerId) {§super(ownerId, 257, "Angus Mackenzie", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{G}{W}{U}");§this.expansionSetCode = "LEG";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Effect effect = new PreventAllDamageByAllEffect(Duration.EndOfTurn, true);§effect.setText("Prevent all combat damage that would be dealt this turn");§Ability ability = new ActivateIfConditionActivatedAbility(§Zone.BATTLEFIELD,§effect,§new ManaCostsImpl("{G}{W}{U}"),§BeforeCombatDamageCondition.getInstance()§);§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public AngusMackenzie(final AngusMackenzie card) {§super(card);§}§@Override§public AngusMackenzie copy() {§return new AngusMackenzie(this);§}§}§class BeforeCombatDamageCondition implements Condition {§private static final BeforeCombatDamageCondition fInstance = new BeforeCombatDamageCondition();§public static Condition getInstance() {§return fInstance;§}§@Override§public boolean apply(Game game, Ability source) {§PhaseStep phaseStep = game.getStep().getType();§if(phaseStep.getIndex() < PhaseStep.FIRST_COMBAT_DAMAGE.getIndex()) {§return true;§}§return false;§}§@Override§public String toString() {§return "before the combat damage step";§}§}§
public class FrostGiant extends CardImpl {§public FrostGiant(UUID ownerId) {§super(ownerId, 146, "Frost Giant", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{R}{R}{R}");§this.expansionSetCode = "LEG";§this.subtype.add("Giant");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new RampageAbility(2));§}§public FrostGiant(final FrostGiant card) {§super(card);§}§@Override§public FrostGiant copy() {§return new FrostGiant(this);§}§}§
public class LadyEvangela extends CardImpl {§public LadyEvangela(UUID ownerId) {§super(ownerId, 280, "Lady Evangela", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{W}{U}{B}");§this.expansionSetCode = "LEG";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§Effect effect = new PreventDamageByTargetEffect(Duration.EndOfTurn, true);§effect.setText("Prevent all combat damage that would be dealt by target creature this turn.");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl("{W}{B}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public LadyEvangela(final LadyEvangela card) {§super(card);§}§@Override§public LadyEvangela copy() {§return new LadyEvangela(this);§}§}§
public class Reset extends CardImpl {§public Reset(UUID ownerId) {§super(ownerId, 73, "Reset", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{U}{U}");§this.expansionSetCode = "LEG";§this.addAbility(new CastOnlyDuringPhaseStepSourceAbility(null, null,§new CompoundCondition(OnOpponentsTurnCondition.getInstance(), AfterUpkeepStepCondtion.getInstance()),§"Cast {this} only during an opponent's turn after his or her upkeep step"));§this.getSpellAbility().addEffect(new UntapAllLandsControllerEffect());§}§public Reset(final Reset card) {§super(card);§}§@Override§public Reset copy() {§return new Reset(this);§}§}§
public class TriassicEgg extends CardImpl {§public TriassicEgg(UUID ownerId) {§super(ownerId, 242, "Triassic Egg", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "LEG";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new AddCountersSourceEffect(CounterType.HATCHLING.createInstance(), true),§new GenericManaCost(3));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§ability = new ConditionalActivatedAbility(Zone.BATTLEFIELD,§new PutPermanentOnBattlefieldEffect(new FilterCreatureCard("a creature card")),§new SacrificeSourceCost(),§new SourceHasCounterCondition(CounterType.HATCHLING, 2, Integer.MAX_VALUE),§"Sacrifice Triassic Egg: Choose one - You may put a creature card from your hand onto the battlefield; or return target creature card from your graveyard to the battlefield. Activate this ability only if two or more hatchling counters are on {this}.");§Mode mode = new Mode();§mode.getEffects().add(new ReturnFromGraveyardToBattlefieldTargetEffect());§Target target = new TargetCardInYourGraveyard(new FilterCreatureCard("creature card from your graveyard"));§mode.getTargets().add(target);§ability.addMode(mode);§this.addAbility(ability);§}§public TriassicEgg(final TriassicEgg card) {§super(card);§}§@Override§public TriassicEgg copy() {§return new TriassicEgg(this);§}§}§
public class CloudreachCavalry extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("Bird");§static {§filter.add(new SubtypePredicate("Bird"));§}§public CloudreachCavalry(UUID ownerId) {§super(ownerId, 7, "Cloudreach Cavalry", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "LGN";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(§new BoostSourceEffect(2, 2, Duration.WhileOnBattlefield),§new PermanentsOnTheBattlefieldCondition(filter),§"As long as you control a Bird, {this} gets +2/+2"));§ability.addEffect(new ConditionalContinuousEffect(§new GainAbilitySourceEffect(FlyingAbility.getInstance()),§new PermanentsOnTheBattlefieldCondition(filter),§"and has flying"));§this.addAbility(ability);§}§public CloudreachCavalry(final CloudreachCavalry card) {§super(card);§}§@Override§public CloudreachCavalry copy() {§return new CloudreachCavalry(this);§}§}§
public class GoblinAssassin extends CardImpl {§public GoblinAssassin(UUID ownerId) {§super(ownerId, 95, "Goblin Assassin", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{R}{R}");§this.expansionSetCode = "LGN";§this.subtype.add("Goblin");§this.subtype.add("Assassin");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new GoblinAssassinTriggeredAbiliy());§}§public GoblinAssassin(final GoblinAssassin card) {§super(card);§}§@Override§public GoblinAssassin copy() {§return new GoblinAssassin(this);§}§}§class GoblinAssassinTriggeredAbiliy extends TriggeredAbilityImpl {§GoblinAssassinTriggeredAbiliy() {§super(Zone.BATTLEFIELD, new GoblinAssassinTriggeredEffect(), false);§}§GoblinAssassinTriggeredAbiliy(final GoblinAssassinTriggeredAbiliy ability) {§super(ability);§}§@Override§public GoblinAssassinTriggeredAbiliy copy() {§return new GoblinAssassinTriggeredAbiliy(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ENTERS_THE_BATTLEFIELD;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§UUID targetId = event.getTargetId();§Permanent permanent = game.getPermanent(targetId);§if ((targetId.equals(this.getSourceId())) || (permanent.hasSubtype("Goblin") && !targetId.equals(this.getSourceId()))) {§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever {this} or another Goblin enters battlefield, each player flips a coin. Each player whose coin comes up tails sacrifices a creature.";§}§}§class GoblinAssassinTriggeredEffect extends OneShotEffect {§GoblinAssassinTriggeredEffect() {§super(Outcome.Sacrifice);§}§GoblinAssassinTriggeredEffect(final GoblinAssassinTriggeredEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§List<UUID> perms = new ArrayList<>();§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null && !player.flipCoin(game)) {§TargetControlledCreaturePermanent target = new TargetControlledCreaturePermanent();§target.setNotTarget(true);§if (target.canChoose(player.getId(), game)) {§player.chooseTarget(Outcome.Sacrifice, target, source, game);§perms.addAll(target.getTargets());§}§}§}§for (UUID permID : perms) {§Permanent permanent = game.getPermanent(permID);§if (permanent != null) {§permanent.sacrifice(source.getSourceId(), game);§}§}§return true;§}§return false;§}§@Override§public GoblinAssassinTriggeredEffect copy() {§return new GoblinAssassinTriggeredEffect(this);§}§}§
public class NeedleshotGourna extends CardImpl {§public NeedleshotGourna(UUID ownerId) {§super(ownerId, 133, "Needleshot Gourna", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{G}{G}");§this.expansionSetCode = "LGN";§this.subtype.add("Beast");§this.power = new MageInt(3);§this.toughness = new MageInt(6);§this.addAbility(ReachAbility.getInstance());§}§public NeedleshotGourna(final NeedleshotGourna card) {§super(card);§}§@Override§public NeedleshotGourna copy() {§return new NeedleshotGourna(this);§}§}§
public class SynapseSliver extends CardImpl {§public SynapseSliver(UUID ownerId) {§super(ownerId, 53, "Synapse Sliver", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{U}");§this.expansionSetCode = "LGN";§this.subtype.add("Sliver");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§Effect effect = new DrawCardTargetEffect(1);§effect.setText("its controller may draw a card");§this.addAbility(new DealsDamageToAPlayerAllTriggeredAbility(effect,§new FilterCreaturePermanent("Sliver", "a Sliver"),§true, SetTargetPointer.PLAYER, true));§}§public SynapseSliver(final SynapseSliver card) {§super(card);§}§@Override§public SynapseSliver copy() {§return new SynapseSliver(this);§}§}§
public class BlackLotus extends CardImpl {§public BlackLotus(UUID ownerId) {§super(ownerId, 232, "Black Lotus", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{0}");§this.expansionSetCode = "LEA";§Ability ability = new SimpleManaAbility(Zone.BATTLEFIELD, new AddManaOfAnyColorEffect(3), new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public BlackLotus(final BlackLotus card) {§super(card);§}§@Override§public BlackLotus copy() {§return new BlackLotus(this);§}§}§
public class Fastbond extends CardImpl {§public Fastbond(UUID ownerId) {§super(ownerId, 101, "Fastbond", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{G}");§this.expansionSetCode = "LEA";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new PlayAdditionalLandsControllerEffect(Integer.MAX_VALUE, Duration.WhileOnBattlefield)));§this.addAbility(new PlayALandTriggeredAbility());§}§public Fastbond(final Fastbond card) {§super(card);§}§@Override§public Fastbond copy() {§return new Fastbond(this);§}§}§class PlayALandTriggeredAbility extends TriggeredAbilityImpl {§public PlayALandTriggeredAbility() {§super(Zone.BATTLEFIELD, new DamageControllerEffect(1), false);§}§public PlayALandTriggeredAbility(PlayALandTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.LAND_PLAYED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§return event.getPlayerId().equals(this.getControllerId());§}§@Override§public boolean checkInterveningIfClause(Game game) {§Player player = game.getPlayer(this.getControllerId());§if (player != null) {§if (player.getLandsPlayed() != 1) {§return true;§}§}§return false;§}§@Override§public PlayALandTriggeredAbility copy() {§return new PlayALandTriggeredAbility(this);§}§@Override§public String getRule() {§return "Whenever you play a land, if it wasn't the first land you played this turn, {source} deals 1 damage to you";§}§}§
public class ManaShort extends CardImpl {§public ManaShort(UUID ownerId) {§super(ownerId, 66, "Mana Short", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{2}{U}");§this.expansionSetCode = "LEA";§this.getSpellAbility().addEffect(new ManaShortEffect());§this.getSpellAbility().addTarget(new TargetPlayer());§}§public ManaShort(final ManaShort card) {§super(card);§}§@Override§public ManaShort copy() {§return new ManaShort(this);§}§}§class ManaShortEffect extends TapAllTargetPlayerControlsEffect {§public ManaShortEffect() {§super(new FilterLandPermanent("lands"));§staticText = "Tap all lands target player controls and empty his or her mana pool";§}§public ManaShortEffect(final ManaShortEffect effect) {§super(effect);§}§@Override§public ManaShortEffect copy() {§return new ManaShortEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player targetPlayer = game.getPlayer(source.getFirstTarget());§if(targetPlayer != null) {§super.apply(game, source);§targetPlayer.getManaPool().emptyPool(game);§return true;§}§return false;§}§}§
public class Regrowth extends CardImpl {§public Regrowth(UUID ownerId) {§super(ownerId, 123, "Regrowth", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{1}{G}");§this.expansionSetCode = "LEA";§this.getSpellAbility().addEffect(new ReturnToHandTargetEffect());§this.getSpellAbility().addTarget(new TargetCardInYourGraveyard());§}§public Regrowth(final Regrowth card) {§super(card);§}§@Override§public Regrowth copy() {§return new Regrowth(this);§}§}§
public class UndergroundSea extends CardImpl {§public UndergroundSea(UUID ownerId) {§super(ownerId, 295, "Underground Sea", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "LEA";§this.subtype.add("Island");§this.subtype.add("Swamp");§this.addAbility(new BlueManaAbility());§this.addAbility(new BlackManaAbility());§}§public UndergroundSea(final UndergroundSea card) {§super(card);§}§@Override§public UndergroundSea copy() {§return new UndergroundSea(this);§}§}§
public class AquitectsWill extends CardImpl {§private final static FilterControlledPermanent filter = new FilterControlledPermanent("Merfolk");§static {§filter.add(new SubtypePredicate("Merfolk"));§}§public AquitectsWill(UUID ownerId) {§super(ownerId, 52, "Aquitect's Will", Rarity.COMMON, new CardType[]{CardType.TRIBAL, CardType.SORCERY}, "{U}");§this.expansionSetCode = "LRW";§this.subtype.add("Merfolk");§this.getSpellAbility().addEffect(new AddCountersTargetEffect(CounterType.FLOOD.createInstance()));§this.getSpellAbility().addTarget(new TargetLandPermanent());§this.getSpellAbility().addEffect(new AquitectsWillEffect(Duration.Custom, false, false, "Island"));§this.getSpellAbility().addEffect(new ConditionalOneShotEffect(§new DrawCardSourceControllerEffect(1),§new PermanentsOnTheBattlefieldCondition(filter),§"If you control a Merfolk, draw a card"));§}§public AquitectsWill(final AquitectsWill card) {§super(card);§}§@Override§public AquitectsWill copy() {§return new AquitectsWill(this);§}§}§class AquitectsWillEffect extends BecomesBasicLandTargetEffect {§public AquitectsWillEffect(Duration duration, boolean chooseLandType, boolean loseType, String... landNames) {§super(duration, chooseLandType, loseType, landNames);§staticText = "That land is an Island in addition to its other types for as long as it has a flood counter on it";§}§public AquitectsWillEffect(final AquitectsWillEffect effect) {§super(effect);§}§@Override§public boolean apply(Layer layer, SubLayer sublayer, Ability source, Game game) {§Permanent land = game.getPermanent(this.targetPointer.getFirst(game, source));§if (land == null) {§this.discard();§} else if (land.getCounters().getCount(CounterType.FLOOD) > 0) {§super.apply(layer, sublayer, source, game);§}§return true;§}§@Override§public AquitectsWillEffect copy() {§return new AquitectsWillEffect(this);§}§}§
public class BrokenAmbitions extends CardImpl {§public BrokenAmbitions(UUID ownerId) {§super(ownerId, 54, "Broken Ambitions", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{X}{U}");§this.expansionSetCode = "LRW";§this.getSpellAbility().addEffect(new BrokenAmbitionsEffect(new ManacostVariableValue()));§this.getSpellAbility().addTarget(new TargetSpell());§}§public BrokenAmbitions(final BrokenAmbitions card) {§super(card);§}§@Override§public BrokenAmbitions copy() {§return new BrokenAmbitions(this);§}§}§class BrokenAmbitionsEffect extends OneShotEffect {§protected Cost cost;§protected DynamicValue genericMana;§public BrokenAmbitionsEffect(Cost cost) {§super(Outcome.Benefit);§this.cost = cost;§this.staticText = "Counter target spell unless its controller pays {X}. Clash with an opponent. If you win, that spell's controller puts the top four cards of his or her library into his or her graveyard";§}§public BrokenAmbitionsEffect(DynamicValue genericMana) {§super(Outcome.Detriment);§this.genericMana = genericMana;§}§public BrokenAmbitionsEffect(final BrokenAmbitionsEffect effect) {§super(effect);§if (effect.cost != null) {§this.cost = effect.cost.copy();§}§if (effect.genericMana != null) {§this.genericMana = effect.genericMana.copy();§}§}§@Override§public BrokenAmbitionsEffect copy() {§return new BrokenAmbitionsEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Spell spell = (Spell) game.getStack().getStackObject(getTargetPointer().getFirst(game, source));§Player controller = game.getPlayer(spell.getControllerId());§if (controller != null) {§Cost costToPay;§if (cost != null) {§costToPay = cost.copy();§} else {§costToPay = new GenericManaCost(genericMana.calculate(game, source, this));§}§String message;§if (costToPay instanceof ManaCost) {§message = "Would you like to pay " + costToPay.getText() + " to prevent counter effect?";§} else {§message = costToPay.getText() + " to prevent counter effect?";§}§costToPay.clearPaid();§if (!(controller.chooseUse(Outcome.Benefit, message, source, game) && costToPay.pay(source, game, spell.getSourceId(), spell.getControllerId(), false, null))) {§game.getStack().counter(spell.getId(), source.getSourceId(), game);§}§if (ClashEffect.getInstance().apply(game, source)) {§controller.moveCards(controller.getLibrary().getTopCards(game, 4), Zone.LIBRARY, Zone.GRAVEYARD, source, game);§}§return true;§}§return false;§}§}§
public class Dread extends CardImpl {§public Dread(UUID ownerId) {§super(ownerId, 107, "Dread", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{B}{B}{B}");§this.expansionSetCode = "LRW";§this.subtype.add("Elemental");§this.subtype.add("Incarnation");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(FearAbility.getInstance());§this.addAbility(new DreadTriggeredAbility());§this.addAbility(new PutIntoGraveFromAnywhereSourceTriggeredAbility(new ShuffleIntoLibrarySourceEffect()));§}§public Dread(final Dread card) {§super(card);§}§@Override§public Dread copy() {§return new Dread(this);§}§}§class DreadTriggeredAbility extends TriggeredAbilityImpl {§DreadTriggeredAbility() {§super(Zone.BATTLEFIELD, new DestroyTargetEffect(), false);§}§DreadTriggeredAbility(final DreadTriggeredAbility ability) {§super(ability);§}§@Override§public DreadTriggeredAbility copy() {§return new DreadTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_PLAYER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getPlayerId().equals(this.getControllerId())) {§Permanent permanent = game.getPermanent(event.getSourceId());§if (permanent != null && permanent.getCardType().contains(CardType.CREATURE)) {§for (Effect effect : this.getEffects()) {§if (effect instanceof DestroyTargetEffect) {§effect.setTargetPointer(new FixedTarget(event.getSourceId()));§}§}§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever a creature deals damage to you, destroy it.";§}§}§
public class FistfulOfForce extends CardImpl {§public FistfulOfForce(UUID ownerId) {§super(ownerId, 212, "Fistful of Force", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{G}");§this.expansionSetCode = "LRW";§this.getSpellAbility().addEffect(new FistfulOfForceEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public FistfulOfForce(final FistfulOfForce card) {§super(card);§}§@Override§public FistfulOfForce copy() {§return new FistfulOfForce(this);§}§}§class FistfulOfForceEffect extends OneShotEffect {§public FistfulOfForceEffect() {§super(Outcome.BoostCreature);§this.staticText = "Target creature gets +2/+2 until end of turn. Clash with an opponent. If you win, that creature gets an additional +2/+2 and gains trample until end of turn";§}§public FistfulOfForceEffect(final FistfulOfForceEffect effect) {§super(effect);§}§@Override§public FistfulOfForceEffect copy() {§return new FistfulOfForceEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Permanent creature = game.getPermanent(getTargetPointer().getFirst(game, source));§if (controller != null && creature != null) {§ContinuousEffect effect = new BoostTargetEffect(2,2,Duration.EndOfTurn);§effect.setTargetPointer(new FixedTarget(creature.getId()));§game.addEffect(effect, source);§if (ClashEffect.getInstance().apply(game, source)) {§game.addEffect(effect.copy(), source);§effect = new GainAbilityTargetEffect(TrampleAbility.getInstance(), Duration.EndOfTurn);§effect.setTargetPointer(new FixedTarget(creature.getId()));§game.addEffect(effect.copy(), source);§}§return true;§}§return false;§}§}§
public class HearthcageGiant extends CardImpl {§private static final FilterControlledPermanent filterElemental = new FilterControlledPermanent("Elemental");§private static final FilterCreaturePermanent filterGiant = new FilterCreaturePermanent("Giant");§static {§filterElemental.add(new SubtypePredicate("Elemental"));§filterGiant.add(new SubtypePredicate("Giant"));§}§public HearthcageGiant(UUID ownerId) {§super(ownerId, 174, "Hearthcage Giant", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{6}{R}{R}");§this.expansionSetCode = "LRW";§this.subtype.add("Giant");§this.subtype.add("Warrior");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(new EntersBattlefieldTriggeredAbility(new CreateTokenEffect(new RedElementalToken(), 2), false));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(3, 1, Duration.EndOfTurn), new SacrificeTargetCost(new TargetControlledPermanent(filterElemental)));§ability.addTarget(new TargetCreaturePermanent(filterGiant));§this.addAbility(ability);§}§public HearthcageGiant(final HearthcageGiant card) {§super(card);§}§@Override§public HearthcageGiant copy() {§return new HearthcageGiant(this);§}§}§class RedElementalToken extends Token {§RedElementalToken() {§super("Elemental Shaman", "3/1 red Elemental Shaman creature token");§cardType.add(CardType.CREATURE);§color.setRed(true);§subtype.add("Elemental");§subtype.add("Shaman");§power = new MageInt(3);§toughness = new MageInt(1);§}§}§
public class KithkinDaggerdare extends CardImpl {§public KithkinDaggerdare(UUID ownerId) {§super(ownerId, 223, "Kithkin Daggerdare", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "LRW";§this.subtype.add("Kithkin");§this.subtype.add("Soldier");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(2, 2, Duration.EndOfTurn), new ColoredManaCost(ColoredManaSymbol.G));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetAttackingCreature());§this.addAbility(ability);§}§public KithkinDaggerdare(final KithkinDaggerdare card) {§super(card);§}§@Override§public KithkinDaggerdare copy() {§return new KithkinDaggerdare(this);§}§}§
public class NamelessInversion extends CardImpl {§public NamelessInversion(UUID ownerId) {§super(ownerId, 128, "Nameless Inversion", Rarity.COMMON, new CardType[]{CardType.TRIBAL, CardType.INSTANT}, "{1}{B}");§this.expansionSetCode = "LRW";§this.subtype.add("Shapeshifter");§this.addAbility(ChangelingAbility.getInstance());§Effect effect = new BoostTargetEffect(3, -3, Duration.EndOfTurn);§effect.setText("Target creature gets +3/-3");§this.getSpellAbility().addEffect(effect);§effect = new LoseAllCreatureTypesTargetEffect(Duration.EndOfTurn);§effect.setText("and loses all creature types until end of turn");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public NamelessInversion(final NamelessInversion card) {§super(card);§}§@Override§public NamelessInversion copy() {§return new NamelessInversion(this);§}§}§
public class ScarredVinebreeder extends CardImpl {§private static final FilterCard filter = new FilterCard("Elf card from your graveyard");§static {§filter.add(new SubtypePredicate("Elf"));§}§public ScarredVinebreeder(UUID ownerId) {§super(ownerId, 138, "Scarred Vinebreeder", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "LRW";§this.subtype.add("Elf");§this.subtype.add("Shaman");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new BoostSourceEffect(3, 3, Duration.EndOfTurn),§new ManaCostsImpl("{2}{B}"));§ability.addCost(new ExileFromGraveCost(new TargetCardInYourGraveyard(filter)));§this.addAbility(ability);§}§public ScarredVinebreeder(final ScarredVinebreeder card) {§super(card);§}§@Override§public ScarredVinebreeder copy() {§return new ScarredVinebreeder(this);§}§}§
public class SummonTheSchool extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("untapped Merfolk you control");§static {§filter.add(Predicates.not(new TappedPredicate()));§filter.add(new SubtypePredicate("Merfolk"));§}§public SummonTheSchool(UUID ownerId) {§super(ownerId, 42, "Summon the School", Rarity.UNCOMMON, new CardType[]{CardType.TRIBAL, CardType.SORCERY}, "{3}{W}");§this.expansionSetCode = "LRW";§this.subtype.add("Merfolk");§this.getSpellAbility().addEffect(new CreateTokenEffect(new MerfolkWizardToken(), 2));§this.addAbility(new SimpleActivatedAbility(Zone.GRAVEYARD, new ReturnToHandSourceEffect(), new TapTargetCost(new TargetControlledPermanent(4, 4, filter, false))));§}§public SummonTheSchool(final SummonTheSchool card) {§super(card);§}§@Override§public SummonTheSchool copy() {§return new SummonTheSchool(this);§}§}§
public class VividMeadow extends CardImpl {§public VividMeadow(UUID ownerId) {§super(ownerId, 279, "Vivid Meadow", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "LRW";§Ability ability = new EntersBattlefieldAbility(new TapSourceEffect(true), false, null, "{this} enters the battlefield tapped with two charge counters on it", null);§ability.addEffect(new AddCountersSourceEffect(CounterType.CHARGE.createInstance(2)));§this.addAbility(ability);§this.addAbility(new WhiteManaAbility());§ability = new AnyColorManaAbility();§ability.addCost(new RemoveCountersSourceCost(CounterType.CHARGE.createInstance(1)));§this.addAbility(ability);§}§public VividMeadow(final VividMeadow card) {§super(card);§}§@Override§public VividMeadow copy() {§return new VividMeadow(this);§}§}§
public class AjaniGoldmane extends CardImpl {§public AjaniGoldmane(UUID ownerId) {§super(ownerId, 1, "Ajani Goldmane", Rarity.MYTHIC, new CardType[]{CardType.PLANESWALKER}, "{2}{W}{W}");§this.expansionSetCode = "M10";§this.subtype.add("Ajani");§this.addAbility(new PlanswalkerEntersWithLoyalityCountersAbility(4));§this.addAbility(new LoyaltyAbility(new GainLifeEffect(2), 1));§Effects effects1 = new Effects();§effects1.add(new AddCountersAllEffect(CounterType.P1P1.createInstance(), new FilterControlledCreaturePermanent()));§effects1.add(new GainAbilityControlledEffect(VigilanceAbility.getInstance(), Duration.EndOfTurn, new FilterCreaturePermanent()));§this.addAbility(new LoyaltyAbility(effects1, -1));§this.addAbility(new LoyaltyAbility(new CreateTokenEffect(new AvatarToken()), -6));§}§public AjaniGoldmane(final AjaniGoldmane card) {§super(card);§}§@Override§public AjaniGoldmane copy() {§return new AjaniGoldmane(this);§}§}§class AvatarToken extends Token {§public AvatarToken() {§super("Avatar", "white Avatar creature token with \"This creature's power and toughness are each equal to your life total.\"");§cardType.add(CardType.CREATURE);§subtype.add("Avatar");§color.setWhite(true);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new AvatarTokenEffect()));§}§}§class AvatarTokenEffect extends ContinuousEffectImpl {§public AvatarTokenEffect() {§super(Duration.WhileOnBattlefield, Layer.PTChangingEffects_7, SubLayer.SetPT_7b, Outcome.BoostCreature);§}§public AvatarTokenEffect(final AvatarTokenEffect effect) {§super(effect);§}§@Override§public AvatarTokenEffect copy() {§return new AvatarTokenEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent token = game.getPermanent(source.getSourceId());§if (token != null) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§token.getPower().setValue(controller.getLife());§token.getToughness().setValue(controller.getLife());§return true;§}§}§return false;§}§}§
public class ChandraNalaar extends CardImpl {§public ChandraNalaar(UUID ownerId) {§super(ownerId, 132, "Chandra Nalaar", Rarity.MYTHIC, new CardType[]{CardType.PLANESWALKER}, "{3}{R}{R}");§this.expansionSetCode = "M10";§this.subtype.add("Chandra");§this.addAbility(new PlanswalkerEntersWithLoyalityCountersAbility(6));§LoyaltyAbility ability1 = new LoyaltyAbility(new DamageTargetEffect(1), 1);§ability1.addTarget(new TargetPlayer());§this.addAbility(ability1);§LoyaltyAbility ability2 = new LoyaltyAbility(new DamageTargetEffect(ChandraNalaarXValue.getDefault()));§ability2.addTarget(new TargetCreaturePermanent());§this.addAbility(ability2);§Effects effects1 = new Effects();§effects1.add(new DamageTargetEffect(10));§effects1.add(new DamageAllControlledTargetEffect(10, new FilterCreaturePermanent()));§LoyaltyAbility ability3 = new LoyaltyAbility(effects1, -8);§ability3.addTarget(new TargetPlayer());§this.addAbility(ability3);§}§public ChandraNalaar(final ChandraNalaar card) {§super(card);§}§@Override§public ChandraNalaar copy() {§return new ChandraNalaar(this);§}§}§class ChandraNalaarXValue implements DynamicValue {§private static final ChandraNalaarXValue defaultValue = new ChandraNalaarXValue();§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§for (Cost cost : sourceAbility.getCosts()) {§if (cost instanceof PayVariableLoyaltyCost) {§return ((PayVariableLoyaltyCost) cost).getAmount();§}§}§return 0;§}§@Override§public DynamicValue copy() {§return defaultValue;§}§@Override§public String getMessage() {§return "";§}§@Override§public String toString() {§return "X";§}§public static ChandraNalaarXValue getDefault() {§return defaultValue;§}§}§
public class EliteVanguard extends CardImpl {§public EliteVanguard(UUID ownerId) {§super(ownerId, 9, "Elite Vanguard", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{W}");§this.expansionSetCode = "M10";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§}§public EliteVanguard(final EliteVanguard card) {§super(card);§}§@Override§public EliteVanguard copy() {§return new EliteVanguard(this);§}§}§
public class GuardianSeraph extends CardImpl {§public GuardianSeraph(UUID ownerId) {§super(ownerId, 13, "Guardian Seraph", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{W}{W}");§this.expansionSetCode = "M10";§this.subtype.add("Angel");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GuardianSeraphEffect()));§}§public GuardianSeraph(final GuardianSeraph card) {§super(card);§}§@Override§public GuardianSeraph copy() {§return new GuardianSeraph(this);§}§}§class GuardianSeraphEffect extends PreventionEffectImpl {§public GuardianSeraphEffect() {§super(Duration.WhileOnBattlefield, 1, false, false);§this.staticText = "If a source an opponent controls would deal damage to you, prevent 1 of that damage";§}§public GuardianSeraphEffect(final GuardianSeraphEffect effect) {§super(effect);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType().equals(GameEvent.EventType.DAMAGE_PLAYER);§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (event.getTargetId().equals(source.getControllerId())) {§UUID sourceControllerId = game.getControllerId(event.getSourceId());§if (sourceControllerId != null && game.getOpponents(source.getControllerId()).contains(sourceControllerId)) {§return super.applies(event, source, game);§}§}§return false;§}§@Override§public GuardianSeraphEffect copy() {§return new GuardianSeraphEffect(this);§}§}§
public class KindledFury extends CardImpl {§public KindledFury(UUID ownerId) {§super(ownerId, 144, "Kindled Fury", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{R}");§this.expansionSetCode = "M10";§this.getSpellAbility().addEffect(new BoostTargetEffect(1, 0, Duration.EndOfTurn));§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public KindledFury(final KindledFury card) {§super(card);§}§@Override§public KindledFury copy() {§return new KindledFury(this);§}§}§
public class Oakenform extends CardImpl {§public Oakenform(UUID ownerId) {§super(ownerId, 197, "Oakenform", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{G}");§this.expansionSetCode = "M10";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new OakenformEffect()));§}§public Oakenform(final Oakenform card) {§super(card);§}§@Override§public Oakenform copy() {§return new Oakenform(this);§}§}§class OakenformEffect extends ContinuousEffectImpl {§public OakenformEffect() {§super(Duration.WhileOnBattlefield, Outcome.BoostCreature);§staticText = "Enchanted creature gets +3/+3";§}§public OakenformEffect(final OakenformEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability ablt) {§return false;§}§@Override§public boolean apply(Layer layer, SubLayer sublayer, Ability source, Game game) {§Permanent enchantment = game.getPermanent(source.getSourceId());§if (enchantment != null && enchantment.getAttachedTo() != null) {§Permanent creature = game.getPermanent(enchantment.getAttachedTo());§if (creature != null) {§switch (layer) {§case PTChangingEffects_7:§if (sublayer == SubLayer.ModifyPT_7c) {§creature.addPower(3);§creature.addToughness(3);§}§break;§}§return true;§}§}§return false;§}§@Override§public boolean hasLayer(Layer layer) {§return layer == Layer.PTChangingEffects_7;§}§@Override§public OakenformEffect copy() {§return new OakenformEffect(this);§}§}§
public class SanguineBond extends CardImpl {§public SanguineBond(UUID ownerId) {§super(ownerId, 111, "Sanguine Bond", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{3}{B}{B}");§this.expansionSetCode = "M10";§SanguineBondTriggeredAbility ability = new SanguineBondTriggeredAbility();§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§}§public SanguineBond(final SanguineBond card) {§super(card);§}§@Override§public SanguineBond copy() {§return new SanguineBond(this);§}§}§class SanguineBondTriggeredAbility extends TriggeredAbilityImpl {§public SanguineBondTriggeredAbility() {§super(Zone.BATTLEFIELD, null);§}§public SanguineBondTriggeredAbility(final SanguineBondTriggeredAbility ability) {§super(ability);§}§@Override§public SanguineBondTriggeredAbility copy() {§return new SanguineBondTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.GAINED_LIFE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getPlayerId().equals(this.controllerId)) {§this.getEffects().clear();§this.addEffect(new LoseLifeTargetEffect(event.getAmount()));§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever you gain life, target opponent loses that much life.";§}§}§
public class TendrilsOfCorruption extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("Swamp you control");§static {§filter.add(new SubtypePredicate("Swamp"));§}§public TendrilsOfCorruption(UUID ownerId) {§super(ownerId, 114, "Tendrils of Corruption", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{3}{B}");§this.expansionSetCode = "M10";§this.getSpellAbility().addEffect(new DamageTargetEffect(new PermanentsOnBattlefieldCount(filter)));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new GainLifeEffect(new PermanentsOnBattlefieldCount(filter)));§}§public TendrilsOfCorruption(final TendrilsOfCorruption card) {§super(card);§}§@Override§public TendrilsOfCorruption copy() {§return new TendrilsOfCorruption(this);§}§}§
public class Windstorm extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature with flying");§static {§filter.add(new AbilityPredicate(FlyingAbility.class));§}§public Windstorm(UUID ownerId) {§super(ownerId, 205, "Windstorm", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{X}{G}");§this.expansionSetCode = "M10";§this.getSpellAbility().addEffect(new DamageAllEffect(new ManacostVariableValue(), filter));§}§public Windstorm(final Windstorm card) {§super(card);§}§@Override§public Windstorm copy() {§return new Windstorm(this);§}§}§
public class BogRaiders extends CardImpl {§public BogRaiders(UUID ownerId) {§super(ownerId, 86, "Bog Raiders", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "M11";§this.subtype.add("Zombie");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SwampwalkAbility());§}§public BogRaiders(final BogRaiders card) {§super(card);§}§@Override§public BogRaiders copy() {§return new BogRaiders(this);§}§}§
public class EarthServant extends CardImpl {§private static final FilterLandPermanent filter = new FilterLandPermanent("Mountain you control");§static {§filter.add(new SubtypePredicate("Mountain"));§filter.add(new ControllerPredicate(TargetController.YOU));§}§public EarthServant(UUID ownerId) {§super(ownerId, 134, "Earth Servant", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{5}{R}");§this.expansionSetCode = "M11";§this.subtype.add("Elemental");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostSourceEffect(new PermanentsOnBattlefieldCount(filter, 0),§new PermanentsOnBattlefieldCount(filter, 1),§Duration.WhileOnBattlefield)));§}§public EarthServant(final EarthServant card) {§super(card);§}§@Override§public EarthServant copy() {§return new EarthServant(this);§}§}§
public class Incite extends CardImpl {§public Incite(UUID ownerId) {§super(ownerId, 145, "Incite", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{R}");§this.expansionSetCode = "M11";§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new BecomesColorTargetEffect(ObjectColor.RED, Duration.EndOfTurn, "Target creature becomes red until end of turn"));§this.getSpellAbility().addEffect(new AttacksIfAbleTargetEffect(Duration.EndOfTurn));§}§public Incite(final Incite card) {§super(card);§}§@Override§public Incite copy() {§return new Incite(this);§}§}§
public class MightyLeap extends CardImpl {§public MightyLeap(UUID ownerId) {§super(ownerId, 22, "Mighty Leap", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{W}");§this.expansionSetCode = "M11";§Effect effect = new BoostTargetEffect(2, 2, Duration.EndOfTurn);§effect.setText("Target creature gets +2/+2");§this.getSpellAbility().addEffect(effect);§effect = new GainAbilityTargetEffect(FlyingAbility.getInstance(), Duration.EndOfTurn);§effect.setText("and gains flying until end of turn");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public MightyLeap(final MightyLeap card) {§super(card);§}§@Override§public MightyLeap copy() {§return new MightyLeap(this);§}§}§
public class RocEgg extends CardImpl {§private static RocEggToken rocEggToken = new RocEggToken();§public RocEgg(UUID ownerId) {§super(ownerId, 25, "Roc Egg", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "M11";§this.subtype.add("Bird");§this.power = new MageInt(0);§this.toughness = new MageInt(3);§this.addAbility(DefenderAbility.getInstance());§this.addAbility(new DiesTriggeredAbility(new CreateTokenEffect(rocEggToken, 1), false));§}§public RocEgg(final RocEgg card) {§super(card);§}§@Override§public RocEgg copy() {§return new RocEgg(this);§}§}§class RocEggToken extends Token {§public RocEggToken() {§super("Bird", "3/3 white Bird creature token with flying");§cardType.add(CardType.CREATURE);§subtype.add("Bird");§color.setWhite(true);§power = new MageInt(3);§toughness = new MageInt(3);§addAbility(FlyingAbility.getInstance());§}§}§
public class VengefulArchon extends CardImpl {§public VengefulArchon(UUID ownerId) {§super(ownerId, 37, "Vengeful Archon", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{W}{W}{W}");§this.expansionSetCode = "M11";§this.subtype.add("Archon");§this.power = new MageInt(7);§this.toughness = new MageInt(7);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new VengefulArchonEffect(), new ManaCostsImpl("{X}"));§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public VengefulArchon(final VengefulArchon card) {§super(card);§}§@Override§public VengefulArchon copy() {§return new VengefulArchon(this);§}§}§class VengefulArchonEffect extends PreventionEffectImpl {§protected int amount = 0;§public VengefulArchonEffect() {§super(Duration.EndOfTurn);§staticText = "Prevent the next X damage that would be dealt to you this turn. If damage is prevented this way, {this} deals that much damage to target player";§}§public VengefulArchonEffect(final VengefulArchonEffect effect) {§super(effect);§this.amount = effect.amount;§}§@Override§public VengefulArchonEffect copy() {§return new VengefulArchonEffect(this);§}§@Override§public void init(Ability source, Game game) {§super.init(source, game);§amount = source.getManaCostsToPay().getX();§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§GameEvent preventEvent = new GameEvent(GameEvent.EventType.PREVENT_DAMAGE, source.getControllerId(), source.getSourceId(), source.getControllerId(), event.getAmount(), false);§if (!game.replaceEvent(preventEvent)) {§Player player = game.getPlayer(source.getFirstTarget());§if (player != null) {§int damage = event.getAmount();§if (event.getAmount() >= this.amount) {§event.setAmount(damage - this.amount);§damage = this.amount;§this.used = true;§} else {§event.setAmount(0);§this.amount -= damage;§}§player.damage(damage, source.getSourceId(), game, false, true);§game.fireEvent(GameEvent.getEvent(GameEvent.EventType.PREVENTED_DAMAGE,§source.getControllerId(), source.getSourceId(), source.getControllerId(), damage));§}§}§return false;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (!this.used && super.applies(event, source, game) && event.getTargetId().equals(source.getControllerId())) {§return true;§}§return false;§}§}§
public class Auramancer extends CardImpl {§private static final FilterCard filter = new FilterCard("enchantment card from your graveyard");§static {§filter.add(new CardTypePredicate(CardType.ENCHANTMENT));§}§public Auramancer(UUID ownerId) {§super(ownerId, 9, "Auramancer", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "M12";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new EntersBattlefieldTriggeredAbility(new ReturnToHandTargetEffect(), true);§ability.addTarget(new TargetCardInYourGraveyard(filter));§this.addAbility(ability);§}§public Auramancer(final Auramancer card) {§super(card);§}§@Override§public Auramancer copy() {§return new Auramancer(this);§}§}§
public class DarkFavor extends CardImpl {§public DarkFavor(UUID ownerId) {§super(ownerId, 89, "Dark Favor", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{B}");§this.expansionSetCode = "M12";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new EntersBattlefieldTriggeredAbility(new LoseLifeSourceControllerEffect(1), false));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(3, 1, Duration.WhileOnBattlefield)));§}§public DarkFavor(final DarkFavor card) {§super(card);§}§@Override§public DarkFavor copy() {§return new DarkFavor(this);§}§}§
public class GoblinGrenade extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("a Goblin");§static {§filter.add(new SubtypePredicate("Goblin"));§}§public GoblinGrenade(UUID ownerId) {§super(ownerId, 140, "Goblin Grenade", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{R}");§this.expansionSetCode = "M12";§this.getSpellAbility().addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent(1, 1, filter, false)));§this.getSpellAbility().addEffect(new DamageTargetEffect(5));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§}§public GoblinGrenade(final GoblinGrenade card) {§super(card);§}§@Override§public GoblinGrenade copy() {§return new GoblinGrenade(this);§}§}§
public class MerfolkMesmerist extends CardImpl {§public MerfolkMesmerist(UUID ownerId) {§super(ownerId, 66, "Merfolk Mesmerist", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "M12";§this.subtype.add("Merfolk");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PutLibraryIntoGraveTargetEffect(2), new ColoredManaCost(ColoredManaSymbol.U));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public MerfolkMesmerist(final MerfolkMesmerist card) {§super(card);§}§@Override§public MerfolkMesmerist copy() {§return new MerfolkMesmerist(this);§}§}§
public class Smallpox extends CardImpl {§private static final FilterControlledPermanent filterCreature = new FilterControlledCreaturePermanent();§private static final FilterControlledPermanent filterLand = new FilterControlledLandPermanent();§public Smallpox(UUID ownerId) {§super(ownerId, 108, "Smallpox", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{B}{B}");§this.expansionSetCode = "M12";§this.getSpellAbility().addEffect(new LoseLifeAllPlayersEffect(1));§Effect effect = new DiscardEachPlayerEffect();§effect.setText(", discards a card");§this.getSpellAbility().addEffect(effect);§effect = new SacrificeAllEffect(1, filterCreature);§effect.setText(", sacrifices a creature");§this.getSpellAbility().addEffect(effect);§effect = new SacrificeAllEffect(1, filterLand);§effect.setText(", then sacrifices a land");§this.getSpellAbility().addEffect(effect);§}§public Smallpox(final Smallpox card) {§super(card);§}§@Override§public Smallpox copy() {§return new Smallpox(this);§}§}§
public class TormentedSoul extends CardImpl {§public TormentedSoul(UUID ownerId) {§super(ownerId, 114, "Tormented Soul", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{B}");§this.expansionSetCode = "M12";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new CantBlockAbility());§this.addAbility(new CantBeBlockedSourceAbility());§}§public TormentedSoul(final TormentedSoul card) {§super(card);§}§@Override§public TormentedSoul copy() {§return new TormentedSoul(this);§}§}§
public class AugurOfBolas extends CardImpl {§private static final FilterCard filter = new FilterCard("an instant or sorcery card");§static {§filter.add(Predicates.or(new CardTypePredicate(CardType.INSTANT), new CardTypePredicate(CardType.SORCERY)));§}§public AugurOfBolas(UUID ownerId) {§super(ownerId, 43, "Augur of Bolas", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "M13";§this.subtype.add("Merfolk");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§this.addAbility(new EntersBattlefieldTriggeredAbility(new AugurOfBolasEffect()));§}§public AugurOfBolas(final AugurOfBolas card) {§super(card);§}§@Override§public AugurOfBolas copy() {§return new AugurOfBolas(this);§}§}§class AugurOfBolasEffect extends OneShotEffect {§public AugurOfBolasEffect() {§super(Outcome.DrawCard);§this.staticText = "look at the top three cards of your library. You may reveal an instant or sorcery card from among them and put it into your hand. Put the rest on the bottom of your library in any order";§}§public AugurOfBolasEffect(final AugurOfBolasEffect effect) {§super(effect);§}§@Override§public AugurOfBolasEffect copy() {§return new AugurOfBolasEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = game.getObject(source.getSourceId());§if (controller != null && sourceObject != null) {§Cards topCards = new CardsImpl();§topCards.addAll(controller.getLibrary().getTopCards(game, 3));§if (!topCards.isEmpty()) {§controller.lookAtCards(sourceObject.getIdName(), topCards, game);§int number = topCards.count(new FilterInstantOrSorceryCard(), source.getSourceId(), source.getControllerId(), game);§if (number > 0) {§if (controller.chooseUse(outcome, "Reveal an instant or sorcery card from the looked at cards and put it into your hand?", source, game)) {§Card card;§if (number == 1) {§card = topCards.getCards(new FilterInstantOrSorceryCard(), source.getSourceId(), source.getControllerId(), game).iterator().next();§} else {§Target target = new TargetCard(Zone.LIBRARY, new FilterInstantOrSorceryCard());§controller.chooseTarget(outcome, target, source, game);§card = topCards.get(target.getFirstTarget(), game);§}§if (card != null) {§controller.moveCards(card, Zone.HAND, source, game);§controller.revealCards(sourceObject.getIdName(), new CardsImpl(card), game);§topCards.remove(card);§}§}§controller.putCardsOnBottomOfLibrary(topCards, game, source, true);§}§}§return true;§}§return false;§}§}§
public class Downpour extends CardImpl {§public Downpour(UUID ownerId) {§super(ownerId, 48, "Downpour", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "M13";§this.getSpellAbility().addEffect(new TapTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent(0, 3));§}§public Downpour(final Downpour card) {§super(card);§}§@Override§public Downpour copy() {§return new Downpour(this);§}§}§
public class HamletbackGoliath extends CardImpl {§public HamletbackGoliath(UUID ownerId) {§super(ownerId, 136, "Hamletback Goliath", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{6}{R}");§this.expansionSetCode = "M13";§this.subtype.add("Giant");§this.subtype.add("Warrior");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(new HamletbackGoliathTriggeredAbility());§}§public HamletbackGoliath(final HamletbackGoliath card) {§super(card);§}§@Override§public HamletbackGoliath copy() {§return new HamletbackGoliath(this);§}§}§class HamletbackGoliathTriggeredAbility extends TriggeredAbilityImpl {§HamletbackGoliathTriggeredAbility() {§super(Zone.BATTLEFIELD, new HamletbackGoliathEffect(), true);§}§HamletbackGoliathTriggeredAbility(final HamletbackGoliathTriggeredAbility ability) {§super(ability);§}§@Override§public HamletbackGoliathTriggeredAbility copy() {§return new HamletbackGoliathTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ENTERS_THE_BATTLEFIELD;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§UUID targetId = event.getTargetId();§Permanent permanent = game.getPermanent(targetId);§if (permanent.getCardType().contains(CardType.CREATURE)§&& !(targetId.equals(this.getSourceId()))) {§for (Effect effect : this.getEffects()) {§effect.setTargetPointer(new FixedTarget(event.getTargetId()));§}§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever another creature enters the battlefield, you may put X +1/+1 counters on Hamletback Goliath, where X is that creature's power.";§}§}§class HamletbackGoliathEffect extends OneShotEffect {§HamletbackGoliathEffect() {§super(Outcome.BoostCreature);§}§HamletbackGoliathEffect(final HamletbackGoliathEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent creature = game.getPermanent(targetPointer.getFirst(game, source));§Permanent HamletbackGoliath = game.getPermanent(source.getSourceId());§if (creature == null) {§creature = (Permanent) game.getLastKnownInformation(targetPointer.getFirst(game, source), Zone.BATTLEFIELD);§}§if (creature != null) {§HamletbackGoliath.addCounters(CounterType.P1P1.createInstance(creature.getPower().getValue()), game);§return true;§}§return false;§}§@Override§public HamletbackGoliathEffect copy() {§return new HamletbackGoliathEffect(this);§}§}§
public class MwonvuliBeastTracker extends CardImpl {§private static final FilterCard filter = new FilterCard("creature card with deathtouch, hexproof, reach, or trample in your library");§static {§filter.add(new CardTypePredicate(CardType.CREATURE));§filter.add(Predicates.or(§new AbilityPredicate(DeathtouchAbility.class),§new AbilityPredicate(HexproofAbility.class),§new AbilityPredicate(ReachAbility.class),§new AbilityPredicate(TrampleAbility.class)));§}§public MwonvuliBeastTracker(UUID ownerId) {§super(ownerId, 177, "Mwonvuli Beast Tracker", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{G}{G}");§this.expansionSetCode = "M13";§this.subtype.add("Human");§this.subtype.add("Scout");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new EntersBattlefieldTriggeredAbility(new SearchLibraryPutOnLibraryEffect(new TargetCardInLibrary(filter), true, true)));§}§public MwonvuliBeastTracker(final MwonvuliBeastTracker card) {§super(card);§}§@Override§public MwonvuliBeastTracker copy() {§return new MwonvuliBeastTracker(this);§}§}§
public class SandsOfDelirium extends CardImpl {§public SandsOfDelirium(UUID ownerId) {§super(ownerId, 216, "Sands of Delirium", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "M13";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PutLibraryIntoGraveTargetEffect(new ManacostVariableValue()), new VariableManaCost());§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public SandsOfDelirium(final SandsOfDelirium card) {§super(card);§}§@Override§public SandsOfDelirium copy() {§return new SandsOfDelirium(this);§}§}§
public class TradingPost extends CardImpl {§public TradingPost(UUID ownerId) {§super(ownerId, 220, "Trading Post", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "M13";§Ability ability1 = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainLifeEffect(4), new GenericManaCost(1));§ability1.addCost(new TapSourceCost());§ability1.addCost(new DiscardTargetCost(new TargetCardInHand()));§this.addAbility(ability1);§Ability ability2 = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CreateTokenEffect(new GoatToken()), new GenericManaCost(1));§ability2.addCost(new TapSourceCost());§ability2.addCost(new PayLifeCost(1));§this.addAbility(ability2);§Ability ability3 = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ReturnFromGraveyardToHandTargetEffect(), new GenericManaCost(1));§ability3.addTarget(new TargetCardInGraveyard(new FilterArtifactCard("an artifact card in your graveyard")));§ability3.addCost(new TapSourceCost());§ability3.addCost(new SacrificeTargetCost(new TargetControlledPermanent(new FilterControlledCreaturePermanent("a creature"))));§this.addAbility(ability3);§Ability ability4 = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1), new GenericManaCost(1));§ability4.addCost(new TapSourceCost());§ability4.addCost(new SacrificeTargetCost(new TargetControlledPermanent(new FilterControlledArtifactPermanent("an artifact"))));§this.addAbility(ability4);§}§public TradingPost(final TradingPost card) {§super(card);§}§@Override§public TradingPost copy() {§return new TradingPost(this);§}§}§
public class ArchangelOfThune extends CardImpl {§public ArchangelOfThune(UUID ownerId) {§super(ownerId, 5, "Archangel of Thune", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{3}{W}{W}");§this.expansionSetCode = "M14";§this.subtype.add("Angel");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(LifelinkAbility.getInstance());§this.addAbility(new ArchangelOfThuneAbility());§}§public ArchangelOfThune(final ArchangelOfThune card) {§super(card);§}§@Override§public ArchangelOfThune copy() {§return new ArchangelOfThune(this);§}§}§class ArchangelOfThuneAbility extends TriggeredAbilityImpl {§public ArchangelOfThuneAbility() {§super(Zone.BATTLEFIELD, new AddCountersAllEffect(CounterType.P1P1.createInstance(), new FilterControlledCreaturePermanent()), false);§}§public ArchangelOfThuneAbility(final ArchangelOfThuneAbility ability) {§super(ability);§}§@Override§public ArchangelOfThuneAbility copy() {§return new ArchangelOfThuneAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.GAINED_LIFE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§return event.getPlayerId().equals(controllerId);§}§@Override§public String getRule() {§return "Whenever you gain life, put a +1/+1 counter on each creature you control.";§}§}§
public class DawnstrikePaladin extends CardImpl {§public DawnstrikePaladin(UUID ownerId) {§super(ownerId, 15, "Dawnstrike Paladin", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{W}{W}");§this.expansionSetCode = "M14";§this.subtype.add("Human");§this.subtype.add("Knight");§this.power = new MageInt(2);§this.toughness = new MageInt(4);§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(LifelinkAbility.getInstance());§}§public DawnstrikePaladin(final DawnstrikePaladin card) {§super(card);§}§@Override§public DawnstrikePaladin copy() {§return new DawnstrikePaladin(this);§}§}§
public class GroundshakerSliver extends CardImpl {§public GroundshakerSliver(UUID ownerId) {§super(ownerId, 177, "Groundshaker Sliver", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{6}{G}");§this.expansionSetCode = "M14";§this.subtype.add("Sliver");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD,§new GainAbilityControlledEffect(TrampleAbility.getInstance(),§Duration.WhileOnBattlefield, new FilterCreaturePermanent("Sliver","Sliver creatures"))));§}§public GroundshakerSliver(final GroundshakerSliver card) {§super(card);§}§@Override§public GroundshakerSliver copy() {§return new GroundshakerSliver(this);§}§}§
public class MinotaurAbomination extends CardImpl {§public MinotaurAbomination(UUID ownerId) {§super(ownerId, 107, "Minotaur Abomination", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{B}{B}");§this.expansionSetCode = "M14";§this.subtype.add("Zombie");§this.subtype.add("Minotaur");§this.power = new MageInt(4);§this.toughness = new MageInt(6);§}§public MinotaurAbomination(final MinotaurAbomination card) {§super(card);§}§@Override§public MinotaurAbomination copy() {§return new MinotaurAbomination(this);§}§}§
public class ShadowbornDemon extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("non-Demon creature");§static {§filter.add(Predicates.not(new SubtypePredicate("Demon")));§}§public ShadowbornDemon(UUID ownerId) {§super(ownerId, 115, "Shadowborn Demon", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{3}{B}{B}");§this.expansionSetCode = "M14";§this.subtype.add("Demon");§this.power = new MageInt(5);§this.toughness = new MageInt(6);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new DestroyTargetEffect(), false);§Target target = new TargetCreaturePermanent(filter);§ability.addTarget(target);§this.addAbility(ability);§this.addAbility(new ConditionalTriggeredAbility(§new BeginningOfUpkeepTriggeredAbility(new SacrificeControllerEffect(new FilterCreaturePermanent(), 1, ""), TargetController.YOU, false),§new InvertCondition(new CreatureCardsInControllerGraveCondition(6)),§"At the beginning of your upkeep, if there are fewer than six creature cards in your graveyard, sacrifice a creature"));§}§public ShadowbornDemon(final ShadowbornDemon card) {§super(card);§}§@Override§public ShadowbornDemon copy() {§return new ShadowbornDemon(this);§}§}§class CreatureCardsInControllerGraveCondition implements Condition {§private int value;§public CreatureCardsInControllerGraveCondition(int value) {§this.value = value;§}§@Override§public boolean apply(Game game, Ability source) {§Player p = game.getPlayer(source.getControllerId());§if (p != null && p.getGraveyard().count(new FilterCreatureCard(), game) >= value) {§return true;§}§return false;§}§}§
public class VastwoodHydra extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creatures you control");§static {§filter.add(new ControllerPredicate(TargetController.YOU));§}§public VastwoodHydra(UUID ownerId) {§super(ownerId, 198, "Vastwood Hydra", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{X}{G}{G}");§this.expansionSetCode = "M14";§this.subtype.add("Hydra");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(new EntersBattlefieldAbility(new EntersBattlefieldWithXCountersEffect(CounterType.P1P1.createInstance())));§Ability ability = new DiesTriggeredAbility(new VastwoodHydraDistributeEffect(), true);§ability.addTarget(new TargetCreaturePermanentAmount(new CountersCount(CounterType.P1P1), filter));§this.addAbility(ability);§}§public VastwoodHydra(final VastwoodHydra card) {§super(card);§}§@Override§public VastwoodHydra copy() {§return new VastwoodHydra(this);§}§}§class VastwoodHydraDistributeEffect extends OneShotEffect {§public VastwoodHydraDistributeEffect() {§super(Outcome.BoostCreature);§this.staticText = "distribute a number of +1/+1 counters equal to the number of +1/+1 counters on {this} among any number of creatures you control";§}§public VastwoodHydraDistributeEffect(final VastwoodHydraDistributeEffect effect) {§super(effect);§}§@Override§public VastwoodHydraDistributeEffect copy() {§return new VastwoodHydraDistributeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§if (source.getTargets().size() > 0) {§Target multiTarget = source.getTargets().get(0);§for (UUID target : multiTarget.getTargets()) {§Permanent permanent = game.getPermanent(target);§if (permanent != null) {§permanent.addCounters(CounterType.P1P1.createInstance(multiTarget.getTargetAmount(target)), game);§}§}§}§return true;§}§}§
public class BlastfireBolt extends CardImpl {§public BlastfireBolt(UUID ownerId) {§super(ownerId, 130, "Blastfire Bolt", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{5}{R}");§this.expansionSetCode = "M15";§this.getSpellAbility().addEffect(new DamageTargetEffect(5));§this.getSpellAbility().addEffect(new DestroyAllAttachedEquipmentEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public BlastfireBolt(final BlastfireBolt card) {§super(card);§}§@Override§public BlastfireBolt copy() {§return new BlastfireBolt(this);§}§}§class DestroyAllAttachedEquipmentEffect extends OneShotEffect {§public DestroyAllAttachedEquipmentEffect() {§super(Outcome.Benefit);§this.staticText = "Destroy all Equipment attached to that creature";§}§public DestroyAllAttachedEquipmentEffect(final DestroyAllAttachedEquipmentEffect effect) {§super(effect);§}§@Override§public DestroyAllAttachedEquipmentEffect copy() {§return new DestroyAllAttachedEquipmentEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Permanent target = game.getPermanent(source.getFirstTarget());§if (target != null) {§ArrayList<UUID> attachments = new ArrayList<>(target.getAttachments());§for (UUID attachmentId : attachments) {§Permanent attachment = game.getPermanent(attachmentId);§if (attachment != null && attachment.getSubtype().contains("Equipment")) {§attachment.destroy(source.getSourceId(), game, false);§}§}§}§return true;§}§return false;§}§}§
public class EnsoulArtifact extends CardImpl {§public EnsoulArtifact(UUID ownerId) {§super(ownerId, 54, "Ensoul Artifact", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{U}");§this.expansionSetCode = "M15";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetArtifactPermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Benefit));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD,§new BecomesCreatureAttachedEffect(new EnsoulArtifactToken(), "Enchanted artifact is a creature with base power and toughness 5/5 in addition to its other types", Duration.WhileOnBattlefield)§));§}§public EnsoulArtifact(final EnsoulArtifact card) {§super(card);§}§@Override§public EnsoulArtifact copy() {§return new EnsoulArtifact(this);§}§}§class EnsoulArtifactToken extends Token {§EnsoulArtifactToken() {§super("", "5/5");§cardType.add(CardType.CREATURE);§power = new MageInt(5);§toughness = new MageInt(5);§}§}§
public class HuntersAmbush extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("nongreen creatures");§static {§filter.add(Predicates.not(new ColorPredicate(ObjectColor.GREEN)));§}§public HuntersAmbush(UUID ownerId) {§super(ownerId, 180, "Hunter's Ambush", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{G}");§this.expansionSetCode = "M15";§this.getSpellAbility().addEffect(new PreventAllDamageByAllEffect(filter, Duration.EndOfTurn, true));§}§public HuntersAmbush(final HuntersAmbush card) {§super(card);§}§@Override§public HuntersAmbush copy() {§return new HuntersAmbush(this);§}§}§
public class MercurialPretender extends CardImpl {§private static final String effectText = "as a copy of any creature you control except it gains \"{2}{U}{U}: Return this creature to its owner's hand.\"";§public MercurialPretender(UUID ownerId) {§super(ownerId, 68, "Mercurial Pretender", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{U}");§this.expansionSetCode = "M15";§this.subtype.add("Shapeshifter");§this.color.setBlue(true);§this.power = new MageInt(0);§this.toughness = new MageInt(0);§Effect effect = new CopyPermanentEffect(new FilterControlledCreaturePermanent(),§new AbilityApplier(new SimpleActivatedAbility(Zone.BATTLEFIELD, new ReturnToHandSourceEffect(true), new ManaCostsImpl("{2}{U}{U}"))));§effect.setText(effectText);§this.addAbility(new EntersBattlefieldAbility(effect, true));§}§public MercurialPretender(final MercurialPretender card) {§super(card);§}§@Override§public MercurialPretender copy() {§return new MercurialPretender(this);§}§}§
public class Phytotitan extends CardImpl {§public Phytotitan(UUID ownerId) {§super(ownerId, 191, "Phytotitan", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{G}{G}");§this.expansionSetCode = "M15";§this.subtype.add("Plant");§this.subtype.add("Elemental");§this.power = new MageInt(7);§this.toughness = new MageInt(2);§this.addAbility(new DiesTriggeredAbility(new PhytotitanEffect()));§}§public Phytotitan(final Phytotitan card) {§super(card);§}§@Override§public Phytotitan copy() {§return new Phytotitan(this);§}§}§class PhytotitanEffect extends OneShotEffect {§private static final String effectText = "return it to the battlefield tapped under its owner's control at the beginning of his or her next upkeep";§PhytotitanEffect() {§super(Outcome.Benefit);§staticText = effectText;§}§PhytotitanEffect(PhytotitanEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Effect effect = new ReturnSourceFromGraveyardToBattlefieldEffect(true, true);§effect.setText(staticText);§DelayedTriggeredAbility delayedAbility = new AtTheBeginOfYourNextUpkeepDelayedTriggeredAbility(effect);§game.addDelayedTriggeredAbility(delayedAbility, source);§return true;§}§@Override§public PhytotitanEffect copy() {§return new PhytotitanEffect(this);§}§}§
public class SiegeDragon extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Walls your opponents control");§static {§filter.add(new SubtypePredicate("Wall"));§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public SiegeDragon(UUID ownerId) {§super(ownerId, 162, "Siege Dragon", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{R}{R}");§this.expansionSetCode = "M15";§this.subtype.add("Dragon");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new DestroyAllEffect(filter), false));§this.addAbility(new SiegeDragonAttacksTriggeredAbility());§}§public SiegeDragon(final SiegeDragon card) {§super(card);§}§@Override§public SiegeDragon copy() {§return new SiegeDragon(this);§}§}§class SiegeDragonAttacksTriggeredAbility extends TriggeredAbilityImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("wall");§static {§filter.add(new SubtypePredicate("Wall"));§}§public SiegeDragonAttacksTriggeredAbility() {§super(Zone.BATTLEFIELD, new SiegeDragonDamageEffect());§}§public SiegeDragonAttacksTriggeredAbility(final SiegeDragonAttacksTriggeredAbility ability) {§super(ability);§}§@Override§public SiegeDragonAttacksTriggeredAbility copy() {§return new SiegeDragonAttacksTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ATTACKER_DECLARED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§return event.getSourceId().equals(this.getSourceId());§}§@Override§public boolean checkInterveningIfClause(Game game) {§UUID defendingPlayerId = game.getCombat().getDefendingPlayerId(getSourceId(), game);§return defendingPlayerId != null && game.getBattlefield().countAll(filter, defendingPlayerId, game) < 1;§}§@Override§public String getRule() {§return "Whenever {this} attacks, if defending player controls no Walls, it deals 2 damage to each creature without flying that player controls.";§}§}§class SiegeDragonDamageEffect extends OneShotEffect {§public SiegeDragonDamageEffect() {§super(Outcome.Damage);§}§public SiegeDragonDamageEffect(final SiegeDragonDamageEffect effect) {§super(effect);§}§@Override§public SiegeDragonDamageEffect copy() {§return new SiegeDragonDamageEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§UUID defendingPlayerId = game.getCombat().getDefendingPlayerId(source.getSourceId(), game);§if (defendingPlayerId != null) {§FilterCreaturePermanent filter = new FilterCreaturePermanent();§filter.add(new ControllerIdPredicate(defendingPlayerId));§filter.add(Predicates.not(new AbilityPredicate(FlyingAbility.class)));§List<Permanent> permanents = game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game);§for (Permanent permanent : permanents) {§permanent.damage(2, source.getSourceId(), game, false, true);§}§return true;§}§return false;§}§}§
public class UndergrowthScavenger extends CardImpl {§public UndergrowthScavenger(UUID ownerId) {§super(ownerId, 204, "Undergrowth Scavenger", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "M15";§this.subtype.add("Fungus");§this.subtype.add("Horror");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§Effect effect = new AddCountersSourceEffect(CounterType.P1P1.createInstance(0), new CardsInAllGraveyardsCount(new FilterCreatureCard()), true);§effect.setText("with a number of +1/+1 counters on it equal to the number of creature cards in all graveyards");§this.addAbility(new EntersBattlefieldAbility(effect));§}§public UndergrowthScavenger(final UndergrowthScavenger card) {§super(card);§}§@Override§public UndergrowthScavenger copy() {§return new UndergrowthScavenger(this);§}§}§
public class AmprynTactician extends CardImpl {§public AmprynTactician(UUID ownerId) {§super(ownerId, 2, "Ampryn Tactician", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}{W}");§this.expansionSetCode = "ORI";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new EntersBattlefieldTriggeredAbility(new BoostControlledEffect(1, 1, Duration.EndOfTurn)));§}§public AmprynTactician(final AmprynTactician card) {§super(card);§}§@Override§public AmprynTactician copy() {§return new AmprynTactician(this);§}§}§
public class ChandrasIgnition extends CardImpl {§public ChandrasIgnition(UUID ownerId) {§super(ownerId, 137, "Chandra's Ignition", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{R}{R}");§this.expansionSetCode = "ORI";§this.getSpellAbility().addEffect(new ChandrasIgnitionEffect());§this.getSpellAbility().addTarget(new TargetControlledCreaturePermanent());§}§public ChandrasIgnition(final ChandrasIgnition card) {§super(card);§}§@Override§public ChandrasIgnition copy() {§return new ChandrasIgnition(this);§}§}§class ChandrasIgnitionEffect extends OneShotEffect {§public ChandrasIgnitionEffect() {§super(Outcome.Benefit);§this.staticText = "Target creature you control deals damage equal to its power to each other creature and each opponent";§}§public ChandrasIgnitionEffect(final ChandrasIgnitionEffect effect) {§super(effect);§}§@Override§public ChandrasIgnitionEffect copy() {§return new ChandrasIgnitionEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent targetCreature = game.getPermanent(getTargetPointer().getFirst(game, source));§if (targetCreature != null && targetCreature.getPower().getValue() > 0) {§for (Permanent creature : game.getState().getBattlefield().getActivePermanents(new FilterCreaturePermanent(), source.getControllerId(), source.getSourceId(), game)) {§if (!creature.getId().equals(targetCreature.getId())) {§creature.damage(targetCreature.getPower().getValue(), targetCreature.getId(), game, false, true);§}§}§for(UUID opponentId : game.getOpponents(source.getControllerId())) {§Player opponent = game.getPlayer(opponentId);§if (opponent != null) {§opponent.damage(targetCreature.getPower().getValue(), targetCreature.getId(), game, false, true);§}§}§}§return true;§}§}§
public class EmbermawHellion extends CardImpl {§public EmbermawHellion(UUID ownerId) {§super(ownerId, 141, "Embermaw Hellion", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{R}{R}");§this.expansionSetCode = "ORI";§this.subtype.add("Hellion");§this.power = new MageInt(4);§this.toughness = new MageInt(5);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new EmbermawHellionEffect()));§}§public EmbermawHellion(final EmbermawHellion card) {§super(card);§}§@Override§public EmbermawHellion copy() {§return new EmbermawHellion(this);§}§}§class EmbermawHellionEffect extends ReplacementEffectImpl {§EmbermawHellionEffect() {§super(Duration.WhileOnBattlefield, Outcome.Benefit);§staticText = "If another red source you control would deal damage to a permanent or player, it deals that much damage plus 1 to that permanent or player instead.";§}§EmbermawHellionEffect(final EmbermawHellionEffect effect) {§super(effect);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§switch(event.getType()) {§case DAMAGE_CREATURE:§case DAMAGE_PLANESWALKER:§case DAMAGE_PLAYER:§return true;§default:§return false;§}§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if(source.getControllerId().equals(game.getControllerId(event.getSourceId()))) {§MageObject sourceObject;§Permanent sourcePermanent = game.getPermanentOrLKIBattlefield(event.getSourceId());§if(sourcePermanent == null) {§sourceObject = game.getObject(event.getSourceId());§}§else {§sourceObject = sourcePermanent;§}§return sourceObject != null && sourceObject.getColor(game).isRed() && !sourceObject.getId().equals(source.getSourceId());§}§return false;§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§event.setAmount(event.getAmount() + 1);§return false;§}§@Override§public EmbermawHellionEffect copy() {§return new EmbermawHellionEffect(this);§}§}§
public class GiltLeafWinnower extends CardImpl {§private final static FilterCreaturePermanent filter = new FilterCreaturePermanent("non-Elf creature whose power and toughness aren't equal");§static {§filter.add(Predicates.not(new SubtypePredicate("Elf")));§filter.add(new PowerToughnessNotEqualPredicate());§}§public GiltLeafWinnower(UUID ownerId) {§super(ownerId, 99, "Gilt-Leaf Winnower", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{B}{B}");§this.expansionSetCode = "ORI";§this.subtype.add("Elf");§this.subtype.add("Warrior");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§this.addAbility(new MenaceAbility());§Ability ability = new EntersBattlefieldTriggeredAbility(new DestroyTargetEffect(), true);§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public GiltLeafWinnower(final GiltLeafWinnower card) {§super(card);§}§@Override§public GiltLeafWinnower copy() {§return new GiltLeafWinnower(this);§}§}§class PowerToughnessNotEqualPredicate implements Predicate<MageObject> {§@Override§public boolean apply(MageObject input, Game game) {§return input.getPower().getValue() != input.getToughness().getValue();§}§@Override§public String toString() {§return "power and toughness aren't equal";§}§}§
public class IroassChampion extends CardImpl {§public IroassChampion(UUID ownerId) {§super(ownerId, 214, "Iroas's Champion", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{R}{W}");§this.expansionSetCode = "ORI";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(DoubleStrikeAbility.getInstance());§}§public IroassChampion(final IroassChampion card) {§super(card);§}§@Override§public IroassChampion copy() {§return new IroassChampion(this);§}§}§
public class MalakirCullblade extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("a creature an opponent controls");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public MalakirCullblade(UUID ownerId) {§super(ownerId, 108, "Malakir Cullblade", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "ORI";§this.subtype.add("Vampire");§this.subtype.add("Warrior");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new DiesCreatureTriggeredAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance()), false, filter));§}§public MalakirCullblade(final MalakirCullblade card) {§super(card);§}§@Override§public MalakirCullblade copy() {§return new MalakirCullblade(this);§}§}§
public class PrismRing extends CardImpl {§public PrismRing(UUID ownerId) {§super(ownerId, 235, "Prism Ring", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "ORI";§this.addAbility(new EntersBattlefieldAbility(new ChooseColorEffect(Outcome.Neutral)));§this.addAbility(new PrismRingTriggeredAbility());§}§public PrismRing(final PrismRing card) {§super(card);§}§@Override§public PrismRing copy() {§return new PrismRing(this);§}§}§class PrismRingTriggeredAbility extends TriggeredAbilityImpl {§public PrismRingTriggeredAbility() {§super(Zone.BATTLEFIELD, new GainLifeEffect(1), false);§}§public PrismRingTriggeredAbility(final PrismRingTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.SPELL_CAST;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getPlayerId().equals(this.getControllerId())) {§Spell spell = game.getStack().getSpell(event.getTargetId());§ObjectColor color = (ObjectColor) game.getState().getValue(getSourceId() + "_color");§if (spell != null && color != null && spell.getColor(game).shares(color)) {§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever you cast a spell of the chosen color, you gain 1 life.";§}§@Override§public PrismRingTriggeredAbility copy() {§return new PrismRingTriggeredAbility(this);§}§}§
public class SkyrakerGiant extends CardImpl {§public SkyrakerGiant(UUID ownerId) {§super(ownerId, 162, "Skyraker Giant", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "ORI";§this.subtype.add("Giant");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§this.addAbility(ReachAbility.getInstance());§}§public SkyrakerGiant(final SkyrakerGiant card) {§super(card);§}§@Override§public SkyrakerGiant copy() {§return new SkyrakerGiant(this);§}§}§
public class TouchOfMoonglove extends CardImpl {§public TouchOfMoonglove(UUID ownerId) {§super(ownerId, 123, "Touch of Moonglove", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{B}");§this.expansionSetCode = "ORI";§Effect effect = new BoostTargetEffect(1, 0, Duration.EndOfTurn);§effect.setText("Target creature you control gets +1/+0");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(§DeathtouchAbility.getInstance(), Duration.EndOfTurn, "and gains deathtouch until end of turn"));§this.getSpellAbility().addTarget(new TargetControlledCreaturePermanent());§this.getSpellAbility().addEffect(new TouchOfMoongloveAddTriggerEffect());§}§public TouchOfMoonglove(final TouchOfMoonglove card) {§super(card);§}§@Override§public TouchOfMoonglove copy() {§return new TouchOfMoonglove(this);§}§}§class TouchOfMoongloveAddTriggerEffect extends OneShotEffect {§public TouchOfMoongloveAddTriggerEffect() {§super(Outcome.LoseLife);§this.staticText = "Whenever a creature dealt damage by that creature this turn dies, its controller loses 2 life";§}§public TouchOfMoongloveAddTriggerEffect(final TouchOfMoongloveAddTriggerEffect effect) {§super(effect);§}§@Override§public TouchOfMoongloveAddTriggerEffect copy() {§return new TouchOfMoongloveAddTriggerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanentOrLKIBattlefield(getTargetPointer().getFirst(game, source));§if (permanent != null) {§DelayedTriggeredAbility delayedAbility = new TouchOfMoongloveDelayedTriggeredAbility(new MageObjectReference(permanent, game));§game.addDelayedTriggeredAbility(delayedAbility, source);§}§return true;§}§}§class TouchOfMoongloveDelayedTriggeredAbility extends DelayedTriggeredAbility {§private final MageObjectReference creatureToCheck;§public TouchOfMoongloveDelayedTriggeredAbility(MageObjectReference creatureToCheck) {§super(new LoseLifeTargetEffect(2), Duration.EndOfTurn, false);§this.creatureToCheck = creatureToCheck;§}§public TouchOfMoongloveDelayedTriggeredAbility(TouchOfMoongloveDelayedTriggeredAbility ability) {§super(ability);§this.creatureToCheck = ability.creatureToCheck;§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ZONE_CHANGE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§ZoneChangeEvent zEvent = (ZoneChangeEvent) event;§if (zEvent.getFromZone() == Zone.BATTLEFIELD && zEvent.getToZone() == Zone.GRAVEYARD§&& zEvent.getTarget().getCardType().contains(CardType.CREATURE)) {§boolean damageDealt = false;§for (MageObjectReference mor : zEvent.getTarget().getDealtDamageByThisTurn()) {§if (mor.equals(creatureToCheck)) {§damageDealt = true;§break;§}§}§if (damageDealt) {§for (Effect effect : getEffects()) {§effect.setTargetPointer(new FixedTarget(zEvent.getTarget().getControllerId()));§}§return true;§}§}§return false;§}§@Override§public TouchOfMoongloveDelayedTriggeredAbility copy() {§return new TouchOfMoongloveDelayedTriggeredAbility(this);§}§@Override§public String getRule() {§return "Whenever a creature dealt damage by that creature this turn dies, its controller loses 2 life.";§}§}§
public class ApprenticeWizard extends CardImpl {§public ApprenticeWizard(UUID ownerId) {§super(ownerId, 30, "Apprentice Wizard", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{U}{U}");§this.expansionSetCode = "MED";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(0);§this.toughness = new MageInt(1);§Ability ability = new SimpleManaAbility(Zone.BATTLEFIELD, Mana.ColorlessMana(3), new ManaCostsImpl("{U}"));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public ApprenticeWizard(final ApprenticeWizard card) {§super(card);§}§@Override§public ApprenticeWizard copy() {§return new ApprenticeWizard(this);§}§}§
public class StoneCalendar extends CardImpl {§public StoneCalendar(UUID ownerId) {§super(ownerId, 167, "Stone Calendar", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{5}");§this.expansionSetCode = "MED";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new SpellsCostReductionControllerEffect(new FilterCard("spells"), 1, true)));§}§public StoneCalendar(final StoneCalendar card) {§super(card);§}§@Override§public StoneCalendar copy() {§return new StoneCalendar(this);§}§}§
public class FolkOfThePines extends CardImpl {§public FolkOfThePines(UUID ownerId) {§super(ownerId, 162, "Folk of the Pines", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{G}");§this.expansionSetCode = "ME2";§this.subtype.add("Dryad");§this.power = new MageInt(2);§this.toughness = new MageInt(5);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 0, Duration.EndOfTurn), new ManaCostsImpl("{1}{G}")));§}§public FolkOfThePines(final FolkOfThePines card) {§super(card);§}§@Override§public FolkOfThePines copy() {§return new FolkOfThePines(this);§}§}§
public class TheloniteDruid extends CardImpl {§private static final FilterControlledLandPermanent filter = new FilterControlledLandPermanent("Forests you control");§static {§filter.add(new SubtypePredicate("Forest"));§}§public TheloniteDruid(UUID ownerId) {§super(ownerId, 182, "Thelonite Druid", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "ME2";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.subtype.add("Druid");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§ContinuousEffect effect = new BecomesCreatureAllEffect(new TheloniteDruidLandToken(), "Forests", filter, Duration.EndOfTurn);§effect.getDependencyTypes().add(DependencyType.BecomeForest);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§effect,§new ManaCostsImpl("{1}{G}"));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent()));§this.addAbility(ability);§}§public TheloniteDruid(final TheloniteDruid card) {§super(card);§}§@Override§public TheloniteDruid copy() {§return new TheloniteDruid(this);§}§}§class TheloniteDruidLandToken extends Token {§public TheloniteDruidLandToken() {§super("", "2/3 creatures");§cardType.add(CardType.CREATURE);§power = new MageInt(2);§toughness = new MageInt(3);§}§}§
public class ForcedRetreat extends CardImpl {§public ForcedRetreat(UUID ownerId) {§super(ownerId, 37, "Forced Retreat", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{U}");§this.expansionSetCode = "ME3";§this.getSpellAbility().addEffect(new PutOnLibraryTargetEffect(true));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public ForcedRetreat(final ForcedRetreat card) {§super(card);§}§@Override§public ForcedRetreat copy() {§return new ForcedRetreat(this);§}§}§
public class Tracker extends CardImpl {§public Tracker(UUID ownerId) {§super(ownerId, 136, "Tracker", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "ME3";§this.subtype.add("Human");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageEachOtherEffect(), new ManaCostsImpl("{G}{G}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public Tracker(final Tracker card) {§super(card);§}§@Override§public Tracker copy() {§return new Tracker(this);§}§}§
public class HasranOgress extends CardImpl {§public HasranOgress(UUID ownerId) {§super(ownerId, 86, "Hasran Ogress", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{B}{B}");§this.expansionSetCode = "ME4";§this.subtype.add("Ogre");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(new AttacksTriggeredAbility(new HasranOgressEffect(), false));§}§public HasranOgress(final HasranOgress card) {§super(card);§}§@Override§public HasranOgress copy() {§return new HasranOgress(this);§}§}§class HasranOgressEffect extends OneShotEffect {§public HasranOgressEffect() {§super(Outcome.Damage);§this.staticText = "{this} deals 3 damage to you unless you pay {2}";§}§public HasranOgressEffect(final HasranOgressEffect effect) {§super(effect);§}§@Override§public HasranOgressEffect copy() {§return new HasranOgressEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Cost cost = new ManaCostsImpl("{2}");§String message = "Would you like to pay {2} to prevent taking 3 damage from Hasran Ogress?";§if (!(controller.chooseUse(Outcome.Benefit, message, source, game)§&& cost.pay(source, game, source.getSourceId(), controller.getId(), false, null))) {§controller.damage(3, source.getSourceId(), game, false, true);§}§return true;§}§return false;§}§}§
public class AlabasterWall extends CardImpl {§public AlabasterWall(UUID ownerId) {§super(ownerId, 2, "Alabaster Wall", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "MMQ";§this.subtype.add("Wall");§this.power = new MageInt(0);§this.toughness = new MageInt(4);§this.addAbility(DefenderAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PreventDamageToTargetEffect(Duration.EndOfTurn, 1), new TapSourceCost());§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public AlabasterWall(final AlabasterWall card) {§super(card);§}§@Override§public AlabasterWall copy() {§return new AlabasterWall(this);§}§}§
public class CaveIn extends CardImpl {§public CaveIn(UUID ownerId) {§super(ownerId, 180, "Cave-In", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{R}{R}");§this.expansionSetCode = "MMQ";§FilterOwnedCard filter = new FilterOwnedCard("a red card from your hand");§filter.add(new ColorPredicate(ObjectColor.RED));§filter.add(Predicates.not(new CardIdPredicate(this.getId())));§this.addAbility(new AlternativeCostSourceAbility(new ExileFromHandCost(new TargetCardInHand(filter))));§this.getSpellAbility().addEffect(new DamageEverythingEffect(2));§}§public CaveIn(final CaveIn card) {§super(card);§}§@Override§public CaveIn copy() {§return new CaveIn(this);§}§}§
public class DeepwoodGhoul extends CardImpl {§public DeepwoodGhoul(UUID ownerId) {§super(ownerId, 131, "Deepwood Ghoul", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "MMQ";§this.subtype.add("Zombie");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new PayLifeCost(2)));§}§public DeepwoodGhoul(final DeepwoodGhoul card) {§super(card);§}§@Override§public DeepwoodGhoul copy() {§return new DeepwoodGhoul(this);§}§}§
public class HammerMage extends CardImpl {§public HammerMage(UUID ownerId) {§super(ownerId, 193, "Hammer Mage", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "MMQ";§this.subtype.add("Human");§this.subtype.add("Spellshaper");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new HammerMageEffect(), new ManaCostsImpl("{X}{R}"));§ability.addCost(new TapSourceCost());§ability.addCost(new DiscardCardCost());§this.addAbility(ability);§}§public HammerMage(final HammerMage card) {§super(card);§}§@Override§public HammerMage copy() {§return new HammerMage(this);§}§}§class HammerMageEffect extends OneShotEffect {§public HammerMageEffect() {§super(Outcome.DestroyPermanent);§staticText = "Destroy all artifacts with converted mana cost X or less";§}§public HammerMageEffect(final HammerMageEffect effect) {§super(effect);§}§@Override§public HammerMageEffect copy() {§return new HammerMageEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§FilterArtifactPermanent filter = new FilterArtifactPermanent();§filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.LessThan, source.getManaCostsToPay().getX() + 1));§for(Permanent permanent : game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game)) {§permanent.destroy(source.getSourceId(), game, false);§}§return true;§}§}§
public class KyrenSniper extends CardImpl {§public KyrenSniper(UUID ownerId) {§super(ownerId, 199, "Kyren Sniper", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "MMQ";§this.subtype.add("Goblin");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new BeginningOfUpkeepTriggeredAbility(new DamageTargetEffect(1), TargetController.YOU, true);§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public KyrenSniper(final KyrenSniper card) {§super(card);§}§@Override§public KyrenSniper copy() {§return new KyrenSniper(this);§}§}§
public class NoblePurpose extends CardImpl {§public NoblePurpose(UUID ownerId) {§super(ownerId, 32, "Noble Purpose", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{3}{W}{W}");§this.expansionSetCode = "MMQ";§this.addAbility(new NoblePurposeTriggeredAbility());§}§public NoblePurpose(final NoblePurpose card) {§super(card);§}§@Override§public NoblePurpose copy() {§return new NoblePurpose(this);§}§}§class NoblePurposeTriggeredAbility extends TriggeredAbilityImpl {§public NoblePurposeTriggeredAbility() {§super(Zone.BATTLEFIELD, null);§}§public NoblePurposeTriggeredAbility(final NoblePurposeTriggeredAbility ability) {§super(ability);§}§@Override§public NoblePurposeTriggeredAbility copy() {§return new NoblePurposeTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_CREATURE§|| event.getType() == EventType.DAMAGED_PLAYER§|| event.getType() == EventType.DAMAGED_PLANESWALKER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§DamagedEvent damageEvent = (DamagedEvent) event;§if (damageEvent.isCombatDamage()) {§Permanent permanent = game.getPermanent(event.getSourceId());§if (permanent != null && permanent.getCardType().contains(CardType.CREATURE)§&& permanent.getControllerId().equals(this.getControllerId())) {§this.getEffects().clear();§this.getEffects().add(new GainLifeEffect(damageEvent.getAmount()));§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever a creature you control deals combat damage, you gain that much life.";§}§}§
public class RishadanPort extends CardImpl {§public RishadanPort(UUID ownerId) {§super(ownerId, 324, "Rishadan Port", Rarity.RARE, new CardType[]{CardType.LAND}, null);§this.expansionSetCode = "MMQ";§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TapTargetEffect(), new GenericManaCost(1));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetLandPermanent());§this.addAbility(ability);§}§public RishadanPort(final RishadanPort card) {§super(card);§}§@Override§public RishadanPort copy() {§return new RishadanPort(this);§}§}§
public class SnakePit extends CardImpl {§private final static FilterSpell filter = new FilterSpell("a blue or black spell");§static {§filter.add(Predicates.or(new ColorPredicate(ObjectColor.BLUE), new ColorPredicate(ObjectColor.BLACK)));§}§public SnakePit(UUID ownerId) {§super(ownerId, 271, "Snake Pit", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{3}{G}");§this.expansionSetCode = "MMQ";§this.addAbility(new SpellCastOpponentTriggeredAbility(new CreateTokenEffect(new SnakeToken()), filter, true));§}§public SnakePit(final SnakePit card) {§super(card);§}§@Override§public SnakePit copy() {§return new SnakePit(this);§}§}§
public class TigerClaws extends CardImpl {§public TigerClaws(UUID ownerId) {§super(ownerId, 279, "Tiger Claws", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{G}");§this.expansionSetCode = "MMQ";§this.subtype.add("Aura");§this.addAbility(FlashAbility.getInstance());§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§Effect effect = new GainAbilityAttachedEffect(TrampleAbility.getInstance(), AttachmentType.AURA);§effect.setText("and has trample");§ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(1, 1));§ability.addEffect(effect);§this.addAbility(ability);§}§public TigerClaws(final TigerClaws card) {§super(card);§}§@Override§public TigerClaws copy() {§return new TigerClaws(this);§}§}§
public class AzimaetDrake extends CardImpl {§public AzimaetDrake(UUID ownerId) {§super(ownerId, 53, "Azimaet Drake", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "MIR";§this.subtype.add("Drake");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new LimitedTimesPerTurnActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 0, Duration.EndOfTurn), new ManaCostsImpl("{U}")));§}§public AzimaetDrake(final AzimaetDrake card) {§super(card);§}§@Override§public AzimaetDrake copy() {§return new AzimaetDrake(this);§}§}§
public class CryptCobra extends CardImpl {§public CryptCobra(UUID ownerId) {§super(ownerId, 12, "Crypt Cobra", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{B}");§this.expansionSetCode = "MIR";§this.subtype.add("Snake");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§Effect effect = new AddPoisonCounterTargetEffect(1);§effect.setText("defending player gets a poison counter");§this.addAbility(new AttacksAndIsNotBlockedTriggeredAbility(effect, false, true));§}§public CryptCobra(final CryptCobra card) {§super(card);§}§@Override§public CryptCobra copy() {§return new CryptCobra(this);§}§}§
public class FreneticEfreet extends CardImpl {§public FreneticEfreet(UUID ownerId) {§super(ownerId, 324, "Frenetic Efreet", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{U}{R}");§this.expansionSetCode = "MIR";§this.subtype.add("Efreet");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new FreneticEfreetEffect(), new GenericManaCost(0)));§}§public FreneticEfreet(final FreneticEfreet card) {§super(card);§}§@Override§public FreneticEfreet copy() {§return new FreneticEfreet(this);§}§}§class FreneticEfreetEffect extends OneShotEffect {§public FreneticEfreetEffect() {§super(Outcome.Damage);§staticText = "Flip a coin. If you win the flip, {this} phases out. If you lose the flip, sacrifice {this}";§}§public FreneticEfreetEffect(FreneticEfreetEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(source.getSourceId());§Player controller = game.getPlayer(source.getControllerId());§if (controller != null && permanent != null) {§if (controller.flipCoin(game)) {§return permanent.phaseOut(game);§} else {§permanent.sacrifice(source.getSourceId(), game);§return true;§}§}§return false;§}§@Override§public FreneticEfreetEffect copy() {§return new FreneticEfreetEffect(this);§}§}§
public class JunglePatrol extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("a token named Wood");§static {§filter.add(new NamePredicate("Wood"));§filter.add(new TokenPredicate());§}§public JunglePatrol(UUID ownerId) {§super(ownerId, 121, "Jungle Patrol", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "MIR";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CreateTokenEffect(new WoodToken()), new ManaCostsImpl("{1}{G}"));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD,§new BasicManaEffect(Mana.RedMana(1)),§new SacrificeTargetCost(new TargetControlledPermanent(1, 1, filter, true))));§}§public JunglePatrol(final JunglePatrol card) {§super(card);§}§@Override§public JunglePatrol copy() {§return new JunglePatrol(this);§}§}§class WoodToken extends Token {§public WoodToken() {§super("Wood", "0/1 green Wall creature token with defender named Wood");§this.setOriginalExpansionSetCode("MIR");§cardType.add(CardType.CREATURE);§color.setGreen(true);§subtype.add("Wall");§power = new MageInt(0);§toughness = new MageInt(1);§this.addAbility(DefenderAbility.getInstance());§}§}§
public class PainfulMemories extends CardImpl {§public PainfulMemories(UUID ownerId) {§super(ownerId, 31, "Painful Memories", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{1}{B}");§this.expansionSetCode = "MIR";§this.getSpellAbility().addEffect(new PainfulMemoriesEffect());§this.getSpellAbility().addTarget(new TargetOpponent());§}§public PainfulMemories(final PainfulMemories card) {§super(card);§}§@Override§public PainfulMemories copy() {§return new PainfulMemories(this);§}§}§class PainfulMemoriesEffect extends OneShotEffect {§public PainfulMemoriesEffect() {§super(Outcome.Discard);§this.staticText = "Look at target opponent's hand and choose a card from it. Put that card on top of that player's library.";§}§public PainfulMemoriesEffect(final PainfulMemoriesEffect effect) {§super(effect);§}§@Override§public PainfulMemoriesEffect copy() {§return new PainfulMemoriesEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player targetPlayer = game.getPlayer(source.getFirstTarget());§Player you = game.getPlayer(source.getControllerId());§if (targetPlayer != null && you != null) {§targetPlayer.revealCards("Painful Memories", targetPlayer.getHand(), game);§if (targetPlayer.getHand().size() > 0) {§TargetCard target = new TargetCard(Zone.HAND, new FilterCard());§if (you.choose(Outcome.Benefit, targetPlayer.getHand(), target, game)) {§Card card = targetPlayer.getHand().get(target.getFirstTarget(), game);§if (card != null) {§return targetPlayer.moveCardToLibraryWithInfo(card, source.getSourceId(), game, Zone.HAND, true, true);§}§}§}§return true;§}§return false;§}§}§
public class SearingSpearAskari extends CardImpl {§public SearingSpearAskari(UUID ownerId) {§super(ownerId, 191, "Searing Spear Askari", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "MIR";§this.subtype.add("Human");§this.subtype.add("Knight");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new FlankingAbility());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(new MenaceAbility(), Duration.EndOfTurn), new ManaCostsImpl("{1}{R}")));§}§public SearingSpearAskari(final SearingSpearAskari card) {§super(card);§}§@Override§public SearingSpearAskari copy() {§return new SearingSpearAskari(this);§}§}§
public class TelimTorsDarts extends CardImpl {§public TelimTorsDarts(UUID ownerId) {§super(ownerId, 286, "Telim'Tor's Darts", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "MIR";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new GenericManaCost(2));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public TelimTorsDarts(final TelimTorsDarts card) {§super(card);§}§@Override§public TelimTorsDarts copy() {§return new TelimTorsDarts(this);§}§}§
public class ZebraUnicorn extends CardImpl {§public ZebraUnicorn(UUID ownerId) {§super(ownerId, 350, "Zebra Unicorn", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{G}{W}");§this.expansionSetCode = "MIR";§this.subtype.add("Unicorn");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new DealsDamageGainLifeSourceTriggeredAbility());§}§public ZebraUnicorn(final ZebraUnicorn card) {§super(card);§}§@Override§public ZebraUnicorn copy() {§return new ZebraUnicorn(this);§}§}§
public class Bloodscent extends CardImpl {§public Bloodscent(UUID ownerId) {§super(ownerId, 114, "Bloodscent", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{3}{G}");§this.expansionSetCode = "MRD";§this.getSpellAbility().addEffect(new MustBeBlockedByAllTargetEffect(Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public Bloodscent(final Bloodscent card) {§super(card);§}§@java.lang.Override§public Bloodscent copy() {§return new Bloodscent(this);§}§}§
public class DreamsGrip extends CardImpl {§public DreamsGrip(UUID ownerId) {§super(ownerId, 34, "Dream's Grip", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{U}");§this.expansionSetCode = "MRD";§this.getSpellAbility().getModes().setMinModes(1);§this.getSpellAbility().getModes().setMaxModes(1);§TargetPermanent target1 = new TargetPermanent(new FilterPermanent("Permanent to tap"));§Effect tapEffect = new TapTargetEffect();§this.getSpellAbility().addTarget(target1);§this.getSpellAbility().addEffect(tapEffect);§Mode mode = new Mode();§TargetPermanent target2 = new TargetPermanent(new FilterPermanent("Permanent to untap"));§mode.getTargets().add(target2);§Effect untapEffect = new UntapTargetEffect();§mode.getEffects().add(untapEffect);§this.getSpellAbility().addMode(mode);§this.addAbility(new EntwineAbility("{1}"));§}§public DreamsGrip(final DreamsGrip card) {§super(card);§}§@java.lang.Override§public DreamsGrip copy() {§return new DreamsGrip(this);§}§}§
public class GoblinReplica extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("artifact");§static {§filter.add(new CardTypePredicate(CardType.ARTIFACT));§}§public GoblinReplica(UUID ownerId) {§super(ownerId, 178, "Goblin Replica", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{3}");§this.expansionSetCode = "MRD";§this.subtype.add("Goblin");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new ManaCostsImpl("{3}{R}"));§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§}§public GoblinReplica(final GoblinReplica card) {§super(card);§}§@java.lang.Override§public GoblinReplica copy() {§return new GoblinReplica(this);§}§}§
public class KrarkClanShaman extends CardImpl {§private static final FilterControlledPermanent filterSacrificed = new FilterControlledPermanent("an artifact");§private static final FilterCreaturePermanent filterTargetedCreatures = new FilterCreaturePermanent("creature without flying");§static {§filterSacrificed.add(new CardTypePredicate(CardType.ARTIFACT));§filterTargetedCreatures.add(Predicates.not(new AbilityPredicate(FlyingAbility.class)));§}§public KrarkClanShaman(UUID ownerId) {§super(ownerId, 98, "Krark-Clan Shaman", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "MRD";§this.subtype.add("Goblin");§this.subtype.add("Shaman");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageAllEffect(1, filterTargetedCreatures), new SacrificeTargetCost(new TargetControlledPermanent(filterSacrificed))));§}§public KrarkClanShaman(final KrarkClanShaman card) {§super(card);§}§@java.lang.Override§public KrarkClanShaman copy() {§return new KrarkClanShaman(this);§}§}§
public class MesmericOrb extends CardImpl {§public MesmericOrb(UUID ownerId) {§super(ownerId, 204, "Mesmeric Orb", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "MRD";§Effect effect = new PutTopCardOfLibraryIntoGraveTargetEffect(1);§effect.setText("that permanent's controller puts the top card of his or her library into his or her graveyard");§this.addAbility(new BecomesUntappedPermanentTriggeredAbility(effect, false));§}§public MesmericOrb(final MesmericOrb card) {§super(card);§}§@java.lang.Override§public MesmericOrb copy() {§return new MesmericOrb(this);§}§}§class BecomesUntappedPermanentTriggeredAbility extends TriggeredAbilityImpl{§public BecomesUntappedPermanentTriggeredAbility(Effect effect, boolean optional) {§super(Zone.BATTLEFIELD, effect, optional);§}§public BecomesUntappedPermanentTriggeredAbility(final BecomesUntappedPermanentTriggeredAbility ability) {§super(ability);§}§@java.lang.Override§public BecomesUntappedPermanentTriggeredAbility copy() {§return new BecomesUntappedPermanentTriggeredAbility(this);§}§@java.lang.Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.UNTAPPED;§}§@java.lang.Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent permanent = game.getPermanent(event.getTargetId());§if (permanent != null) {§this.getEffects().get(0).setTargetPointer(new FixedTarget(permanent.getControllerId()));§return true;§}§return false;§}§@java.lang.Override§public String getRule() {§return "Whenever a permanent becomes untapped, " + super.getRule();§}§}§
public class OmegaMyr extends CardImpl {§public OmegaMyr(UUID ownerId) {§super(ownerId, 223, "Omega Myr", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{2}");§this.expansionSetCode = "MRD";§this.subtype.add("Myr");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§}§public OmegaMyr(final OmegaMyr card) {§super(card);§}§@java.lang.Override§public OmegaMyr copy() {§return new OmegaMyr(this);§}§}§
public class ScytheOfTheWretched extends CardImpl {§public ScytheOfTheWretched(UUID ownerId) {§super(ownerId, 239, "Scythe of the Wretched", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "MRD";§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(2, 2, Duration.WhileOnBattlefield)));§this.addAbility(new ScytheOfTheWretchedTriggeredAbility());§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(4)));§}§public ScytheOfTheWretched(final ScytheOfTheWretched card) {§super(card);§}§@java.lang.Override§public ScytheOfTheWretched copy() {§return new ScytheOfTheWretched(this);§}§}§class ScytheOfTheWretchedTriggeredAbility extends TriggeredAbilityImpl {§public ScytheOfTheWretchedTriggeredAbility() {§super(Zone.ALL, new ScytheOfTheWretchedReanimateEffect(), false);§}§public ScytheOfTheWretchedTriggeredAbility(final ScytheOfTheWretchedTriggeredAbility ability) {§super(ability);§}§@java.lang.Override§public ScytheOfTheWretchedTriggeredAbility copy() {§return new ScytheOfTheWretchedTriggeredAbility(this);§}§@java.lang.Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.ZONE_CHANGE;§}§@java.lang.Override§public boolean checkTrigger(GameEvent event, Game game) {§ZoneChangeEvent zoneChange = (ZoneChangeEvent) event;§if (zoneChange.isDiesEvent() && zoneChange.getTarget().getCardType().contains(CardType.CREATURE)) {§Permanent equippedCreature = getEquippedCreature(game);§for (MageObjectReference mor : zoneChange.getTarget().getDealtDamageByThisTurn()) {§Permanent permanent = (Permanent) game.getLastKnownInformation(mor.getSourceId(), Zone.BATTLEFIELD);§if ((equippedCreature != null && mor.refersTo(equippedCreature, game))§|| (permanent != null && permanent.getAttachments().contains(getSourceId()))) {§setTarget(new FixedTarget(event.getTargetId()));§return true;§}§}§}§return false;§}§@java.lang.Override§public String getRule() {§return "Whenever a creature dealt damage by equipped creature this turn dies, " + super.getRule();§}§private void setTarget(TargetPointer target) {§for (Effect effect : getEffects()) {§effect.setTargetPointer(target);§}§}§private Permanent getEquippedCreature(Game game) {§Permanent equipment = game.getPermanent(getSourceId());§if (equipment != null && equipment.getAttachedTo() != null) {§return game.getPermanent(equipment.getAttachedTo());§}§return null;§}§}§class ScytheOfTheWretchedReanimateEffect extends OneShotEffect {§public ScytheOfTheWretchedReanimateEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "return that card to the battlefield under your control. Attach {this} to that creature";§}§public ScytheOfTheWretchedReanimateEffect(final ScytheOfTheWretchedReanimateEffect effect) {§super(effect);§}§@java.lang.Override§public boolean apply(Game game, Ability source) {§Card card = game.getCard(getTargetPointer().getFirst(game, source));§Player controller = game.getPlayer(source.getControllerId());§if (card != null && controller != null) {§controller.moveCards(card, Zone.BATTLEFIELD, source, game);§Effect effect = new AttachEffect(Outcome.AddAbility);§effect.setTargetPointer(new FixedTarget(card.getId()));§effect.apply(game, source);§return true;§}§return false;§}§@java.lang.Override§public Effect copy() {§return new ScytheOfTheWretchedReanimateEffect(this);§}§}§
public class SteelWall extends CardImpl {§public SteelWall (UUID ownerId) {§super(ownerId, 248, "Steel Wall", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{1}");§this.expansionSetCode = "MRD";§this.subtype.add("Wall");§this.power = new MageInt(0);§this.toughness = new MageInt(4);§this.addAbility(DefenderAbility.getInstance());§}§public SteelWall (final SteelWall card) {§super(card);§}§@java.lang.Override§public SteelWall copy() {§return new SteelWall(this);§}§}§
public class TowerOfMurmurs extends CardImpl {§public TowerOfMurmurs (UUID ownerId) {§super(ownerId, 268, "Tower of Murmurs", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "MRD";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PutLibraryIntoGraveTargetEffect(8), new GenericManaCost(8));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public TowerOfMurmurs (final TowerOfMurmurs card) {§super(card);§}§@java.lang.Override§public TowerOfMurmurs copy() {§return new TowerOfMurmurs(this);§}§}§
public class YotianSoldier extends CardImpl {§public YotianSoldier(UUID ownerId) {§super(ownerId, 277, "Yotian Soldier", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{3}");§this.expansionSetCode = "MRD";§this.subtype.add("Soldier");§this.power = new MageInt(1);§this.toughness = new MageInt(4);§this.addAbility(VigilanceAbility.getInstance());§}§public YotianSoldier(final YotianSoldier card) {§super(card);§}§@java.lang.Override§public YotianSoldier copy() {§return new YotianSoldier(this);§}§}§
public class CorruptedConscience extends CardImpl {§public CorruptedConscience(UUID ownerId) {§super(ownerId, 22, "Corrupted Conscience", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{3}{U}{U}");§this.expansionSetCode = "MBS";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.GainControl));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ControlEnchantedEffect()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(InfectAbility.getInstance(), AttachmentType.AURA)));§}§public CorruptedConscience(final CorruptedConscience card) {§super(card);§}§@Override§public CorruptedConscience copy() {§return new CorruptedConscience(this);§}§}§
public class GoForTheThroat extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent();§static {§filter.add(Predicates.not(new CardTypePredicate(CardType.ARTIFACT)));§}§public GoForTheThroat(UUID ownerId) {§super(ownerId, 43, "Go for the Throat", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{B}");§this.expansionSetCode = "MBS";§Target target = new TargetCreaturePermanent(filter);§target.setTargetName("nonartifact creature");§this.getSpellAbility().addTarget(target);§this.getSpellAbility().addEffect(new DestroyTargetEffect());§}§public GoForTheThroat(final GoForTheThroat card) {§super(card);§}§@Override§public GoForTheThroat copy() {§return new GoForTheThroat(this);§}§}§
public class LoxodonPartisan extends CardImpl {§public LoxodonPartisan (UUID ownerId) {§super(ownerId, 12, "Loxodon Partisan", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{W}");§this.expansionSetCode = "MBS";§this.subtype.add("Elephant");§this.subtype.add("Soldier");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§this.addAbility(new BattleCryAbility());§}§public LoxodonPartisan (final LoxodonPartisan card) {§super(card);§}§@Override§public LoxodonPartisan copy() {§return new LoxodonPartisan(this);§}§}§
public class OgreResister extends CardImpl {§public OgreResister (UUID ownerId) {§super(ownerId, 72, "Ogre Resister", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "MBS";§this.subtype.add("Ogre");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§}§public OgreResister (final OgreResister card) {§super(card);§}§@Override§public OgreResister copy() {§return new OgreResister(this);§}§}§
public class RallyTheForces extends CardImpl {§public RallyTheForces (UUID ownerId) {§super(ownerId, 73, "Rally the Forces", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{R}");§this.expansionSetCode = "MBS";§Effect effect = new BoostAllEffect(1, 0, Duration.EndOfTurn, new FilterAttackingCreature("Attacking creatures"), false);§effect.setText("Attacking creatures get +1/+0");§this.getSpellAbility().addEffect(effect);§effect = new GainAbilityAllEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn, new FilterAttackingCreature("Attacking creatures"), false);§effect.setText("and gain first strike until end of turn");§this.getSpellAbility().addEffect(effect);§}§public RallyTheForces (final RallyTheForces card) {§super(card);§}§@Override§public RallyTheForces copy() {§return new RallyTheForces(this);§}§}§
public class SpreadTheSickness extends CardImpl {§public SpreadTheSickness (UUID ownerId) {§super(ownerId, 56, "Spread the Sickness", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{4}{B}");§this.expansionSetCode = "MBS";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addEffect(new ProliferateEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public SpreadTheSickness (final SpreadTheSickness card) {§super(card);§}§@Override§public SpreadTheSickness copy() {§return new SpreadTheSickness(this);§}§}§
public class ViridianEmissary extends CardImpl {§public ViridianEmissary (UUID ownerId) {§super(ownerId, 95, "Viridian Emissary", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "MBS";§this.subtype.add("Elf");§this.subtype.add("Scout");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new DiesTriggeredAbility(new SearchLibraryPutInPlayEffect(new TargetCardInLibrary(new FilterBasicLandCard()), true), true));§}§public ViridianEmissary (final ViridianEmissary card) {§super(card);§}§@Override§public ViridianEmissary copy() {§return new ViridianEmissary(this);§}§}§
public class FeudkillersVerdict extends CardImpl {§public FeudkillersVerdict(UUID ownerId) {§super(ownerId, 15, "Feudkiller's Verdict", Rarity.UNCOMMON, new CardType[]{CardType.TRIBAL, CardType.SORCERY}, "{4}{W}{W}");§this.expansionSetCode = "MMA";§this.subtype.add("Giant");§this.getSpellAbility().addEffect(new FeudkillersVerdictEffect());§}§public FeudkillersVerdict(final FeudkillersVerdict card) {§super(card);§}§@Override§public FeudkillersVerdict copy() {§return new FeudkillersVerdict(this);§}§}§class FeudkillersVerdictEffect extends OneShotEffect {§public FeudkillersVerdictEffect() {§super(Outcome.Benefit);§this.staticText = "You gain 10 life. Then if you have more life than an opponent, put a 5/5 white Giant Warrior creature token onto the battlefield";§}§public FeudkillersVerdictEffect(final FeudkillersVerdictEffect effect) {§super(effect);§}§@Override§public FeudkillersVerdictEffect copy() {§return new FeudkillersVerdictEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§controller.gainLife(10, game);§boolean moreLife = false;§for (UUID opponentId :game.getOpponents(source.getControllerId())) {§Player opponent = game.getPlayer(opponentId);§if (opponent != null) {§if (controller.getLife() > opponent.getLife()) {§moreLife = true;§break;§}§}§}§if (moreLife) {§return new CreateTokenEffect(new GiantWarriorToken(), 1).apply(game, source);§}§return true;§}§return false;§}§}§class GiantWarriorToken extends Token {§GiantWarriorToken() {§super("Giant Warrior", "5/5 white Giant Warrior creature token");§cardType.add(CardType.CREATURE);§color.setWhite(true);§subtype.add("Giant");§subtype.add("Warrior");§power = new MageInt(5);§toughness = new MageInt(5);§}§}§
public class RudeAwakening extends CardImpl {§public RudeAwakening(UUID ownerId) {§super(ownerId, 160, "Rude Awakening", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{4}{G}");§this.expansionSetCode = "MMA";§this.getSpellAbility().getModes().setMinModes(1);§this.getSpellAbility().getModes().setMaxModes(1);§this.getSpellAbility().addEffect(new UntapAllLandsControllerEffect());§Mode mode = new Mode();§mode.getEffects().add(new BecomesCreatureAllEffect(new RudeAwakeningToken(), "lands", new FilterControlledLandPermanent("lands you control"), Duration.EndOfTurn));§this.getSpellAbility().getModes().addMode(mode);§this.addAbility(new EntwineAbility("{2}{G}"));§}§public RudeAwakening(final RudeAwakening card) {§super(card);§}§@Override§public RudeAwakening copy() {§return new RudeAwakening(this);§}§}§class RudeAwakeningToken extends Token {§public RudeAwakeningToken() {§super("", "2/2 creature");§cardType.add(CardType.CREATURE);§power = new MageInt(2);§toughness = new MageInt(2);§}§}§
public class Bitterblossom extends CardImpl {§public Bitterblossom(UUID ownerId) {§super(ownerId, 58, "Bitterblossom", Rarity.RARE, new CardType[]{CardType.TRIBAL, CardType.ENCHANTMENT}, "{1}{B}");§this.expansionSetCode = "MOR";§this.subtype.add("Faerie");§Ability ability = new BeginningOfUpkeepTriggeredAbility(new LoseLifeSourceControllerEffect(1), TargetController.YOU, false);§ability.addEffect(new CreateTokenEffect(new FaerieRogueToken(), 1));§this.addAbility(ability);§}§public Bitterblossom(final Bitterblossom card) {§super(card);§}§@Override§public Bitterblossom copy() {§return new Bitterblossom(this);§}§}§
public class ElvishWarrior extends CardImpl {§public ElvishWarrior(UUID ownerId) {§super(ownerId, 120, "Elvish Warrior", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{G}{G}");§this.expansionSetCode = "MOR";§this.subtype.add("Elf");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§}§public ElvishWarrior(final ElvishWarrior card) {§super(card);§}§@Override§public ElvishWarrior copy() {§return new ElvishWarrior(this);§}§}§
public class KinsbaileBorderguard extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent();§static {§filter.add(new SubtypePredicate("Kithkin"));§}§public KinsbaileBorderguard(UUID ownerId) {§super(ownerId, 14, "Kinsbaile Borderguard", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{W}{W}");§this.expansionSetCode = "MOR";§this.subtype.add("Kithkin");§this.subtype.add("Soldier");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new EntersBattlefieldAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance(0),§new PermanentsOnBattlefieldCount(filter), true), "with a +1/+1 counter on it for each other Kithkin you control"));§this.addAbility(new DiesTriggeredAbility(new CreateTokenEffect(new KithkinToken(), new AllCountersCount())));§}§public KinsbaileBorderguard(final KinsbaileBorderguard card) {§super(card);§}§@Override§public KinsbaileBorderguard copy() {§return new KinsbaileBorderguard(this);§}§}§class AllCountersCount implements DynamicValue {§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§Permanent sourcePermanent = game.getPermanentOrLKIBattlefield(sourceAbility.getSourceId());§if(sourcePermanent != null) {§int total = 0;§for(Counter counter : sourcePermanent.getCounters().values()) {§total += counter.getCount();§}§return total;§}§return 0;§}§@Override§public DynamicValue copy() {§return new AllCountersCount();§}§@Override§public String getMessage() {§return "for each counter on it";§}§@Override§public String toString() {§return "1";§}§}§
public class NogginWhack extends CardImpl {§public NogginWhack(UUID ownerId) {§super(ownerId, 70, "Noggin Whack", Rarity.UNCOMMON, new CardType[]{CardType.TRIBAL, CardType.SORCERY}, "{2}{B}{B}");§this.expansionSetCode = "MOR";§this.subtype.add("Rogue");§this.addAbility(new ProwlAbility(this, "{1}{B}"));§this.getSpellAbility().addEffect(new NogginWhackEffect());§this.getSpellAbility().addTarget(new TargetPlayer());§}§public NogginWhack(final NogginWhack card) {§super(card);§}§@Override§public NogginWhack copy() {§return new NogginWhack(this);§}§}§class NogginWhackEffect extends OneShotEffect {§public NogginWhackEffect() {§super(Outcome.Benefit);§this.staticText = "Target player reveals three cards from his or her hand. You choose two of them. That player discards those cards";§}§public NogginWhackEffect(final NogginWhackEffect effect) {§super(effect);§}§@Override§public NogginWhackEffect copy() {§return new NogginWhackEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Player targetPlayer = game.getPlayer(source.getFirstTarget());§Card sourceCard = game.getCard(source.getSourceId());§if (controller != null && targetPlayer != null && sourceCard != null) {§Cards cardsInHand = new CardsImpl();§cardsInHand.addAll(targetPlayer.getHand());§int count = Math.min(cardsInHand.size(), 3);§TargetCard target = new TargetCard(count, Zone.HAND, new FilterCard());§Cards revealedCards = new CardsImpl();§if (targetPlayer.chooseTarget(Outcome.Discard, cardsInHand, target, source, game)) {§List<UUID> targets = target.getTargets();§for (UUID targetId : targets) {§Card card = game.getCard(targetId);§if (card != null) {§revealedCards.add(card);§}§}§}§int cardsToDiscard = Math.min(revealedCards.size(), 2);§TargetCard targetInHand = new TargetCard(cardsToDiscard, cardsToDiscard, Zone.HAND, new FilterCard("card to discard"));§if (!revealedCards.isEmpty()) {§targetPlayer.revealCards("Noggin Whack", revealedCards, game);§controller.chooseTarget(Outcome.Exile, revealedCards, targetInHand, source, game);§for (UUID cardId : (List<UUID>) targetInHand.getTargets()) {§Card card = game.getCard(cardId);§if (card != null) {§controller.discard(card, source, game);§}§}§}§return true;§}§return false;§}§}§
public class SageOfFables extends CardImpl {§public SageOfFables(UUID ownerId) {§super(ownerId, 47, "Sage of Fables", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "MOR";§this.subtype.add("Merfolk");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new SageOfFablesReplacementEffect()));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1), new GenericManaCost(2));§ability.addCost(new RemoveCounterCost(new TargetControlledCreaturePermanent(), CounterType.P1P1));§this.addAbility(ability);§}§public SageOfFables(final SageOfFables card) {§super(card);§}§@Override§public SageOfFables copy() {§return new SageOfFables(this);§}§}§class SageOfFablesReplacementEffect extends ReplacementEffectImpl {§SageOfFablesReplacementEffect() {§super(Duration.WhileOnBattlefield, Outcome.BoostCreature);§staticText = "Each other Wizard creature you control enters the battlefield with an additional +1/+1 counter on it";§}§SageOfFablesReplacementEffect(SageOfFablesReplacementEffect effect) {§super(effect);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.ENTERS_THE_BATTLEFIELD;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§Permanent creature = ((EntersTheBattlefieldEvent) event).getTarget();§return creature != null && creature.getControllerId().equals(source.getControllerId())§&& creature.getCardType().contains(CardType.CREATURE)§&& creature.getSubtype().contains("Wizard")§&& !event.getTargetId().equals(source.getSourceId());§}§@Override§public boolean apply(Game game, Ability source) {§return false;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§Permanent creature = ((EntersTheBattlefieldEvent) event).getTarget();§if (creature != null) {§creature.addCounters(CounterType.P1P1.createInstance(), game);§}§return false;§}§@Override§public SageOfFablesReplacementEffect copy() {§return new SageOfFablesReplacementEffect(this);§}§}§
public class ThornbiteStaff extends CardImpl {§private static final FilterPermanent filter = new FilterCreaturePermanent("a Shaman creature");§static {§filter.add(new SubtypePredicate("Shaman"));§}§public ThornbiteStaff(UUID ownerId) {§super(ownerId, 145, "Thornbite Staff", Rarity.UNCOMMON, new CardType[]{CardType.TRIBAL, CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "MOR";§this.subtype.add("Shaman");§this.subtype.add("Equipment");§Ability gainedAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new GenericManaCost(2));§gainedAbility.addCost(new TapSourceCost());§gainedAbility.addTarget(new TargetCreatureOrPlayer());§Effect effect = new GainAbilityAttachedEffect(gainedAbility, AttachmentType.EQUIPMENT);§effect.setText("Equipped creature has \"{2}, {T}: This creature deals 1 damage to target creature or player\"");§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, effect);§effect = new GainAbilityAttachedEffect(new DiesCreatureTriggeredAbility(new UntapSourceEffect(),false), AttachmentType.EQUIPMENT);§effect.setText("and \"Whenever a creature dies, untap this creature.\"");§ability.addEffect(effect);§this.addAbility(ability);§this.addAbility(new EntersBattlefieldAllTriggeredAbility(§Zone.BATTLEFIELD, new AttachEffect(Outcome.Detriment, "attach {source} to it"),§filter, true, SetTargetPointer.PERMANENT, null));§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(4)));§}§public ThornbiteStaff(final ThornbiteStaff card) {§super(card);§}§@Override§public ThornbiteStaff copy() {§return new ThornbiteStaff(this);§}§}§
public class BattlefieldPercher extends CardImpl {§public BattlefieldPercher(UUID ownerId) {§super(ownerId, 52, "Battlefield Percher", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{B}{B}");§this.expansionSetCode = "NMS";§this.subtype.add("Bird");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new CanBlockOnlyFlyingAbility());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 1, Duration.EndOfTurn),§new ManaCostsImpl("{1}{B}")));§}§public BattlefieldPercher(final BattlefieldPercher card) {§super(card);§}§@Override§public BattlefieldPercher copy() {§return new BattlefieldPercher(this);§}§}§
public class KorHaven extends CardImpl {§public KorHaven(UUID ownerId) {§super(ownerId, 141, "Kor Haven", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "NMS";§this.supertype.add("Legendary");§this.addAbility(new ColorlessManaAbility());§Effect effect = new PreventDamageByTargetEffect(Duration.EndOfTurn, true);§effect.setText("Prevent all combat damage that would be dealt by target attacking creature this turn");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl<>("{1}{W}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetAttackingCreature());§this.addAbility(ability);§}§public KorHaven(final KorHaven card) {§super(card);§}§@Override§public KorHaven copy() {§return new KorHaven(this);§}§}§
public class RathiAssassin extends CardImpl {§private static final FilterPermanentCard filter = new FilterPermanentCard("Mercenary permanent card with converted mana cost 3 or less");§private static final FilterCreaturePermanent destroyFilter = new FilterCreaturePermanent("tapped nonblack creature");§static {§filter.add(new SubtypePredicate("Mercenary"));§filter.add(new ConvertedManaCostPredicate(ComparisonType.LessThan, 4));§destroyFilter.add(new TappedPredicate());§destroyFilter.add(Predicates.not(new ColorPredicate(ObjectColor.BLACK)));§}§public RathiAssassin(UUID ownerId) {§super(ownerId, 67, "Rathi Assassin", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{B}{B}");§this.expansionSetCode = "NMS";§this.subtype.add("Zombie");§this.subtype.add("Mercenary");§this.subtype.add("Assassin");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability destroyAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new ManaCostsImpl("{1}{B}{B}"));§destroyAbility.addCost(new TapSourceCost());§destroyAbility.addTarget(new TargetCreaturePermanent(destroyFilter));§this.addAbility(destroyAbility);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new SearchLibraryPutInPlayEffect(new TargetCardInLibrary(filter)), new TapSourceCost());§ability.addManaCost(new GenericManaCost(3));§this.addAbility(ability);§}§public RathiAssassin(final RathiAssassin card) {§super(card);§}§@Override§public RathiAssassin copy() {§return new RathiAssassin(this);§}§}§
public class SkyshroudBehemoth extends CardImpl {§public SkyshroudBehemoth(UUID ownerId) {§super(ownerId, 116, "Skyshroud Behemoth", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{G}{G}");§this.expansionSetCode = "NMS";§this.subtype.add("Beast");§this.power = new MageInt(10);§this.toughness = new MageInt(10);§this.addAbility(new FadingAbility(2, this));§this.addAbility(new EntersBattlefieldTappedAbility());§}§public SkyshroudBehemoth(final SkyshroudBehemoth card) {§super(card);§}§@Override§public SkyshroudBehemoth copy() {§return new SkyshroudBehemoth(this);§}§}§
public class ApostlesBlessing extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("artifact or creature you control");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.ARTIFACT),§new CardTypePredicate(CardType.CREATURE)));§}§public ApostlesBlessing(UUID ownerId) {§super(ownerId, 2, "Apostle's Blessing", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{WP}");§this.expansionSetCode = "NPH";§this.getSpellAbility().addEffect(new ApostlesBlessingEffect());§this.getSpellAbility().addTarget(new TargetControlledPermanent(filter));§}§public ApostlesBlessing(final ApostlesBlessing card) {§super(card);§}§@Override§public ApostlesBlessing copy() {§return new ApostlesBlessing(this);§}§}§class ApostlesBlessingEffect extends OneShotEffect {§public ApostlesBlessingEffect() {§super(Outcome.AddAbility);§this.staticText = "Target artifact or creature you control gains protection from artifacts or from the color of your choice until end of turn";§}§public ApostlesBlessingEffect(final ApostlesBlessingEffect effect) {§super(effect);§}§@Override§public ApostlesBlessingEffect copy() {§return new ApostlesBlessingEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§ChoiceColorOrArtifact choice = new ChoiceColorOrArtifact();§while (!choice.isChosen()) {§if (!controller.canRespond()) {§return false;§}§controller.choose(outcome, choice, game);§}§FilterCard protectionFilter = new FilterCard();§if (choice.isArtifactSelected()) {§protectionFilter.add(new CardTypePredicate(CardType.ARTIFACT));§} else {§protectionFilter.add(new ColorPredicate(choice.getColor()));§}§protectionFilter.setMessage(choice.getChoice());§ProtectionAbility protectionAbility = new ProtectionAbility(protectionFilter);§ContinuousEffect effect = new GainAbilityTargetEffect(protectionAbility, Duration.EndOfTurn);§effect.setTargetPointer(getTargetPointer());§game.addEffect(effect, source);§return true;§}§return false;§}§}§
public class ChancellorOfTheForge extends CardImpl {§private static String abilityText = "at the beginning of the first upkeep, put a 1/1 red Goblin creature token with haste onto the battlefield";§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creatures you control");§static {§filter.add(new ControllerPredicate(TargetController.YOU));§}§public ChancellorOfTheForge(UUID ownerId) {§super(ownerId, 81, "Chancellor of the Forge", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{R}{R}{R}");§this.expansionSetCode = "NPH";§this.subtype.add("Giant");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(new ChancellorAbility(new ChancellorOfTheForgeDelayedTriggeredAbility(), abilityText));§DynamicValue value = new PermanentsOnBattlefieldCount(filter);§this.addAbility(new EntersBattlefieldTriggeredAbility(new CreateTokenEffect(new GoblinTokenWithHaste(), value), false));§}§public ChancellorOfTheForge(final ChancellorOfTheForge card) {§super(card);§}§@Override§public ChancellorOfTheForge copy() {§return new ChancellorOfTheForge(this);§}§}§class ChancellorOfTheForgeDelayedTriggeredAbility extends DelayedTriggeredAbility {§ChancellorOfTheForgeDelayedTriggeredAbility () {§super(new CreateTokenEffect(new GoblinTokenWithHaste()));§}§ChancellorOfTheForgeDelayedTriggeredAbility(ChancellorOfTheForgeDelayedTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.UPKEEP_STEP_PRE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§return true;§}§@Override§public ChancellorOfTheForgeDelayedTriggeredAbility copy() {§return new ChancellorOfTheForgeDelayedTriggeredAbility(this);§}§}§
public class ExclusionRitual extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("nonland permanent");§static {§filter.add(Predicates.not(new CardTypePredicate(CardType.LAND)));§}§public ExclusionRitual(UUID ownerId) {§super(ownerId, 10, "Exclusion Ritual", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{4}{W}{W}");§this.expansionSetCode = "NPH";§Ability ability = new EntersBattlefieldTriggeredAbility(new ExclusionRitualImprintEffect(), false);§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ExclusionRitualReplacementEffect()));§}§public ExclusionRitual(final ExclusionRitual card) {§super(card);§}§@Override§public ExclusionRitual copy() {§return new ExclusionRitual(this);§}§}§class ExclusionRitualImprintEffect extends OneShotEffect {§ExclusionRitualImprintEffect() {§super(Outcome.Exile);§staticText = "exile target nonland permanent";§}§ExclusionRitualImprintEffect(final ExclusionRitualImprintEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent sourcePermanent = game.getPermanent(source.getSourceId());§Permanent targetPermanent = game.getPermanent(targetPointer.getFirst(game, source));§Player controller = game.getPlayer(source.getControllerId());§if (controller != null && sourcePermanent != null && targetPermanent != null) {§controller.moveCardToExileWithInfo(targetPermanent, getId(), sourcePermanent.getIdName(), source.getSourceId(), game, Zone.BATTLEFIELD, true);§sourcePermanent.imprint(targetPermanent.getId(), game);§}§return true;§}§@Override§public ExclusionRitualImprintEffect copy() {§return new ExclusionRitualImprintEffect(this);§}§}§class ExclusionRitualReplacementEffect extends ContinuousRuleModifyingEffectImpl {§ExclusionRitualReplacementEffect() {§super(Duration.WhileOnBattlefield, Outcome.Detriment);§staticText = "Players can't cast spells with the same name as the exiled card";§}§ExclusionRitualReplacementEffect(final ExclusionRitualReplacementEffect effect) {§super(effect);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.CAST_SPELL;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§Permanent sourcePermanent = game.getPermanent(source.getSourceId());§Card card = game.getCard(event.getSourceId());§if (sourcePermanent != null && card != null) {§if (sourcePermanent.getImprinted().size() > 0) {§Card imprintedCard = game.getCard(sourcePermanent.getImprinted().get(0));§if (imprintedCard != null) {§return card.getName().equals(imprintedCard.getName());§}§}§}§return false;§}§@Override§public boolean apply(Game game, Ability source) {§return false;§}§@Override§public ExclusionRitualReplacementEffect copy() {§return new ExclusionRitualReplacementEffect(this);§}§}§
public class ImpalerShrike extends CardImpl {§public ImpalerShrike(UUID ownerId) {§super(ownerId, 36, "Impaler Shrike", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{U}{U}");§this.expansionSetCode = "NPH";§this.subtype.add("Bird");§this.power = new MageInt(3);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new DealsCombatDamageToAPlayerTriggeredAbility(new SacrificeSourceEffect(), true);§ability.addEffect(new DrawCardSourceControllerEffect(3));§this.addAbility(ability);§}§public ImpalerShrike(final ImpalerShrike card) {§super(card);§}§@Override§public ImpalerShrike copy() {§return new ImpalerShrike(this);§}§}§
public class Mindculling extends CardImpl {§public Mindculling(UUID ownerId) {§super(ownerId, 39, "Mindculling", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{5}{U}");§this.expansionSetCode = "NPH";§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(2));§this.getSpellAbility().addTarget(new TargetOpponent());§this.getSpellAbility().addEffect(new DiscardTargetEffect(2));§}§public Mindculling(final Mindculling card) {§super(card);§}§@Override§public Mindculling copy() {§return new Mindculling(this);§}§}§
public class PhyrexianUnlife extends CardImpl {§public PhyrexianUnlife(UUID ownerId) {§super(ownerId, 18, "Phyrexian Unlife", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{2}{W}");§this.expansionSetCode = "NPH";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new DontLoseByZeroOrLessLifeEffect(Duration.WhileOnBattlefield)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new PhyrexianUnlifeEffect2()));§}§public PhyrexianUnlife(final PhyrexianUnlife card) {§super(card);§}§@Override§public PhyrexianUnlife copy() {§return new PhyrexianUnlife(this);§}§}§class PhyrexianUnlifeEffect2 extends ReplacementEffectImpl {§int lastCheckedDamageStepNum = 0;§boolean startedWithLifeAboveZero = false;§public PhyrexianUnlifeEffect2() {§super(Duration.WhileOnBattlefield, Outcome.Benefit);§staticText = "As long as you have 0 or less life, all damage is dealt to you as though its source had infect";§}§public PhyrexianUnlifeEffect2(final PhyrexianUnlifeEffect2 effect) {§super(effect);§this.lastCheckedDamageStepNum = effect.lastCheckedDamageStepNum;§this.startedWithLifeAboveZero = effect.startedWithLifeAboveZero;§}§@Override§public PhyrexianUnlifeEffect2 copy() {§return new PhyrexianUnlifeEffect2(this);§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§DamagePlayerEvent damageEvent = (DamagePlayerEvent) event;§int actualDamage = damageEvent.getAmount();§if (actualDamage > 0) {§Player player = game.getPlayer(damageEvent.getPlayerId());§Permanent damageSource = game.getPermanent(damageEvent.getSourceId());§player.addCounters(CounterType.POISON.createInstance(actualDamage), game);§if (damageSource != null && damageSource.getAbilities().containsKey(LifelinkAbility.getInstance().getId())) {§Player controlPlayer = game.getPlayer(damageSource.getControllerId());§controlPlayer.gainLife(actualDamage, game);§}§game.fireEvent(new DamagedPlayerEvent(damageEvent.getPlayerId(), damageEvent.getSourceId(), damageEvent.getPlayerId(), actualDamage, damageEvent.isCombatDamage()));§}§return true;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGE_PLAYER;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (event.getPlayerId().equals(source.getControllerId())) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§if (((DamagePlayerEvent) event).isCombatDamage()) {§if (lastCheckedDamageStepNum != game.getState().getStepNum()) {§lastCheckedDamageStepNum = game.getState().getStepNum();§startedWithLifeAboveZero = player.getLife() > 0;§}§if (startedWithLifeAboveZero) {§return false;§}§}§if (player.getLife() <= 0) {§return true;§}§}§}§return false;§}§}§
public class SheoldredWhisperingOne extends CardImpl {§public SheoldredWhisperingOne (UUID ownerId) {§super(ownerId, 73, "Sheoldred, Whispering One", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{5}{B}{B}");§this.expansionSetCode = "NPH";§this.supertype.add("Legendary");§this.subtype.add("Praetor");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(new SwampwalkAbility());§Ability ability = new BeginningOfUpkeepTriggeredAbility(new ReturnFromGraveyardToBattlefieldTargetEffect(false), TargetController.YOU, false);§ability.addTarget(new TargetCardInYourGraveyard(new FilterCreatureCard("creature card from your graveyard")));§this.addAbility(ability);§ability = new BeginningOfUpkeepTriggeredAbility(new SacrificeEffect(new FilterCreaturePermanent(), 1, "that player "), TargetController.OPPONENT, false);§this.addAbility(ability);§}§public SheoldredWhisperingOne (final SheoldredWhisperingOne card) {§super(card);§}§@Override§public SheoldredWhisperingOne copy() {§return new SheoldredWhisperingOne(this);§}§}§
public class ThunderingTanadon extends CardImpl {§public ThunderingTanadon(UUID ownerId) {§super(ownerId, 122, "Thundering Tanadon", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{4}{GP}{GP}");§this.expansionSetCode = "NPH";§this.subtype.add("Beast");§this.power = new MageInt(5);§this.toughness = new MageInt(4);§this.addAbility(TrampleAbility.getInstance());§}§public ThunderingTanadon(final ThunderingTanadon card) {§super(card);§}§@Override§public ThunderingTanadon copy() {§return new ThunderingTanadon(this);§}§}§
public class WhisperingSpecter extends CardImpl {§public WhisperingSpecter(UUID ownerId) {§super(ownerId, 77, "Whispering Specter", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{B}{B}");§this.expansionSetCode = "NPH";§this.subtype.add("Specter");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(InfectAbility.getInstance());§Ability ability = new DealsCombatDamageToAPlayerTriggeredAbility(new SacrificeSourceEffect(), true, true);§ability.addEffect(new WhisperingSpecterEffect());§this.addAbility(ability);§}§public WhisperingSpecter(final WhisperingSpecter card) {§super(card);§}§@Override§public WhisperingSpecter copy() {§return new WhisperingSpecter(this);§}§}§class WhisperingSpecterEffect extends OneShotEffect {§WhisperingSpecterEffect() {§super(Outcome.Discard);§staticText = "If you do, that player discards a card for each poison counter he or she has";§}§WhisperingSpecterEffect(final WhisperingSpecterEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(targetPointer.getFirst(game, source));§if (player != null) {§int value = player.getCounters().getCount(CounterType.POISON);§if (value > 0) {§player.discard(value, source, game);§return true;§}§}§return false;§}§@Override§public WhisperingSpecterEffect copy() {§return new WhisperingSpecterEffect(this);§}§}§
public class DaringApprentice extends CardImpl {§public DaringApprentice(UUID ownerId) {§super(ownerId, 72, "Daring Apprentice", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{U}{U}");§this.expansionSetCode = "9ED";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CounterTargetEffect(), new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetSpell());§this.addAbility(ability);§}§public DaringApprentice(final DaringApprentice card) {§super(card);§}§@Override§public DaringApprentice copy() {§return new DaringApprentice(this);§}§}§
public class Groundskeeper extends CardImpl {§public Groundskeeper(UUID ownerId) {§super(ownerId, 247, "Groundskeeper", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "9ED";§this.subtype.add("Human");§this.subtype.add("Druid");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ReturnToHandTargetEffect(), new ManaCostsImpl("{1}{G}"));§ability.addTarget(new TargetCardInYourGraveyard(new FilterBasicLandCard("basic land card from your graveyard")));§this.addAbility(ability);§}§public Groundskeeper(final Groundskeeper card) {§super(card);§}§@Override§public Groundskeeper copy() {§return new Groundskeeper(this);§}§}§
public class RathiDragon extends CardImpl {§private static final FilterControlledLandPermanent filter = new FilterControlledLandPermanent("two Mountains");§static{§filter.add(new SubtypePredicate("Mountain"));§}§public RathiDragon(UUID ownerId) {§super(ownerId, 210, "Rathi Dragon", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "9ED";§this.subtype.add("Dragon");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(§new SacrificeSourceUnlessPaysEffect(new SacrificeTargetCost(new TargetControlledPermanent(2, 2, filter, true)))));§}§public RathiDragon(final RathiDragon card) {§super(card);§}§@Override§public RathiDragon copy() {§return new RathiDragon(this);§}§}§
public class TidalKraken extends CardImpl {§public TidalKraken(UUID ownerId) {§super(ownerId, 105, "Tidal Kraken", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{U}{U}{U}");§this.expansionSetCode = "9ED";§this.subtype.add("Kraken");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(new CantBeBlockedSourceAbility());§}§public TidalKraken(final TidalKraken card) {§super(card);§}§@Override§public TidalKraken copy() {§return new TidalKraken(this);§}§}§
public class BearerOfSilence extends CardImpl {§public BearerOfSilence(UUID ownerId) {§super(ownerId, 67, "Bearer of Silence", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "OGW";§this.subtype.add("Eldrazi");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new DevoidAbility(this.color));§Ability ability = new CastSourceTriggeredAbility(new DoIfCostPaid(new SacrificeEffect(new FilterCreaturePermanent(), 1, "Target opponent"), new ManaCostsImpl("{1}{C}")));§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new CantBlockAbility());§}§public BearerOfSilence(final BearerOfSilence card) {§super(card);§}§@Override§public BearerOfSilence copy() {§return new BearerOfSilence(this);§}§}§
public class CrushOfTentacles extends CardImpl {§public CrushOfTentacles(UUID ownerId) {§super(ownerId, 53, "Crush of Tentacles", Rarity.MYTHIC, new CardType[]{CardType.SORCERY}, "{4}{U}{U}");§this.expansionSetCode = "OGW";§getSpellAbility().addEffect(new ReturnToHandFromBattlefieldAllEffect(new FilterNonlandPermanent("nonland permanents")));§Effect effect = new ConditionalOneShotEffect(new CreateTokenEffect(new CrushOfTentaclesToken()), SurgedCondition.getInstance());§effect.setText("If {this} surge cost was paid, put an 8/8 blue Octopus creature token onto the battlefield");§getSpellAbility().addEffect(effect);§addAbility(new SurgeAbility(this, "{3}{U}{U}"));§}§public CrushOfTentacles(final CrushOfTentacles card) {§super(card);§}§@Override§public CrushOfTentacles copy() {§return new CrushOfTentacles(this);§}§}§class CrushOfTentaclesToken extends Token {§public CrushOfTentaclesToken() {§super("Octopus", "8/8 blue Octopus creature");§this.setExpansionSetCodeForImage("BFZ");§this.cardType.add(CardType.CREATURE);§this.color.setBlue(true);§this.subtype.add("Octopus");§this.power = new MageInt(8);§this.toughness = new MageInt(8);§}§}§
public class ExpeditionRaptor extends CardImpl {§public ExpeditionRaptor(UUID ownerId) {§super(ownerId, 18, "Expedition Raptor", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{W}{W}");§this.expansionSetCode = "OGW";§this.subtype.add("Bird");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SupportAbility(this, 2));§}§public ExpeditionRaptor(final ExpeditionRaptor card) {§super(card);§}§@Override§public ExpeditionRaptor copy() {§return new ExpeditionRaptor(this);§}§}§
public class IonasBlessing extends CardImpl {§public IonasBlessing(UUID ownerId) {§super(ownerId, 21, "Iona's Blessing", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{3}{W}");§this.expansionSetCode = "OGW";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(2, 2, Duration.WhileOnBattlefield));§Effect effect = new GainAbilityAttachedEffect(VigilanceAbility.getInstance(), AttachmentType.AURA);§effect.setText(", has vigilance");§ability.addEffect(effect);§ability.addEffect(new IonasBlessingEffect());§this.addAbility(ability);§}§public IonasBlessing(final IonasBlessing card) {§super(card);§}§@Override§public IonasBlessing copy() {§return new IonasBlessing(this);§}§}§class IonasBlessingEffect extends ContinuousEffectImpl {§public IonasBlessingEffect() {§super(Duration.WhileOnBattlefield, Outcome.Benefit);§staticText = ", and can block an additional creature";§}§public IonasBlessingEffect(final IonasBlessingEffect effect) {§super(effect);§}§@Override§public IonasBlessingEffect copy() {§return new IonasBlessingEffect(this);§}§@Override§public boolean apply(Layer layer, SubLayer sublayer, Ability source, Game game) {§Permanent perm = game.getPermanent(source.getSourceId());§if (perm != null && perm.getAttachedTo() != null) {§Permanent enchanted = game.getPermanent(perm.getAttachedTo());§if (enchanted != null) {§switch (layer) {§case RulesEffects:§if (enchanted.getMaxBlocks() > 0) {§enchanted.setMaxBlocks(enchanted.getMaxBlocks() + 1);§}§break;§}§return true;§}§}§return false;§}§@Override§public boolean apply(Game game, Ability source) {§return false;§}§@Override§public boolean hasLayer(Layer layer) {§return layer == Layer.RulesEffects;§}§}§
public class MatterReshaper extends CardImpl {§public MatterReshaper(UUID ownerId) {§super(ownerId, 6, "Matter Reshaper", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{C}");§this.expansionSetCode = "OGW";§this.subtype.add("Eldrazi");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(new DiesTriggeredAbility(new MatterReshaperEffect(), false));§}§public MatterReshaper(final MatterReshaper card) {§super(card);§}§@Override§public MatterReshaper copy() {§return new MatterReshaper(this);§}§}§class MatterReshaperEffect extends OneShotEffect {§public MatterReshaperEffect() {§super(Outcome.Benefit);§staticText = "reveal the top card of your library. You may put that card onto the battlefield if it's a permanent card"§+ " with converted mana cost 3 or less. Otherwise, put that card into your hand";§}§public MatterReshaperEffect(final MatterReshaperEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = game.getObject(source.getSourceId());§if (controller != null && sourceObject != null && controller.getLibrary().size() > 0) {§Card card = controller.getLibrary().getFromTop(game);§if (card == null) {§return false;§}§controller.revealCards(sourceObject.getIdName(), new CardsImpl(card), game);§FilterPermanentCard filter = new FilterPermanentCard("permanent card with converted mana cost 3 or less");§filter.add(new ConvertedManaCostPredicate(ComparisonType.LessThan, 4));§if (filter.match(card, game)) {§if (controller.chooseUse(Outcome.PutCardInPlay, "Put " + card.getName() + " onto the battlefield (otherwise put in hand)?", source, game)) {§card.putOntoBattlefield(game, Zone.LIBRARY, source.getSourceId(), source.getControllerId(), false);§return true;§}§}§card.moveToZone(Zone.HAND, source.getSourceId(), game, false);§return true;§}§return false;§}§@Override§public MatterReshaperEffect copy() {§return new MatterReshaperEffect(this);§}§}§
public class ProphetOfDistortion extends CardImpl {§public ProphetOfDistortion(UUID ownerId) {§super(ownerId, 46, "Prophet of Distortion", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{U}");§this.expansionSetCode = "OGW";§this.subtype.add("Eldrazi");§this.subtype.add("Drone");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(new DevoidAbility(this.color));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1), new ManaCostsImpl("{3}{C}")));§}§public ProphetOfDistortion(final ProphetOfDistortion card) {§super(card);§}§@Override§public ProphetOfDistortion copy() {§return new ProphetOfDistortion(this);§}§}§
public class ShoulderToShoulder extends CardImpl {§public ShoulderToShoulder(UUID ownerId) {§super(ownerId, 34, "Shoulder to Shoulder", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{W}");§this.expansionSetCode = "OGW";§getSpellAbility().addEffect(new SupportEffect(this, 2, false));§getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));§}§public ShoulderToShoulder(final ShoulderToShoulder card) {§super(card);§}§@Override§public ShoulderToShoulder copy() {§return new ShoulderToShoulder(this);§}§}§
public class TearsOfValakut extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature with flying");§static {§filter.add(new AbilityPredicate(FlyingAbility.class));§}§public TearsOfValakut(UUID ownerId) {§super(ownerId, 118, "Tears of Valakut", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{R}");§this.expansionSetCode = "OGW";§Effect effect = new CantBeCounteredSourceEffect();§effect.setText("{this} can't be countered by spells or abilities");§Ability ability = new SimpleStaticAbility(Zone.STACK, effect);§ability.setRuleAtTheTop(true);§this.addAbility(ability);§this.getSpellAbility().addEffect(new DamageTargetEffect(5));§this.getSpellAbility().addTarget(new TargetCreaturePermanent(filter));§}§public TearsOfValakut(final TearsOfValakut card) {§super(card);§}§@Override§public TearsOfValakut copy() {§return new TearsOfValakut(this);§}§}§
public class WarpingWail extends CardImpl {§private static final FilterCreaturePermanent filterCreature = new FilterCreaturePermanent("creature with power or toughness 1 or less");§private static final FilterSpell filterSorcery = new FilterSpell("sorcery spell");§static {§filterCreature.add(Predicates.or(§new PowerPredicate(Filter.ComparisonType.LessThan, 2),§new ToughnessPredicate(ComparisonType.LessThan, 2)));§filterSorcery.add(new CardTypePredicate(CardType.SORCERY));§}§public WarpingWail(UUID ownerId) {§super(ownerId, 12, "Warping Wail", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{C}");§this.expansionSetCode = "OGW";§Effect effect = new ExileTargetEffect();§effect.setText("Exile target creature with power or toughness 1 or less.");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCreaturePermanent(filterCreature));§Mode mode = new Mode();§mode.getEffects().add(new CounterTargetEffect());§mode.getTargets().add(new TargetSpell(filterSorcery));§this.getSpellAbility().addMode(mode);§mode = new Mode();§effect = new CreateTokenEffect(new EldraziScionToken());§effect.setText("Put a 1/1 colorless Eldrazi Scion creature token onto the battlefield. It has \"Sacrifice this creature: Add {C} to your mana pool.\"");§mode.getEffects().add(effect);§this.getSpellAbility().addMode(mode);§}§public WarpingWail(final WarpingWail card) {§super(card);§}§@Override§public WarpingWail copy() {§return new WarpingWail(this);§}§}§
public class AvenSmokeweaver extends CardImpl {§static final FilterCard filter = new FilterCard("red");§static{§filter.add(new ColorPredicate(ObjectColor.RED));§}§public AvenSmokeweaver(UUID ownerId) {§super(ownerId, 64, "Aven Smokeweaver", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{U}{U}");§this.expansionSetCode = "ODY";§this.subtype.add("Bird");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new ProtectionAbility(filter));§}§public AvenSmokeweaver(final AvenSmokeweaver card) {§super(card);§}§@Override§public AvenSmokeweaver copy() {§return new AvenSmokeweaver(this);§}§}§
public class Cantivore extends CardImpl {§public static final FilterCard filter = new FilterCard("enchantment cards");§static {§filter.add(new CardTypePredicate(CardType.ENCHANTMENT));§}§public Cantivore(UUID ownerId) {§super(ownerId, 13, "Cantivore", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{W}{W}");§this.expansionSetCode = "ODY";§this.subtype.add("Lhurgoyf");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(VigilanceAbility.getInstance());§DynamicValue value = (new CardsInAllGraveyardsCount(filter));§this.addAbility(new SimpleStaticAbility(Zone.ALL, new SetPowerToughnessSourceEffect(value , Duration.EndOfGame)));§}§public Cantivore(final Cantivore card) {§super(card);§}§@Override§public Cantivore copy() {§return new Cantivore(this);§}§}§
public class CrashingCentaur extends CardImpl {§public CrashingCentaur(UUID ownerId) {§super(ownerId, 235, "Crashing Centaur", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{G}{G}");§this.expansionSetCode = "ODY";§this.subtype.add("Centaur");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(TrampleAbility.getInstance(),Duration.EndOfTurn), new ManaCostsImpl("{G}"));§ability.addCost(new DiscardCardCost());§this.addAbility(ability);§Ability thresholdAbility = new SimpleStaticAbility(§Zone.BATTLEFIELD,§new ConditionalContinuousEffect(§new BoostSourceEffect(2, 2, Duration.WhileOnBattlefield),§new CardsInControllerGraveCondition(7),§"If seven or more cards are in your graveyard, {this} gets +2/+2"));§Effect effect = new ConditionalContinuousEffect(§new GainAbilitySourceEffect(ShroudAbility.getInstance()),§new CardsInControllerGraveCondition(7), "and has shroud");§thresholdAbility.addEffect(effect);§thresholdAbility.setAbilityWord(AbilityWord.THRESHOLD);§this.addAbility(thresholdAbility);§}§public CrashingCentaur(final CrashingCentaur card) {§super(card);§}§@Override§public CrashingCentaur copy() {§return new CrashingCentaur(this);§}§}§
public class Dreamwinder extends CardImpl {§public Dreamwinder(UUID ownerId) {§super(ownerId, 83, "Dreamwinder", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "ODY";§this.subtype.add("Serpent");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CantAttackUnlessDefenderControllsPermanent(new FilterLandPermanent("Island","an Island"))));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BecomesBasicLandTargetEffect(Duration.EndOfTurn, "Island"), new ManaCostsImpl("{U}"));§Target target = new TargetLandPermanent();§ability.addTarget(target);§FilterControlledLandPermanent filter = new FilterControlledLandPermanent("an Island");§filter.add(new SubtypePredicate("Island"));§ability.addCost(new SacrificeTargetCost(new TargetControlledPermanent(1, 1, filter, true)));§this.addAbility(ability);§}§public Dreamwinder(final Dreamwinder card) {§super(card);§}§@Override§public Dreamwinder copy() {§return new Dreamwinder(this);§}§}§
public class FreneticOgre extends CardImpl {§public FreneticOgre(UUID ownerId) {§super(ownerId, 195, "Frenetic Ogre", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{R}");§this.expansionSetCode = "ODY";§this.subtype.add("Ogre");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(3, 0, Duration.EndOfTurn), new ManaCostsImpl("{R}"));§ability.addCost(new DiscardCardCost(true));§this.addAbility(ability);§}§public FreneticOgre(final FreneticOgre card) {§super(card);§}§@Override§public FreneticOgre copy() {§return new FreneticOgre(this);§}§}§
public class LuminousGuardian extends CardImpl {§public LuminousGuardian(UUID ownerId) {§super(ownerId, 31, "Luminous Guardian", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "ODY";§this.subtype.add("Human");§this.subtype.add("Nomad");§this.power = new MageInt(1);§this.toughness = new MageInt(4);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(0, 1, Duration.EndOfTurn), new ManaCostsImpl("{W}")));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new CanBlockAdditionalCreatureEffect(Duration.EndOfTurn, 1), new ManaCostsImpl("{2}")));§}§public LuminousGuardian(final LuminousGuardian card) {§super(card);§}§@Override§public LuminousGuardian copy() {§return new LuminousGuardian(this);§}§}§
public class NantukoMentor extends CardImpl {§public NantukoMentor(UUID ownerId) {§super(ownerId, 255, "Nantuko Mentor", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "ODY";§this.subtype.add("Insect");§this.subtype.add("Druid");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new NantukoMentorBoostTargetEffect(), new ManaCostsImpl("{2}{G}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public NantukoMentor(final NantukoMentor card) {§super(card);§}§@Override§public NantukoMentor copy() {§return new NantukoMentor(this);§}§}§class NantukoMentorBoostTargetEffect extends ContinuousEffectImpl {§public NantukoMentorBoostTargetEffect() {§super(Duration.EndOfTurn, Outcome.BoostCreature);§staticText = "Target creature gets +X/+X until end of turn, where X is that creature's power.";§}§public NantukoMentorBoostTargetEffect(final NantukoMentorBoostTargetEffect effect) {§super(effect);§}§@Override§public NantukoMentorBoostTargetEffect copy() {§return new NantukoMentorBoostTargetEffect(this);§}§@Override§public boolean apply(Game game, Ability source){§Permanent target = game.getPermanent(source.getFirstTarget());§if (target != null) {§MageInt power = target.getPower();§target.addPower(power.getValue());§target.addToughness(power.getValue());§}§return true;§}§}§
public class PriceOfGlory extends CardImpl {§public PriceOfGlory(UUID ownerId) {§super(ownerId, 214, "Price of Glory", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{R}");§this.expansionSetCode = "ODY";§this.addAbility(new PriceOfGloryAbility());§}§public PriceOfGlory(final PriceOfGlory card) {§super(card);§}§@Override§public PriceOfGlory copy() {§return new PriceOfGlory(this);§}§}§class PriceOfGloryAbility extends TriggeredAbilityImpl {§private static final String staticText = "Whenever a player taps a land for mana, if it's not that player's turn, destroy that land.";§public PriceOfGloryAbility() {§super(Zone.BATTLEFIELD, new PriceOfGloryEffect());§}§public PriceOfGloryAbility(PriceOfGloryAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.TAPPED_FOR_MANA;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent permanent = game.getPermanent(event.getSourceId());§if (permanent == null) {§permanent = (Permanent) game.getLastKnownInformation(event.getSourceId(), Zone.BATTLEFIELD);§}§if (permanent != null && permanent.getCardType().contains(CardType.LAND)§&& !permanent.getControllerId().equals(game.getActivePlayerId())) { §
public class ScreamsOfTheDamned extends CardImpl {§public ScreamsOfTheDamned(UUID ownerId) {§super(ownerId, 160, "Screams of the Damned", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{3}{B}{B}");§this.expansionSetCode = "ODY";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageEverythingEffect(1), new ManaCostsImpl("{1}{B}"));§ability.addCost(new ExileFromGraveCost(new TargetCardInYourGraveyard()));§this.addAbility(ability);§}§public ScreamsOfTheDamned(final ScreamsOfTheDamned card) {§super(card);§}§@Override§public ScreamsOfTheDamned copy() {§return new ScreamsOfTheDamned(this);§}§}§
public class Standstill extends CardImpl {§public Standstill(UUID ownerId) {§super(ownerId, 102, "Standstill", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{U}");§this.expansionSetCode = "ODY";§this.addAbility(new SpellCastTriggeredAbility());§}§public Standstill(final Standstill card) {§super(card);§}§@Override§public Standstill copy() {§return new Standstill(this);§}§}§class SpellCastTriggeredAbility extends TriggeredAbilityImpl {§public SpellCastTriggeredAbility() {§super(Zone.BATTLEFIELD, new StandstillEffect(), false);§}§public SpellCastTriggeredAbility(final SpellCastTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.SPELL_CAST;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§this.getEffects().get(0).setTargetPointer(new FixedTarget(event.getPlayerId()));§return true;§}§@Override§public String getRule() {§return "When a player casts a spell, sacrifice Standstill. If you do, each of that player's opponents draws three cards.";§}§@Override§public SpellCastTriggeredAbility copy() {§return new SpellCastTriggeredAbility(this);§}§}§class StandstillEffect extends OneShotEffect {§public StandstillEffect() {§super(Outcome.Sacrifice);§staticText = "sacrifice {this}. If you do, each of that player's opponents draws three cards";§}§public StandstillEffect(final StandstillEffect effect) {§super(effect);§}§@Override§public StandstillEffect copy() {§return new StandstillEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(source.getSourceId());§if (permanent != null) {§if (permanent.sacrifice(source.getSourceId(), game)) {§for (UUID uuid : game.getOpponents(this.getTargetPointer().getFirst(game, source))) {§Player player = game.getPlayer(uuid);§if (player != null) {§player.drawCards(3, game);§}§}§return true;§}§}§return false;§}§}§
public class Tremble extends CardImpl {§public Tremble(UUID ownerId) {§super(ownerId, 225, "Tremble", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{1}{R}");§this.expansionSetCode = "ODY";§this.getSpellAbility().addEffect(new SacrificeAllEffect(1, new FilterControlledLandPermanent("land")));§}§public Tremble(final Tremble card) {§super(card);§}§@Override§public Tremble copy() {§return new Tremble(this);§}§}§
public class AkromasBlessing extends CardImpl {§public AkromasBlessing(UUID ownerId) {§super(ownerId, 1, "Akroma's Blessing", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{2}{W}");§this.expansionSetCode = "ONS";§this.getSpellAbility().addEffect(new GainProtectionFromColorAllEffect(Duration.EndOfTurn, new FilterControlledCreaturePermanent("Creatures you control")));§this.addAbility(new CyclingAbility(new ManaCostsImpl("{W}")));§}§public AkromasBlessing(final AkromasBlessing card) {§super(card);§}§@Override§public AkromasBlessing copy() {§return new AkromasBlessing(this);§}§}§
public class Boneknitter extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("Zombie");§static {§filter.add(new SubtypePredicate("Zombie"));§}§public Boneknitter(UUID ownerId) {§super(ownerId, 128, "Boneknitter", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "ONS";§this.subtype.add("Zombie");§this.subtype.add("Cleric");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateTargetEffect(), new ManaCostsImpl("{1}{B}"));§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§this.addAbility(new MorphAbility(this, new ManaCostsImpl("{2}{B}")));§}§public Boneknitter(final Boneknitter card) {§super(card);§}§@Override§public Boneknitter copy() {§return new Boneknitter(this);§}§}§
public class DaruLancer extends CardImpl {§public DaruLancer(UUID ownerId) {§super(ownerId, 20, "Daru Lancer", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{W}{W}");§this.expansionSetCode = "ONS";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§this.addAbility(FirstStrikeAbility.getInstance());§this.addAbility(new MorphAbility(this, new ManaCostsImpl("{2}{W}{W}")));§}§public DaruLancer(final DaruLancer card) {§super(card);§}§@Override§public DaruLancer copy() {§return new DaruLancer(this);§}§}§
public class ExaltedAngel extends CardImpl {§public ExaltedAngel(UUID ownerId) {§super(ownerId, 28, "Exalted Angel", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{W}{W}");§this.expansionSetCode = "ONS";§this.subtype.add("Angel");§this.power = new MageInt(4);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new DealsDamageGainLifeSourceTriggeredAbility());§this.addAbility(new MorphAbility(this, new ManaCostsImpl("{2}{W}{W}")));§}§public ExaltedAngel(final ExaltedAngel card) {§super(card);§}§@Override§public ExaltedAngel copy() {§return new ExaltedAngel(this);§}§}§
public class GoblinTaskmaster extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Goblin creature");§static {§filter.add(new SubtypePredicate("Goblin"));§}§public GoblinTaskmaster(UUID ownerId) {§super(ownerId, 210, "Goblin Taskmaster", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "ONS";§this.subtype.add("Goblin");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(1, 0, Duration.EndOfTurn), new ManaCostsImpl("{1}{R}"));§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§this.addAbility(new MorphAbility(this, new ManaCostsImpl("{R}")));§}§public GoblinTaskmaster(final GoblinTaskmaster card) {§super(card);§}§@Override§public GoblinTaskmaster copy() {§return new GoblinTaskmaster(this);§}§}§
public class IronfistCrusher extends CardImpl {§public IronfistCrusher(UUID ownerId) {§super(ownerId, 42, "Ironfist Crusher", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{W}");§this.expansionSetCode = "ONS";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(4);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CanBlockAdditionalCreatureEffect(0)));§this.addAbility(new MorphAbility(this, new ManaCostsImpl("{3}{W}")));§}§public IronfistCrusher(final IronfistCrusher card) {§super(card);§}§@Override§public IronfistCrusher copy() {§return new IronfistCrusher(this);§}§}§
public class PietyCharm extends CardImpl {§private static final FilterPermanent filter1 = new FilterPermanent("Aura attached to a creature");§private static final FilterCreaturePermanent filter2 = new FilterCreaturePermanent("Soldier creature");§static {§filter1.add(new SubtypePredicate("Aura"));§filter1.add(new AttachedToPredicate(new FilterCreaturePermanent()));§filter2.add(new SubtypePredicate("Soldier"));§}§public PietyCharm(UUID ownerId) {§super(ownerId, 49, "Piety Charm", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{W}");§this.expansionSetCode = "ONS";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addTarget(new TargetPermanent(filter1));§Mode mode = new Mode();§mode.getEffects().add(new BoostTargetEffect(2, 2, Duration.EndOfTurn));§mode.getTargets().add(new TargetCreaturePermanent(filter2));§this.getSpellAbility().addMode(mode);§mode = new Mode();§mode.getEffects().add(new GainAbilityAllEffect(VigilanceAbility.getInstance(), Duration.EndOfTurn, new FilterControlledCreaturePermanent("creatures you control")));§this.getSpellAbility().addMode(mode);§}§public PietyCharm(final PietyCharm card) {§super(card);§}§@Override§public PietyCharm copy() {§return new PietyCharm(this);§}§}§
public class SilentSpecter extends CardImpl {§public SilentSpecter(UUID ownerId) {§super(ownerId, 169, "Silent Specter", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{B}{B}");§this.expansionSetCode = "ONS";§this.subtype.add("Specter");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(new DiscardTargetEffect(2), false, true));§this.addAbility(new MorphAbility(this, new ManaCostsImpl("{3}{B}{B}")));§}§public SilentSpecter(final SilentSpecter card) {§super(card);§}§@Override§public SilentSpecter copy() {§return new SilentSpecter(this);§}§}§
public class SunfireBalm extends CardImpl {§public SunfireBalm(UUID ownerId) {§super(ownerId, 56, "Sunfire Balm", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{2}{W}");§this.expansionSetCode = "ONS";§this.getSpellAbility().addEffect(new PreventDamageToTargetEffect(Duration.EndOfTurn, 4));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§this.addAbility(new CyclingAbility(new ManaCostsImpl("{1}{W}")));§Ability ability = new CycleTriggeredAbility(new PreventDamageToTargetEffect(Duration.EndOfTurn, 1), true);§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public SunfireBalm(final SunfireBalm card) {§super(card);§}§@Override§public SunfireBalm copy() {§return new SunfireBalm(this);§}§}§
public class WalkingDesecration extends CardImpl {§public WalkingDesecration(UUID ownerId) {§super(ownerId, 180, "Walking Desecration", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "ONS";§this.subtype.add("Zombie");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new WalkingDesecrationEffect(), new ManaCostsImpl("{B}"));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public WalkingDesecration(final WalkingDesecration card) {§super(card);§}§@Override§public WalkingDesecration copy() {§return new WalkingDesecration(this);§}§}§class WalkingDesecrationEffect extends OneShotEffect {§public WalkingDesecrationEffect() {§super(Outcome.UnboostCreature);§staticText = "Creatures of the creature type of your choice attack this turn if able";§}§public WalkingDesecrationEffect(final WalkingDesecrationEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§MageObject sourceObject = game.getObject(source.getSourceId());§if (player != null) {§Choice typeChoice = new ChoiceImpl(true);§typeChoice.setMessage("Choose a creature type:");§typeChoice.setChoices(CardRepository.instance.getCreatureTypes());§while (!player.choose(outcome, typeChoice, game)) {§if (!player.canRespond()) {§return false;§}§}§if (typeChoice.getChoice() != null) {§game.informPlayers(sourceObject.getLogName() + " chosen type: " + typeChoice.getChoice());§}§FilterCreaturePermanent filter = new FilterCreaturePermanent();§filter.add(new SubtypePredicate(typeChoice.getChoice()));§RequirementEffect effect = new AttacksIfAbleAllEffect(filter, Duration.EndOfTurn);§game.addEffect(effect, source);§return true;§}§return false;§}§@Override§public WalkingDesecrationEffect copy() {§return new WalkingDesecrationEffect(this);§}§}§
public class GerrardsCommand extends CardImpl {§public GerrardsCommand(UUID ownerId) {§super(ownerId, 53, "Gerrard's Command", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{G}{W}");§this.expansionSetCode = "DDE";§this.getSpellAbility().addEffect(new UntapTargetEffect());§Effect effect = new BoostTargetEffect(3, 3, Duration.EndOfTurn);§effect.setText("It gets +3/+3 until end of turn.");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public GerrardsCommand(final GerrardsCommand card) {§super(card);§}§@Override§public GerrardsCommand copy() {§return new GerrardsCommand(this);§}§}§
public class Calciderm extends CardImpl {§public Calciderm(UUID ownerId) {§super(ownerId, 23, "Calciderm", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{W}{W}");§this.expansionSetCode = "PLC";§this.subtype.add("Beast");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(ShroudAbility.getInstance());§Ability ability = new EntersBattlefieldAbility(new AddCountersSourceEffect(CounterType.TIME.createInstance(4)));§ability.setRuleVisible(false);§this.addAbility(ability);§this.addAbility(new VanishingUpkeepAbility(4));§this.addAbility(new VanishingSacrificeAbility());§}§public Calciderm(final Calciderm card) {§super(card);§}§@Override§public Calciderm copy() {§return new Calciderm(this);§}§}§
public class Extirpate extends CardImpl {§private static final FilterCard filter = new FilterCard("card in a graveyard other than a basic land card");§static {§filter.add(Predicates.not(Predicates.and(new CardTypePredicate(CardType.LAND), new SupertypePredicate("Basic"))));§}§public Extirpate(UUID ownerId) {§super(ownerId, 71, "Extirpate", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{B}");§this.expansionSetCode = "PLC";§this.addAbility(new SplitSecondAbility());§this.getSpellAbility().addEffect(new ExtirpateEffect());§this.getSpellAbility().addTarget(new TargetCardInGraveyard(filter));§}§public Extirpate(final Extirpate card) {§super(card);§}§@Override§public Extirpate copy() {§return new Extirpate(this);§}§}§class ExtirpateEffect extends OneShotEffect {§public ExtirpateEffect() {§super(Outcome.Exile);§this.staticText = "Choose target card in a graveyard other than a basic land card. Search its owner's graveyard, hand, and library for any number of cards with the same name as that card and exile them. Then that player shuffles his or her library";§}§public ExtirpateEffect(final ExtirpateEffect effect) {§super(effect);§}§@Override§public ExtirpateEffect copy() {§return new ExtirpateEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = game.getObject(source.getSourceId());§Card chosenCard = game.getCard(getTargetPointer().getFirst(game, source));§if (chosenCard != null && sourceObject != null && controller != null) {§Player owner = game.getPlayer(chosenCard.getOwnerId());§if (owner == null) {§return false;§}§FilterCard filterNamedCard = new FilterCard();§filterNamedCard.add(new NamePredicate(chosenCard.getName()));§for (Card checkCard : owner.getGraveyard().getCards(game)) {§if (checkCard.getName().equals(chosenCard.getName())) {§controller.moveCardToExileWithInfo(checkCard, null, "", source.getSourceId(), game, Zone.GRAVEYARD, true);§}§}§filterNamedCard.setMessage("card named " + chosenCard.getLogName() + " in the hand of " + owner.getLogName());§TargetCardInHand targetCardInHand = new TargetCardInHand(0, Integer.MAX_VALUE, filterNamedCard);§if (controller.choose(Outcome.Exile, owner.getHand(), targetCardInHand, game)) {§List<UUID> targets = targetCardInHand.getTargets();§for (UUID targetId : targets) {§Card targetCard = owner.getHand().get(targetId, game);§if (targetCard != null) {§controller.moveCardToExileWithInfo(targetCard, null, "", source.getSourceId(), game, Zone.HAND, true);§}§}§}§filterNamedCard.setMessage("card named " + chosenCard.getName() + " in the library of " + owner.getName());§TargetCardInLibrary targetCardInLibrary = new TargetCardInLibrary(0, Integer.MAX_VALUE, filterNamedCard);§if (controller.searchLibrary(targetCardInLibrary, game, owner.getId())) {§List<UUID> targets = targetCardInLibrary.getTargets();§for (UUID targetId : targets) {§Card targetCard = owner.getLibrary().getCard(targetId, game);§if (targetCard != null) {§controller.moveCardToExileWithInfo(targetCard, null, "", source.getSourceId(), game, Zone.LIBRARY, true);§}§}§}§owner.shuffleLibrary(game);§return true;§}§return false;§}§}§
public class IntetTheDreamer extends CardImpl {§protected static final String VALUE_PREFIX = "ExileZones";§public IntetTheDreamer(UUID ownerId) {§super(ownerId, 158, "Intet, the Dreamer", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{U}{R}{G}");§this.expansionSetCode = "PLC";§this.supertype.add("Legendary");§this.subtype.add("Dragon");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(§new DoIfCostPaid(new IntetTheDreamerExileEffect(), new ManaCostsImpl("{2}{U}")), false, true));§this.addAbility(new SimpleStaticAbility(Zone.ALL, new IntetTheDreamerLookEffect()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new IntetTheDreamerCastEffect()));§}§public IntetTheDreamer(final IntetTheDreamer card) {§super(card);§}§@Override§public IntetTheDreamer copy() {§return new IntetTheDreamer(this);§}§}§class IntetTheDreamerExileEffect extends OneShotEffect {§public IntetTheDreamerExileEffect() {§super(Outcome.Discard);§staticText = "exile the top card of your library face down";§}§public IntetTheDreamerExileEffect(final IntetTheDreamerExileEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Card card = controller.getLibrary().getFromTop(game);§MageObject sourceObject = source.getSourceObject(game);§if (card != null && sourceObject != null) {§UUID exileZoneId = CardUtil.getExileZoneId(game, source.getSourceId(), source.getSourceObjectZoneChangeCounter());§card.setFaceDown(true, game);§controller.moveCardsToExile(card, source, game, false, exileZoneId, sourceObject.getIdName());§card.setFaceDown(true, game);§Set<UUID> exileZones = (Set<UUID>) game.getState().getValue(IntetTheDreamer.VALUE_PREFIX + source.getSourceId().toString());§if (exileZones == null) {§exileZones = new HashSet<>();§game.getState().setValue(IntetTheDreamer.VALUE_PREFIX + source.getSourceId().toString(), exileZones);§}§exileZones.add(exileZoneId);§return true;§}§}§return false;§}§@Override§public IntetTheDreamerExileEffect copy() {§return new IntetTheDreamerExileEffect(this);§}§}§class IntetTheDreamerCastEffect extends AsThoughEffectImpl {§public IntetTheDreamerCastEffect() {§super(AsThoughEffectType.PLAY_FROM_NOT_OWN_HAND_ZONE, Duration.WhileOnBattlefield, Outcome.Benefit);§staticText = "You may play the card from exile without paying its mana cost for as long as {this} remains on the battlefield";§}§public IntetTheDreamerCastEffect(final IntetTheDreamerCastEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public IntetTheDreamerCastEffect copy() {§return new IntetTheDreamerCastEffect(this);§}§@Override§public boolean applies(UUID objectId, Ability source, UUID affectedControllerId, Game game) {§if (affectedControllerId.equals(source.getControllerId()) && game.getState().getZone(objectId).equals(Zone.EXILED)) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = source.getSourceObject(game);§if (controller != null && sourceObject != null) {§Card card = game.getCard(objectId);§if (card != null && card.isFaceDown(game)) {§ExileZone zone = game.getExile().getExileZone(CardUtil.getExileZoneId(game, source.getSourceId(), source.getSourceObjectZoneChangeCounter()));§if (zone != null && zone.contains(card.getId())/* && CardUtil.cardCanBePlayedNow(card, controller.getId(), game)*/) {§if (card.getCardType().contains(CardType.LAND)) {§if (game.canPlaySorcery(controller.getId()) && game.getPlayer(controller.getId()).canPlayLand()) {§return controller.chooseUse(outcome, "Play " + card.getName() + "?", source, game);§}§} else {§controller.setCastSourceIdWithAlternateMana(objectId, null, null);§return true;§}§}§}§}§}§return false;§}§}§class IntetTheDreamerLookEffect extends AsThoughEffectImpl {§public IntetTheDreamerLookEffect() {§super(AsThoughEffectType.LOOK_AT_FACE_DOWN, Duration.EndOfGame, Outcome.Benefit);§staticText = "You may look at that card for as long as it remains exiled";§}§public IntetTheDreamerLookEffect(final IntetTheDreamerLookEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public IntetTheDreamerLookEffect copy() {§return new IntetTheDreamerLookEffect(this);§}§@Override§public boolean applies(UUID objectId, Ability source, UUID affectedControllerId, Game game) {§if (affectedControllerId.equals(source.getControllerId()) && game.getState().getZone(objectId).equals(Zone.EXILED)) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = source.getSourceObject(game);§if (controller != null && sourceObject != null) {§Card card = game.getCard(objectId);§if (card != null && card.isFaceDown(game)) {§Set<UUID> exileZones = (Set<UUID>) game.getState().getValue(IntetTheDreamer.VALUE_PREFIX + source.getSourceId().toString());§if (exileZones != null) {§for (ExileZone exileZone : game.getExile().getExileZones()) {§if (exileZone.contains(objectId)) {§if (!exileZones.contains(exileZone.getId())) {§return false;§}§}§}§return true;§}§}§}§}§return false;§}§}§
public class Ovinize extends CardImpl {§public Ovinize(UUID ownerId) {§super(ownerId, 57, "Ovinize", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "PLC";§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new LoseAllAbilitiesTargetEffect(Duration.EndOfTurn));§Effect effect = new SetPowerToughnessTargetEffect(0, 1, Duration.EndOfTurn);§effect.setText("and has base power and toughness 0/1");§this.getSpellAbility().addEffect(effect);§}§public Ovinize(final Ovinize card) {§super(card);§}§@Override§public Ovinize copy() {§return new Ovinize(this);§}§}§
public class Saltblast extends CardImpl {§static final protected FilterPermanent filter = new FilterPermanent("nonwhite permanent");§static {§filter.add(Predicates.not(new ColorPredicate(ObjectColor.WHITE)));§}§public Saltblast(UUID ownerId) {§super(ownerId, 15, "Saltblast", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{3}{W}{W}");§this.expansionSetCode = "PLC";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addTarget(new TargetPermanent(filter));§}§public Saltblast(final Saltblast card) {§super(card);§}§@Override§public Saltblast copy() {§return new Saltblast(this);§}§}§
public class Timbermare extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("other creatures");§static {§filter.add(new AnotherPredicate());§}§public Timbermare(UUID ownerId) {§super(ownerId, 140, "Timbermare", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "PLC";§this.subtype.add("Elemental");§this.subtype.add("Horse");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(HasteAbility.getInstance());§this.addAbility(new EchoAbility("{5}{G}"));§this.addAbility(new EntersBattlefieldTriggeredAbility(new TapAllEffect(filter)));§}§public Timbermare(final Timbermare card) {§super(card);§}§@Override§public Timbermare copy() {§return new Timbermare(this);§}§}§
public class Briarhorn extends CardImpl {§public Briarhorn(UUID ownerId) {§super(ownerId, 69, "Briarhorn", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "HOP";§this.subtype.add("Elemental");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlashAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new BoostTargetEffect(3,3, Duration.EndOfTurn));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§this.addAbility(new EvokeAbility(this, "{1}{G}"));§}§public Briarhorn(final Briarhorn card) {§super(card);§}§@Override§public Briarhorn copy() {§return new Briarhorn(this);§}§}§
public class LoxodonWarhammer extends CardImpl {§public LoxodonWarhammer(UUID ownerId) {§super(ownerId, 118, "Loxodon Warhammer", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "HOP";§this.subtype.add("Equipment");§Effect effect = new BoostEquippedEffect(3, 0);§effect.setText("Equipped creature gets +3/+0");§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, effect);§effect = new GainAbilityAttachedEffect(TrampleAbility.getInstance(), AttachmentType.EQUIPMENT);§effect.setText("and has trample");§ability.addEffect(effect);§effect = new GainAbilityAttachedEffect(LifelinkAbility.getInstance(), AttachmentType.EQUIPMENT);§effect.setText("and lifelink. <i>(If the creature would assign enough damage to its blockers to destroy them, you may have it assign the rest of its damage to defending player or planeswalker. Damage dealt by the creature also causes its controller to gain that much life.)</i>");§ability.addEffect(effect);§this.addAbility(ability);§this.addAbility(new EquipAbility(Outcome.BoostCreature, new GenericManaCost(3)));§}§public LoxodonWarhammer(final LoxodonWarhammer card) {§super(card);§}§@Override§public LoxodonWarhammer copy() {§return new LoxodonWarhammer(this);§}§}§
public class ThirstForKnowledge extends CardImpl {§public ThirstForKnowledge(UUID ownerId) {§super(ownerId, 14, "Thirst for Knowledge", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{2}{U}");§this.expansionSetCode = "HOP";§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(3));§this.getSpellAbility().addEffect(new ThirstforKnowledgeEffect());§}§public ThirstForKnowledge(final ThirstForKnowledge card) {§super(card);§}§@Override§public ThirstForKnowledge copy() {§return new ThirstForKnowledge(this);§}§}§class ThirstforKnowledgeEffect extends OneShotEffect {§public ThirstforKnowledgeEffect() {§super(Outcome.Damage);§staticText = "Then discard two cards unless you discard an artifact card";§}§public ThirstforKnowledgeEffect(final ThirstforKnowledgeEffect effect) {§super(effect);§}§@Override§public ThirstforKnowledgeEffect copy() {§return new ThirstforKnowledgeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player you = game.getPlayer(source.getControllerId());§FilterCard filter = new FilterCard("artifact to discard");§filter.add(new CardTypePredicate(CardType.ARTIFACT));§if (you != null§&& you.getHand().count(filter, game) > 0§&& you.chooseUse(Outcome.Discard, "Do you want to discard an artifact? If you don't, you must discard 2 cards", source, game)) {§Cost cost = new DiscardTargetCost(new TargetCardInHand(filter));§if (cost.canPay(source, source.getSourceId(), you.getId(), game)) {§if (cost.pay(source, game, source.getSourceId(), you.getId(), false, null)) {§return true;§}§}§}§if (you != null) {§you.discard(2, false, source, game);§return true;§}§return false;§}§}§
public class LastStand extends CardImpl {§public LastStand(UUID ownerId) {§super(ownerId, 100, "Last Stand", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{W}{U}{B}{R}{G}");§this.expansionSetCode = "PC2";§this.getSpellAbility().addEffect(new LastStandEffect());§this.getSpellAbility().addTarget(new TargetOpponent());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public LastStand(final LastStand card) {§super(card);§}§@Override§public LastStand copy() {§return new LastStand(this);§}§}§class LastStandEffect extends OneShotEffect {§private static final FilterControlledLandPermanent filterSwamp = new FilterControlledLandPermanent();§private static final FilterControlledLandPermanent filterMountain = new FilterControlledLandPermanent();§private static final FilterControlledLandPermanent filterPlains = new FilterControlledLandPermanent();§private static final FilterControlledLandPermanent filterForest = new FilterControlledLandPermanent();§private static final FilterControlledLandPermanent filterIsland = new FilterControlledLandPermanent();§static {§filterSwamp.add(new SubtypePredicate("Swamp"));§filterMountain.add(new SubtypePredicate("Mountain"));§filterPlains.add(new SubtypePredicate("Plains"));§filterForest.add(new SubtypePredicate("Forest"));§filterIsland.add(new SubtypePredicate("Island"));§}§public LastStandEffect() {§super(Outcome.Benefit);§this.staticText = "Target opponent loses 2 life for each Swamp you control. Last Stand deals damage equal to the number of Mountains you control to target creature. Put a 1/1 green Saproling creature token onto the battlefield for each Forest you control. You gain 2 life for each Plains you control. Draw a card for each Island you control, then discard that many cards";§}§public LastStandEffect(final LastStandEffect effect) {§super(effect);§}§@Override§public LastStandEffect copy() {§return new LastStandEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Player opponent = game.getPlayer(getTargetPointer().getFirst(game, source));§if (opponent != null) {§int swamps = game.getBattlefield().count(filterSwamp, source.getSourceId(), source.getControllerId(), game);§opponent.damage(swamps, source.getSourceId(), game, false, true);§}§Permanent creature = game.getPermanent(source.getTargets().get(1).getFirstTarget());§if (creature != null) {§int mountains = game.getBattlefield().count(filterMountain, source.getSourceId(), source.getControllerId(), game);§if (mountains > 0) {§creature.damage(mountains, source.getSourceId(), game, false, true);§}§}§int forests = game.getBattlefield().count(filterForest, source.getSourceId(), source.getControllerId(), game);§if (forests > 0) {§new CreateTokenEffect(new SaprolingToken(), forests).apply(game, source);§}§int plains = game.getBattlefield().count(filterPlains, source.getSourceId(), source.getControllerId(), game);§controller.gainLife(plains, game);§int islands = game.getBattlefield().count(filterIsland, source.getSourceId(), source.getControllerId(), game);§if (islands > 0) {§controller.drawCards(islands, game);§controller.discard(islands, false, source, game);§}§}§return false;§}§}§
public class AlliedStrategies extends CardImpl {§public AlliedStrategies(UUID ownerId) {§super(ownerId, 20, "Allied Strategies", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{4}{U}");§this.expansionSetCode = "PLS";§this.getSpellAbility().addEffect(new DrawCardTargetEffect(new DomainValue(true)));§this.getSpellAbility().addTarget(new TargetPlayer());§}§public AlliedStrategies(final AlliedStrategies card) {§super(card);§}§@Override§public AlliedStrategies copy() {§return new AlliedStrategies(this);§}§}§
public class DoomsdaySpecter extends CardImpl {§static final private FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("blue or black creature you control");§static {§filter.add(Predicates.or(new ColorPredicate(ObjectColor.BLUE), new ColorPredicate(ObjectColor.BLACK)));§}§public DoomsdaySpecter(UUID ownerId) {§super(ownerId, 103, "Doomsday Specter", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{U}{B}");§this.expansionSetCode = "PLS";§this.subtype.add("Specter");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new ReturnToHandChosenControlledPermanentEffect(filter), false));§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(new DiscardCardYouChooseTargetEffect(), false, true));§}§public DoomsdaySpecter(final DoomsdaySpecter card) {§super(card);§}§@Override§public DoomsdaySpecter copy() {§return new DoomsdaySpecter(this);§}§}§
public class LashknifeBarrier extends CardImpl {§public LashknifeBarrier(UUID ownerId) {§super(ownerId, 9, "Lashknife Barrier", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{W}");§this.expansionSetCode = "PLS";§this.addAbility(new EntersBattlefieldTriggeredAbility(new DrawCardSourceControllerEffect(1)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new LashknifeBarrierEffect()));§}§public LashknifeBarrier(final LashknifeBarrier card) {§super(card);§}§@Override§public LashknifeBarrier copy() {§return new LashknifeBarrier(this);§}§}§class LashknifeBarrierEffect extends ReplacementEffectImpl {§public LashknifeBarrierEffect() {§super(Duration.WhileOnBattlefield, Outcome.Benefit);§staticText = "If a source would deal damage to a creature you control, it deals that much damage minus 1 to that creature instead.";§}§public LashknifeBarrierEffect(final LashknifeBarrierEffect effect) {§super(effect);§}§@Override§public LashknifeBarrierEffect copy() {§return new LashknifeBarrierEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§event.setAmount(event.getAmount() - 1);§return false;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGE_CREATURE;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§Permanent creature = game.getPermanent(event.getTargetId());§return creature.getControllerId().equals(source.getControllerId());§}§}§
public class PhyrexianTyranny extends CardImpl {§public PhyrexianTyranny(UUID ownerId) {§super(ownerId, 118, "Phyrexian Tyranny", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{U}{B}{R}");§this.expansionSetCode = "PLS";§this.addAbility(new PhyrexianTyrannyTriggeredAbility());§}§public PhyrexianTyranny(final PhyrexianTyranny card) {§super(card);§}§@Override§public PhyrexianTyranny copy() {§return new PhyrexianTyranny(this);§}§}§class PhyrexianTyrannyTriggeredAbility extends TriggeredAbilityImpl {§PhyrexianTyrannyTriggeredAbility() {§super(Zone.BATTLEFIELD, new PhyrexianTyrannyEffect(), false);§}§PhyrexianTyrannyTriggeredAbility(final PhyrexianTyrannyTriggeredAbility ability) {§super(ability);§}§@Override§public PhyrexianTyrannyTriggeredAbility copy() {§return new PhyrexianTyrannyTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DREW_CARD;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§for (Effect effect : this.getEffects()) {§if (effect instanceof PhyrexianTyrannyEffect) {§effect.setTargetPointer(new FixedTarget(event.getPlayerId()));§}§}§return true;§}§@Override§public String getRule() {§return "Whenever a player draws a card, that player loses 2 life unless he or she pays {2}";§}§}§class PhyrexianTyrannyEffect extends OneShotEffect {§PhyrexianTyrannyEffect() {§super(Outcome.Neutral);§this.staticText = "that player loses 2 life unless he or she pays {2}";§}§PhyrexianTyrannyEffect(final PhyrexianTyrannyEffect effect) {§super(effect);§}§@Override§public PhyrexianTyrannyEffect copy() {§return new PhyrexianTyrannyEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(targetPointer.getFirst(game, source));§if (player != null) {§Cost cost = new GenericManaCost(2);§if (!cost.pay(source, game, player.getId(), player.getId(), false, null)) {§player.damage(2, source.getSourceId(), game, false, true);§}§return true;§}§return false;§}§}§
public class SinisterStrength extends CardImpl {§public SinisterStrength(UUID ownerId) {§super(ownerId, 54, "Sinister Strength", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{B}");§this.expansionSetCode = "PLS";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§Effect effect = new BoostEnchantedEffect(3, 1);§effect.setText("Enchanted creature gets +3/+1");§ability = new SimpleStaticAbility(Zone.BATTLEFIELD, effect);§effect = new SetCardColorAttachedEffect(ObjectColor.BLACK, Duration.WhileOnBattlefield, AttachmentType.AURA);§effect.setText("and is black");§ability.addEffect(effect);§this.addAbility(ability);§}§public SinisterStrength(final SinisterStrength card) {§super(card);§}§@Override§public SinisterStrength copy() {§return new SinisterStrength(this);§}§}§
public class UrzasGuilt extends CardImpl {§public UrzasGuilt(UUID ownerId) {§super(ownerId, 130, "Urza's Guilt", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{2}{U}{B}");§this.expansionSetCode = "PLS";§this.getSpellAbility().addEffect(new DrawCardAllEffect(2));§Effect effect = new DiscardEachPlayerEffect(3, false);§effect.setText("then discards three cards");§this.getSpellAbility().addEffect(effect);§effect = new LoseLifeAllPlayersEffect(4);§effect.setText("then loses 4 life");§this.getSpellAbility().addEffect(effect);§}§public UrzasGuilt(final UrzasGuilt card) {§super(card);§}§@Override§public UrzasGuilt copy() {§return new UrzasGuilt(this);§}§}§
public class DevotedHero extends CardImpl {§public DevotedHero(UUID ownerId) {§super(ownerId, 175, "Devoted Hero", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{W}");§this.expansionSetCode = "POR";§this.subtype.add("Elf");§this.subtype.add("Soldier");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§}§public DevotedHero(final DevotedHero card) {§super(card);§}§@Override§public DevotedHero copy() {§return new DevotedHero(this);§}§}§
public class MindKnives extends CardImpl {§public MindKnives(UUID ownerId) {§super(ownerId, 23, "Mind Knives", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{1}{B}");§this.expansionSetCode = "POR";§this.getSpellAbility().addEffect(new DiscardTargetEffect(1, true));§this.getSpellAbility().addTarget(new TargetOpponent());§}§public MindKnives(final MindKnives card) {§super(card);§}§@Override§public MindKnives copy() {§return new MindKnives(this);§}§}§
public class SpottedGriffin extends CardImpl {§public SpottedGriffin(UUID ownerId) {§super(ownerId, 190, "Spotted Griffin", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "POR";§this.subtype.add("Griffin");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§}§public SpottedGriffin(final SpottedGriffin card) {§super(card);§}§@Override§public SpottedGriffin copy() {§return new SpottedGriffin(this);§}§}§
public class AlabornCavalier extends CardImpl {§public AlabornCavalier(UUID ownerId) {§super(ownerId, 121, "Alaborn Cavalier", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{W}{W}");§this.expansionSetCode = "PO2";§this.subtype.add("Human");§this.subtype.add("Knight");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new AttacksTriggeredAbility(new TapTargetEffect(), true);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public AlabornCavalier(final AlabornCavalier card) {§super(card);§}§@Override§public AlabornCavalier copy() {§return new AlabornCavalier(this);§}§}§
public class FalseSummoning extends CardImpl {§public FalseSummoning(UUID ownerId) {§super(ownerId, 40, "False Summoning", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "PO2";§this.getSpellAbility().addTarget(new TargetSpell(new FilterCreatureSpell()));§this.getSpellAbility().addEffect(new CounterTargetEffect());§}§public FalseSummoning(final FalseSummoning card) {§super(card);§}§@Override§public FalseSummoning copy() {§return new FalseSummoning(this);§}§}§
public class OgreWarrior extends CardImpl {§public OgreWarrior(UUID ownerId) {§super(ownerId, 113, "Ogre Warrior", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "PO2";§this.subtype.add("Ogre");§this.subtype.add("Warrior");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§}§public OgreWarrior(final OgreWarrior card) {§super(card);§}§@Override§public OgreWarrior copy() {§return new OgreWarrior(this);§}§}§
public class WildOx extends CardImpl {§public WildOx(UUID ownerId) {§super(ownerId, 90, "Wild Ox", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "PO2";§this.subtype.add("Ox");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new SwampwalkAbility());§}§public WildOx(final WildOx card) {§super(card);§}§@Override§public WildOx copy() {§return new WildOx(this);§}§}§
public class DongZhouTheTyrant extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature an opponent controls");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public DongZhouTheTyrant(UUID ownerId) {§super(ownerId, 109, "Dong Zhou, the Tyrant", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{R}");§this.expansionSetCode = "PTK";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§Ability ability = new EntersBattlefieldTriggeredAbility(new DongZhouTheTyrantEffect(), false);§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public DongZhouTheTyrant(final DongZhouTheTyrant card) {§super(card);§}§@Override§public DongZhouTheTyrant copy() {§return new DongZhouTheTyrant(this);§}§}§class DongZhouTheTyrantEffect extends OneShotEffect {§public DongZhouTheTyrantEffect() {§super(Outcome.Damage);§staticText = "target creature an opponent controls deals damage equal to its power to that player";§}§public DongZhouTheTyrantEffect(final DongZhouTheTyrantEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent creature = game.getPermanent(source.getFirstTarget());§if (creature != null) {§int amount = creature.getPower().getValue();§Player controller = game.getPlayer(creature.getControllerId());§if (controller != null) {§controller.damage(amount, creature.getId(), game, false, true);§return true;§}§}§return false;§}§@Override§public DongZhouTheTyrantEffect copy() {§return new DongZhouTheTyrantEffect(this);§}§}§
public class MarshalingTheTroops extends CardImpl {§public MarshalingTheTroops(UUID ownerId) {§super(ownerId, 141, "Marshaling the Troops", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{1}{G}");§this.expansionSetCode = "PTK";§this.getSpellAbility().addEffect(new MarshalingTheTroopsEffect());§}§public MarshalingTheTroops(final MarshalingTheTroops card) {§super(card);§}§@Override§public MarshalingTheTroops copy() {§return new MarshalingTheTroops(this);§}§}§class MarshalingTheTroopsEffect extends OneShotEffect {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("untapped creatures you control");§static {§filter.add(new ControllerPredicate(TargetController.YOU));§filter.add(Predicates.not(new TappedPredicate()));§}§public MarshalingTheTroopsEffect() {§super(Outcome.GainLife);§staticText = "Tap any number of untapped creatures you control. You gain 4 life for each creature tapped this way";§}§public MarshalingTheTroopsEffect(MarshalingTheTroopsEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int tappedAmount = 0;§TargetPermanent target = new TargetPermanent(0, 1, filter, false);§while (true) {§target.clearChosen();§if (target.canChoose(source.getControllerId(), game) && target.choose(Outcome.Tap, source.getControllerId(), source.getSourceId(), game)) {§Map<String, Serializable> options = new HashMap<>();§options.put("UI.right.btn.text", "Tapping complete");§controller.choose(outcome, target, source.getControllerId(), game, options);§if (target.getTargets().size() > 0) {§UUID creature = target.getFirstTarget();§if (creature != null) {§game.getPermanent(creature).tap(game);§tappedAmount++;§}§} else {§break;§}§} else {§break;§}§}§if (tappedAmount > 0) {§controller.gainLife(tappedAmount * 4, game);§}§return true;§}§return false;§}§@Override§public MarshalingTheTroopsEffect copy() {§return new MarshalingTheTroopsEffect(this);§}§}§
public class ShuGeneral extends CardImpl {§public ShuGeneral(UUID ownerId) {§super(ownerId, 25, "Shu General", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "PTK";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(HorsemanshipAbility.getInstance());§}§public ShuGeneral(final ShuGeneral card) {§super(card);§}§@Override§public ShuGeneral copy() {§return new ShuGeneral(this);§}§}§
public class WeiInfantry extends CardImpl {§public WeiInfantry(UUID ownerId) {§super(ownerId, 88, "Wei Infantry", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "PTK";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§}§public WeiInfantry(final WeiInfantry card) {§super(card);§}§@Override§public WeiInfantry copy() {§return new WeiInfantry(this);§}§}§
public class ZhaoZilongTigerGeneral extends CardImpl {§public ZhaoZilongTigerGeneral(UUID ownerId) {§super(ownerId, 33, "Zhao Zilong, Tiger General", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{W}{W}");§this.expansionSetCode = "PTK";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Soldier");§this.subtype.add("Warrior");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(HorsemanshipAbility.getInstance());§this.addAbility(new BlocksTriggeredAbility(new BoostSourceEffect(1, 1, Duration.EndOfTurn), false));§}§public ZhaoZilongTigerGeneral(final ZhaoZilongTigerGeneral card) {§super(card);§}§@Override§public ZhaoZilongTigerGeneral copy() {§return new ZhaoZilongTigerGeneral(this);§}§}§
public class QuestingPhelddagrif extends CardImpl {§private static final FilterCard filter = new FilterCard("black and from red");§static {§filter.add(Predicates.or(new ColorPredicate(ObjectColor.BLACK), new ColorPredicate(ObjectColor.RED)));§}§public QuestingPhelddagrif(UUID ownerId) {§super(ownerId, 13, "Questing Phelddagrif", Rarity.SPECIAL, new CardType[]{CardType.CREATURE}, "{1}{G}{W}{U}");§this.expansionSetCode = "PTC";§this.subtype.add("Phelddagrif");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 1, Duration.EndOfTurn),§new ManaCostsImpl("{G}"));§ability.addEffect(new CreateTokenTargetEffect(new HippoToken()));§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(new ProtectionAbility(filter),§Duration.EndOfTurn), new ManaCostsImpl("{W}"));§ability.addEffect(new GainLifeTargetEffect(2));§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(FlyingAbility.getInstance(),§Duration.EndOfTurn), new ManaCostsImpl("{U}"));§ability.addEffect(new DrawCardTargetEffect(1, true));§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§}§public QuestingPhelddagrif(final QuestingPhelddagrif card) {§super(card);§}§@Override§public QuestingPhelddagrif copy() {§return new QuestingPhelddagrif(this);§}§}§class HippoToken extends Token {§public HippoToken() {§super("Hippo", "1/1 green Hippo creature token");§cardType.add(CardType.CREATURE);§color.setGreen(true);§subtype.add("Hippo");§power = new MageInt(1);§toughness = new MageInt(1);§}§}§
public class FenStalker extends CardImpl {§private static final FilterControlledLandPermanent filter = new FilterControlledLandPermanent();§static {§filter.add(Predicates.not(new TappedPredicate()));§}§public FenStalker(UUID ownerId) {§super(ownerId, 64, "Fen Stalker", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{B}");§this.expansionSetCode = "PCY";§this.subtype.add("Nightstalker");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD,§new ConditionalContinuousEffect(new GainAbilitySourceEffect(FearAbility.getInstance(),§Duration.WhileOnBattlefield), new InvertCondition(new PermanentsOnTheBattlefieldCondition(filter)),§"{this} has fear as long as you control no untapped lands")));§}§public FenStalker(final FenStalker card) {§super(card);§}§@Override§public FenStalker copy() {§return new FenStalker(this);§}§}§
public class MineBearer extends CardImpl {§public MineBearer(UUID ownerId) {§super(ownerId, 16, "Mine Bearer", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "PCY";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetAttackingCreature());§this.addAbility(ability);§}§public MineBearer(final MineBearer card) {§super(card);§}§@Override§public MineBearer copy() {§return new MineBearer(this);§}§}§
public class SiltCrawler extends CardImpl {§public SiltCrawler(UUID ownerId) {§super(ownerId, 123, "Silt Crawler", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "PCY";§this.subtype.add("Beast");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new EntersBattlefieldTriggeredAbility(new TapAllEffect(new FilterControlledLandPermanent("lands you control")), false));§}§public SiltCrawler(final SiltCrawler card) {§super(card);§}§@Override§public SiltCrawler copy() {§return new SiltCrawler(this);§}§}§
public class WhipstitchedZombie extends CardImpl {§public WhipstitchedZombie(UUID ownerId) {§super(ownerId, 81, "Whipstitched Zombie", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "PCY";§this.subtype.add("Zombie");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new SacrificeSourceUnlessPaysEffect(new ManaCostsImpl("{B}")), TargetController.YOU, false));§}§public WhipstitchedZombie(final WhipstitchedZombie card) {§super(card);§}§@Override§public WhipstitchedZombie copy() {§return new WhipstitchedZombie(this);§}§}§
public class CarrionHowler extends CardImpl {§public CarrionHowler(UUID ownerId) {§super(ownerId, 79, "Carrion Howler", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{B}");§this.expansionSetCode = "RAV";§this.subtype.add("Zombie");§this.subtype.add("Wolf");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(2, -1, Duration.EndOfTurn), new PayLifeCost(1)));§}§public CarrionHowler(final CarrionHowler card) {§super(card);§}§@Override§public CarrionHowler copy() {§return new CarrionHowler(this);§}§}§
public class DarkHeartOfTheWood extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("Forest");§static {§filter.add(new SubtypePredicate("Forest"));§}§public DarkHeartOfTheWood(UUID ownerId) {§super(ownerId, 200, "Dark Heart of the Wood", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{B}{G}");§this.expansionSetCode = "RAV";§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainLifeEffect(3), new SacrificeTargetCost(new TargetControlledPermanent(filter))));§}§public DarkHeartOfTheWood(final DarkHeartOfTheWood card) {§super(card);§}§@Override§public DarkHeartOfTheWood copy() {§return new DarkHeartOfTheWood(this);§}§}§
public class Farseek extends CardImpl {§private static final FilterCard filter = new FilterCard("Plains, Island, Swamp, or Mountain card");§static {§filter.add(Predicates.or(§new SubtypePredicate("Plains"),§new SubtypePredicate("Island"),§new SubtypePredicate("Swamp"),§new SubtypePredicate("Mountain")));§}§public Farseek(UUID ownerId) {§super(ownerId, 163, "Farseek", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{1}{G}");§this.expansionSetCode = "RAV";§this.getSpellAbility().addEffect(new SearchLibraryPutInPlayEffect(new TargetCardInLibrary(filter), true, Outcome.PutLandInPlay));§}§public Farseek(final Farseek card) {§super(card);§}§@Override§public Farseek copy() {§return new Farseek(this);§}§}§
public class GolgariGuildmage extends CardImpl {§public GolgariGuildmage (UUID ownerId) {§super(ownerId, 248, "Golgari Guildmage", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{B/G}{B/G}");§this.expansionSetCode = "RAV";§this.subtype.add("Elf");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ReturnToHandTargetEffect(), new ManaCostsImpl("{4}{B}"));§ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent()));§ability.addTarget(new TargetCardInYourGraveyard(new FilterCreatureCard("creature card from your graveyard")));§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersTargetEffect(CounterType.P1P1.createInstance()), new ManaCostsImpl("{4}{G}"));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public GolgariGuildmage (final GolgariGuildmage card) {§super(card);§}§@Override§public GolgariGuildmage copy() {§return new GolgariGuildmage(this);§}§}§
public class HuntedTroll extends CardImpl {§public HuntedTroll(UUID ownerId) {§super(ownerId, 170, "Hunted Troll", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{G}{G}");§this.expansionSetCode = "RAV";§this.subtype.add("Troll");§this.subtype.add("Warrior");§this.power = new MageInt(8);§this.toughness = new MageInt(4);§Ability ability = new EntersBattlefieldTriggeredAbility(new CreateTokenTargetEffect(new FaerieToken(), 4), false);§Target target = new TargetOpponent();§ability.addTarget(target);§this.addAbility(ability);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new ColoredManaCost(ColoredManaSymbol.G)));§}§public HuntedTroll(final HuntedTroll card) {§super(card);§}§@Override§public HuntedTroll copy() {§return new HuntedTroll(this);§}§}§class FaerieToken extends Token {§FaerieToken() {§super("Faerie", "1/1 blue Faerie creature tokens with flying");§cardType.add(CardType.CREATURE);§color.setBlue(true);§subtype.add("Faerie");§power = new MageInt(1);§toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§}§}§
public class NecromanticThirst extends CardImpl {§public NecromanticThirst(UUID ownerId) {§super(ownerId, 97, "Necromantic Thirst", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{B}{B}");§this.expansionSetCode = "RAV";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Benefit));§this.addAbility(new EnchantAbility(auraTarget.getTargetName()));§Ability ability = new DealsDamageToAPlayerAttachedTriggeredAbility(§new ReturnFromGraveyardToHandTargetEffect(),§"enchanted creature", true, false, true, TargetController.ANY);§ability.addTarget(new TargetCardInYourGraveyard(new FilterCreatureCard("creature card from your graveyard")));§this.addAbility(ability);§}§public NecromanticThirst(final NecromanticThirst card) {§super(card);§}§@Override§public NecromanticThirst copy() {§return new NecromanticThirst(this);§}§}§
public class RibbonsOfNight extends CardImpl {§public RibbonsOfNight(UUID ownerId) {§super(ownerId, 101, "Ribbons of Night", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{4}{B}");§this.expansionSetCode = "RAV";§Effect effect = new DamageTargetEffect(4);§this.getSpellAbility().addEffect(effect);§effect = new GainLifeEffect(4);§effect.setText("and you gain 4 life");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new ConditionalOneShotEffect(§new DrawCardSourceControllerEffect(1),§new ManaWasSpentCondition(ColoredManaSymbol.U), "If {U} was spent to cast {this}, draw a card"));§}§public RibbonsOfNight(final RibbonsOfNight card) {§super(card);§}§@Override§public RibbonsOfNight copy() {§return new RibbonsOfNight(this);§}§}§
public class ShredMemory extends CardImpl {§public ShredMemory(UUID ownerId) {§super(ownerId, 105, "Shred Memory", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{B}");§this.expansionSetCode = "RAV";§this.getSpellAbility().addEffect(new ExileTargetEffect());§this.getSpellAbility().addTarget(new TargetCardInASingleGraveyard(0, 4, new FilterCard("cards")));§this.addAbility(new TransmuteAbility("{1}{B}{B}"));§}§public ShredMemory(final ShredMemory card) {§super(card);§}§@Override§public ShredMemory copy() {§return new ShredMemory(this);§}§}§
public class ThoughtpickerWitch extends CardImpl {§public ThoughtpickerWitch(UUID ownerId) {§super(ownerId, 109, "Thoughtpicker Witch", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{B}");§this.expansionSetCode = "RAV";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ThoughtpickerWitchEffect(), new GenericManaCost(1));§ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent(new FilterControlledCreaturePermanent("a creature"))));§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§}§public ThoughtpickerWitch(final ThoughtpickerWitch card) {§super(card);§}§@Override§public ThoughtpickerWitch copy() {§return new ThoughtpickerWitch(this);§}§}§class ThoughtpickerWitchEffect extends OneShotEffect {§ThoughtpickerWitchEffect() {§super(Outcome.Exile);§this.staticText = "Look at the top two cards of target opponent's library, then exile one of them";§}§ThoughtpickerWitchEffect(final ThoughtpickerWitchEffect effect) {§super(effect);§}§@Override§public ThoughtpickerWitchEffect copy() {§return new ThoughtpickerWitchEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Player opponent = game.getPlayer(this.getTargetPointer().getFirst(game, source));§if (controller != null && opponent != null) {§Cards cards = new CardsImpl();§int numLooked = Math.min(2, opponent.getLibrary().size());§if (numLooked > 0) {§for (int i = 0; i < numLooked; i++) {§cards.add(opponent.getLibrary().removeFromTop(game));§}§TargetCard target = new TargetCardInLibrary(new FilterCard("card to exile"));§controller.choose(Outcome.Exile, cards, target, game);§Card card = cards.get(target.getFirstTarget(), game);§cards.remove(card);§opponent.moveCardToExileWithInfo(card, null, "", source.getSourceId(), game, Zone.LIBRARY, true);§if (cards.size() == 1) {§card = cards.get(cards.iterator().next(), game);§opponent.moveCardToLibraryWithInfo(card, source.getSourceId(), game, Zone.LIBRARY, true, false);§}§}§return true;§}§return false;§}§}§
public class WarTorchGoblin extends CardImpl {§public WarTorchGoblin(UUID ownerId) {§super(ownerId, 151, "War-Torch Goblin", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "RAV";§this.subtype.add("Goblin");§this.subtype.add("Warrior");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(2), new ColoredManaCost(ColoredManaSymbol.R));§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetCreaturePermanent(new FilterBlockingCreature()));§this.addAbility(ability);§}§public WarTorchGoblin(final WarTorchGoblin card) {§super(card);§}§@Override§public WarTorchGoblin copy() {§return new WarTorchGoblin(this);§}§}§
public class AzoriusCharm extends CardImpl {§public AzoriusCharm(UUID ownerId) {§super(ownerId, 145, "Azorius Charm", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{W}{U}");§this.expansionSetCode = "RTR";§this.getSpellAbility().addEffect(new GainAbilityControlledEffect(LifelinkAbility.getInstance(), Duration.EndOfTurn, new FilterControlledCreaturePermanent("Creatures")));§Mode mode = new Mode();§mode.getEffects().add(new DrawCardSourceControllerEffect(1));§this.getSpellAbility().addMode(mode);§mode = new Mode();§mode.getTargets().add(new TargetAttackingOrBlockingCreature());§mode.getEffects().add(new PutOnLibraryTargetEffect(true));§this.getSpellAbility().addMode(mode);§}§public AzoriusCharm(final AzoriusCharm card) {§super(card);§}§@Override§public AzoriusCharm copy() {§return new AzoriusCharm(this);§}§}§
public class ChromaticLantern extends CardImpl {§public ChromaticLantern(UUID ownerId) {§super(ownerId, 226, "Chromatic Lantern", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "RTR";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityControlledEffect(new AnyColorManaAbility(), Duration.WhileOnBattlefield, new FilterLandPermanent("Lands"), false)));§this.addAbility(new AnyColorManaAbility());§}§public ChromaticLantern(final ChromaticLantern card) {§super(card);§}§@Override§public ChromaticLantern copy() {§return new ChromaticLantern(this);§}§}§
public class DeathsPresence extends CardImpl {§public DeathsPresence(UUID ownerId) {§super(ownerId, 121, "Death's Presence", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{5}{G}");§this.expansionSetCode = "RTR";§this.addAbility(new DeathsPresenceTriggeredAbility());§}§public DeathsPresence(final DeathsPresence card) {§super(card);§}§@Override§public DeathsPresence copy() {§return new DeathsPresence(this);§}§}§class DeathsPresenceTriggeredAbility extends TriggeredAbilityImpl {§public DeathsPresenceTriggeredAbility() {§super(Zone.BATTLEFIELD, null);§}§public DeathsPresenceTriggeredAbility(final DeathsPresenceTriggeredAbility ability) {§super(ability);§}§@Override§public DeathsPresenceTriggeredAbility copy() {§return new DeathsPresenceTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ZONE_CHANGE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (((ZoneChangeEvent) event).getToZone() == Zone.GRAVEYARD§&& ((ZoneChangeEvent) event).getFromZone() == Zone.BATTLEFIELD) {§Permanent permanent = (Permanent) game.getLastKnownInformation(event.getTargetId(), Zone.BATTLEFIELD);§if (permanent != null && permanent.getControllerId().equals(this.getControllerId()) && permanent.getCardType().contains(CardType.CREATURE)) {§this.getTargets().clear();§this.addTarget(new TargetControlledCreaturePermanent());§this.getEffects().clear();§this.addEffect(new AddCountersTargetEffect(CounterType.P1P1.createInstance(permanent.getPower().getValue())));§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever a creature you control dies, put X +1/+1 counters on target creature you control, where X is the power of the creature that died.";§}§}§
public class EyesInTheSkies extends CardImpl {§public EyesInTheSkies(UUID ownerId) {§super(ownerId, 10, "Eyes in the Skies", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{3}{W}");§this.expansionSetCode = "RTR";§this.getSpellAbility().addEffect(new CreateTokenEffect(new BirdToken()));§this.getSpellAbility().addEffect(new PopulateEffect("then"));§}§public EyesInTheSkies(final EyesInTheSkies card) {§super(card);§}§@Override§public EyesInTheSkies copy() {§return new EyesInTheSkies(this);§}§}§
public class GrowingRanks extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature an opponent controls");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public GrowingRanks(UUID ownerId) {§super(ownerId, 217, "Growing Ranks", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{2}{G/W}{G/W}");§this.expansionSetCode = "RTR";§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new PopulateEffect(""), TargetController.YOU, false));§}§public GrowingRanks(final GrowingRanks card) {§super(card);§}§@Override§public GrowingRanks copy() {§return new GrowingRanks(this);§}§}§
public class JudgesFamiliar extends CardImpl {§private static final FilterSpell filter = new FilterSpell("instant or sorcery spell");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.INSTANT),§new CardTypePredicate(CardType.SORCERY)));§}§public JudgesFamiliar(UUID ownerId) {§super(ownerId, 218, "Judge's Familiar", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{W/U}");§this.expansionSetCode = "RTR";§this.subtype.add("Bird");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new CounterUnlessPaysEffect(new GenericManaCost(1)),§new SacrificeSourceCost());§ability.addTarget(new TargetSpell(filter));§this.addAbility(ability);§}§public JudgesFamiliar(final JudgesFamiliar card) {§super(card);§}§@Override§public JudgesFamiliar copy() {§return new JudgesFamiliar(this);§}§}§
public class NivMizzetDracogenius extends CardImpl {§public NivMizzetDracogenius(UUID ownerId) {§super(ownerId, 183, "Niv-Mizzet, Dracogenius", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{2}{U}{U}{R}{R}");§this.expansionSetCode = "RTR";§this.supertype.add("Legendary");§this.subtype.add("Dragon");§this.subtype.add("Wizard");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new DealsDamageToAPlayerTriggeredAbility(new DrawCardSourceControllerEffect(1), true));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1),new ManaCostsImpl("{U}{R}"));§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public NivMizzetDracogenius(final NivMizzetDracogenius card) {§super(card);§}§@Override§public NivMizzetDracogenius copy() {§return new NivMizzetDracogenius(this);§}§}§
public class RakdossReturn extends CardImpl {§public RakdossReturn (UUID ownerId) {§super(ownerId, 188, "Rakdos's Return", Rarity.MYTHIC, new CardType[]{CardType.SORCERY}, "{X}{B}{R}");§this.expansionSetCode = "RTR";§this.getSpellAbility().addEffect(new DamageTargetEffect(new ManacostVariableValue()));§this.getSpellAbility().addEffect(new DiscardTargetEffect(new ManacostVariableValue()));§this.getSpellAbility().addTarget(new TargetOpponent());§}§public RakdossReturn (final RakdossReturn card) {§super(card);§}§@Override§public RakdossReturn copy() {§return new RakdossReturn(this);§}§}§
public class ShriekingAffliction extends CardImpl {§static final String rule = "At the beginning of the upkeep of enchanted creature's controller, that player loses 2 life";§public ShriekingAffliction (UUID ownerId) {§super(ownerId, 76, "Shrieking Affliction", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{B}");§this.expansionSetCode = "RTR";§this.addAbility(new ShriekingAfflictionTriggeredAbility());§}§public ShriekingAffliction (final ShriekingAffliction card) {§super(card);§}§@Override§public ShriekingAffliction copy() {§return new ShriekingAffliction(this);§}§}§class ShriekingAfflictionTriggeredAbility extends TriggeredAbilityImpl {§public ShriekingAfflictionTriggeredAbility() {§super(Zone.BATTLEFIELD, null);§}§public ShriekingAfflictionTriggeredAbility(final ShriekingAfflictionTriggeredAbility ability) {§super(ability);§}§@Override§public ShriekingAfflictionTriggeredAbility copy() {§return new ShriekingAfflictionTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.UPKEEP_STEP_PRE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (game.getOpponents(controllerId).contains(event.getPlayerId())) {§Player player = game.getPlayer(event.getPlayerId());§if (player != null && player.getHand().size() < 2) {§this.getEffects().clear();§ShriekingAfflictionTargetEffect effect = new ShriekingAfflictionTargetEffect();§effect.setTargetPointer(new FixedTarget(player.getId()));§this.addEffect(effect);§return true;§}§}§return false;§}§@Override§public String getRule() {§return "At the beginning of each opponent's upkeep, if that player has one or fewer cards in hand, he or she loses 3 life.";§}§}§class ShriekingAfflictionTargetEffect extends OneShotEffect {§public ShriekingAfflictionTargetEffect() {§super(Outcome.Damage);§staticText = "he or she loses 3 life";§}§public ShriekingAfflictionTargetEffect(final ShriekingAfflictionTargetEffect effect) {§super(effect);§}§@Override§public ShriekingAfflictionTargetEffect copy() {§return new ShriekingAfflictionTargetEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(targetPointer.getFirst(game, source));§if (player != null && player.getHand().size() < 2) {§Permanent sourcePermanent = game.getPermanent(source.getSourceId());§if (sourcePermanent != null) {§game.informPlayers(sourcePermanent.getName() + ": " + player.getLogName() + " loses 3 life");§}§player.loseLife(3, game);§return true;§}§return false;§}§}§
public class StreetSweeper extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("creatures with defender you control");§static{§filter.add(new AbilityPredicate(DefenderAbility.class));§}§public StreetSweeper(UUID ownerId) {§super(ownerId, 234, "Street Sweeper", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{6}");§this.expansionSetCode = "RTR";§this.subtype.add("Construct");§this.power = new MageInt(4);§this.toughness = new MageInt(6);§Ability ability = new AttacksTriggeredAbility(new StreetSweeperDestroyEffect(), false);§ability.addTarget(new TargetLandPermanent());§this.addAbility(ability);§}§public StreetSweeper(final StreetSweeper card) {§super(card);§}§@Override§public StreetSweeper copy() {§return new StreetSweeper(this);§}§}§class StreetSweeperDestroyEffect extends OneShotEffect {§public StreetSweeperDestroyEffect() {§super(Outcome.DestroyPermanent);§}§public StreetSweeperDestroyEffect(final StreetSweeperDestroyEffect effect) {§super(effect);§}§@Override§public StreetSweeperDestroyEffect copy() {§return new StreetSweeperDestroyEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(source.getFirstTarget());§if(permanent != null)§{§LinkedList<UUID> attachments = new LinkedList<>();§attachments.addAll(permanent.getAttachments());§for(UUID uuid : attachments)§{§Permanent aura = game.getPermanent(uuid);§if(aura != null && aura.getSubtype().contains("Aura"))§{§aura.destroy(source.getSourceId(), game, false);§}§}§return true;§}§return false;§}§@Override§public String getText(Mode mode) {§return "destroy all Auras attached to target land";§}§}§
public class TrostaniSelesnyasVoice extends CardImpl {§public TrostaniSelesnyasVoice(UUID ownerId) {§super(ownerId, 206, "Trostani, Selesnya's Voice", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{G}{G}{W}{W}");§this.expansionSetCode = "RTR";§this.supertype.add("Legendary");§this.subtype.add("Dryad");§this.power = new MageInt(2);§this.toughness = new MageInt(5);§this.addAbility(new TrostaniSelesnyasVoiceTriggeredAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PopulateEffect(), new ManaCostsImpl("{1}{G}{W}"));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public TrostaniSelesnyasVoice(final TrostaniSelesnyasVoice card) {§super(card);§}§@Override§public TrostaniSelesnyasVoice copy() {§return new TrostaniSelesnyasVoice(this);§}§}§class TrostaniSelesnyasVoiceTriggeredAbility extends TriggeredAbilityImpl {§public TrostaniSelesnyasVoiceTriggeredAbility() {§super(Zone.BATTLEFIELD, new TrostaniSelesnyasVoiceEffect(), false);§}§public TrostaniSelesnyasVoiceTriggeredAbility(TrostaniSelesnyasVoiceTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ENTERS_THE_BATTLEFIELD;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent permanent = game.getPermanent(event.getTargetId());§if (permanent.getCardType().contains(CardType.CREATURE)§&& permanent.getControllerId().equals(this.controllerId)§&& event.getTargetId() != this.getSourceId()) {§Effect effect = this.getEffects().get(0);§effect.setValue("lifeSource", event.getTargetId());§effect.setValue("zoneChangeCounter", permanent.getZoneChangeCounter(game));§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever another creature enters the battlefield under your control, " + super.getRule();§}§@Override§public TrostaniSelesnyasVoiceTriggeredAbility copy() {§return new TrostaniSelesnyasVoiceTriggeredAbility(this);§}§}§class TrostaniSelesnyasVoiceEffect extends OneShotEffect {§public TrostaniSelesnyasVoiceEffect() {§super(Outcome.GainLife);§staticText = "you gain life equal to that creature's toughness";§}§public TrostaniSelesnyasVoiceEffect(final TrostaniSelesnyasVoiceEffect effect) {§super(effect);§}§@Override§public TrostaniSelesnyasVoiceEffect copy() {§return new TrostaniSelesnyasVoiceEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§UUID creatureId = (UUID) getValue("lifeSource");§Integer zoneChangeCounter = (Integer) getValue("zoneChangeCounter");§Permanent creature = game.getPermanent(creatureId);§if (creature == null || creature.getZoneChangeCounter(game) != zoneChangeCounter) {§creature = (Permanent) game.getLastKnownInformation(creatureId, Zone.BATTLEFIELD, zoneChangeCounter);§}§if (creature != null) {§int amount = creature.getToughness().getValue();§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§player.gainLife(amount, game);§}§return true;§}§return false;§}§}§
public class DwarvenWarriors extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature with power 2 or less");§static {§filter.add(new PowerPredicate(ComparisonType.LessThan, 3));§}§public DwarvenWarriors(UUID ownerId) {§super(ownerId, 143, "Dwarven Warriors", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "3ED";§this.subtype.add("Dwarf");§this.subtype.add("Warrior");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CantBeBlockedTargetEffect(), new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public DwarvenWarriors(final DwarvenWarriors card) {§super(card);§}§@Override§public DwarvenWarriors copy() {§return new DwarvenWarriors(this);§}§}§
public class BattleRattleShaman extends CardImpl {§public BattleRattleShaman(UUID ownerId) {§super(ownerId, 136, "Battle-Rattle Shaman", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "ROE";§this.subtype.add("Goblin");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new BeginningOfCombatTriggeredAbility(Zone.BATTLEFIELD, new BoostTargetEffect(2, 0, Duration.EndOfTurn), TargetController.YOU, true, false);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public BattleRattleShaman(final BattleRattleShaman card) {§super(card);§}§@Override§public BattleRattleShaman copy() {§return new BattleRattleShaman(this);§}§}§
public class DeathCultist extends CardImpl {§public DeathCultist(UUID ownerId) {§super(ownerId, 105, "Death Cultist", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{B}");§this.expansionSetCode = "ROE";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new LoseLifeTargetEffect(1),§new SacrificeSourceCost());§ability.addEffect(new GainLifeEffect(1));§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public DeathCultist(final DeathCultist card) {§super(card);§}§@Override§public DeathCultist copy() {§return new DeathCultist(this);§}§}§
public class EnatuGolem extends CardImpl {§public EnatuGolem(UUID ownerId) {§super(ownerId, 217, "Enatu Golem", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{6}");§this.expansionSetCode = "ROE";§this.subtype.add("Golem");§this.power = new MageInt(3);§this.toughness = new MageInt(5);§this.addAbility(new DiesTriggeredAbility(new GainLifeEffect(4), false));§}§public EnatuGolem(final EnatuGolem card) {§super(card);§}§@Override§public EnatuGolem copy() {§return new EnatuGolem(this);§}§}§
public class GrowthSpasm extends CardImpl {§private static final FilterBasicLandCard filter = new FilterBasicLandCard();§public GrowthSpasm(UUID ownerId) {§super(ownerId, 186, "Growth Spasm", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{G}");§this.expansionSetCode = "ROE";§this.getSpellAbility().addEffect(new SearchLibraryPutInPlayEffect(new TargetCardInLibrary(filter), true));§this.getSpellAbility().addEffect(new CreateTokenEffect(new EldraziSpawnToken()));§}§public GrowthSpasm(final GrowthSpasm card) {§super(card);§}§@Override§public GrowthSpasm copy() {§return new GrowthSpasm(this);§}§}§
public class KorLineSlinger extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature with power 3 or less");§static {§filter.add(new PowerPredicate(ComparisonType.LessThan, 4));§}§public KorLineSlinger(UUID ownerId) {§super(ownerId, 30, "Kor Line-Slinger", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "ROE";§this.subtype.add("Kor");§this.subtype.add("Scout");§this.power = new MageInt(0);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TapTargetEffect(), new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public KorLineSlinger(final KorLineSlinger card) {§super(card);§}§@Override§public KorLineSlinger copy() {§return new KorLineSlinger(this);§}§}§
public class MightOfTheMasses extends CardImpl {§public MightOfTheMasses(UUID ownerId) {§super(ownerId, 196, "Might of the Masses", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{G}");§this.expansionSetCode = "ROE";§PermanentsOnBattlefieldCount value = new PermanentsOnBattlefieldCount(new FilterControlledCreaturePermanent());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new BoostTargetEffect(value, value, Duration.EndOfTurn, true));§}§public MightOfTheMasses(final MightOfTheMasses card) {§super(card);§}§@Override§public MightOfTheMasses copy() {§return new MightOfTheMasses(this);§}§}§
public class PelakkaWurm extends CardImpl {§public PelakkaWurm(UUID ownerId) {§super(ownerId, 204, "Pelakka Wurm", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{G}{G}{G}");§this.expansionSetCode = "ROE";§this.subtype.add("Wurm");§this.power = new MageInt(7);§this.toughness = new MageInt(7);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new GainLifeEffect(7), false));§this.addAbility(new DiesTriggeredAbility(new DrawCardSourceControllerEffect(1), false));§}§public PelakkaWurm(final PelakkaWurm card) {§super(card);§}§@Override§public PelakkaWurm copy() {§return new PelakkaWurm(this);§}§}§
public class SeaGateOracle extends CardImpl {§public SeaGateOracle(UUID ownerId) {§super(ownerId, 85, "Sea Gate Oracle", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "ROE";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§this.addAbility(new EntersBattlefieldTriggeredAbility(new LookLibraryAndPickControllerEffect(new StaticValue(2), false, new StaticValue(1), new FilterCard(), Zone.LIBRARY, false, false), false));§}§public SeaGateOracle(final SeaGateOracle card) {§super(card);§}§@Override§public SeaGateOracle copy() {§return new SeaGateOracle(this);§}§}§
public class StomperCub extends CardImpl {§public StomperCub (UUID ownerId) {§super(ownerId, 210, "Stomper Cub", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{G}{G}");§this.expansionSetCode = "ROE";§this.subtype.add("Beast");§this.power = new MageInt(5);§this.toughness = new MageInt(3);§this.addAbility(TrampleAbility.getInstance());§}§public StomperCub (final StomperCub card) {§super(card);§}§@Override§public StomperCub copy() {§return new StomperCub(this);§}§}§
public class VentSentinel extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("creatures with defender you control");§static{§filter.add(new AbilityPredicate(DefenderAbility.class));§}§public VentSentinel(UUID ownerId) {§super(ownerId, 171, "Vent Sentinel", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "ROE";§this.subtype.add("Elemental");§this.power = new MageInt(2);§this.toughness = new MageInt(4);§this.addAbility(DefenderAbility.getInstance());§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(new PermanentsOnBattlefieldCount(filter)), new ManaCostsImpl("{1}{R}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public VentSentinel(final VentSentinel card) {§super(card);§}§@Override§public VentSentinel copy() {§return new VentSentinel(this);§}§}§
public class BriarknitKami extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public BriarknitKami(UUID ownerId) {§super(ownerId, 124, "Briarknit Kami", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{G}{G}");§this.expansionSetCode = "SOK";§this.subtype.add("Spirit");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§Ability ability = new SpellCastControllerTriggeredAbility(new AddCountersTargetEffect(CounterType.P1P1.createInstance()), filter, false);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public BriarknitKami(final BriarknitKami card) {§super(card);§}§@Override§public BriarknitKami copy() {§return new BriarknitKami(this);§}§}§
public class EbonyOwlNetsuke extends CardImpl {§public EbonyOwlNetsuke(UUID ownerId) {§super(ownerId, 154, "Ebony Owl Netsuke", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "SOK";§this.addAbility(new EbonyOwlNetsukeTriggeredAbility(new DamageTargetEffect(4, true)));§}§public EbonyOwlNetsuke(final EbonyOwlNetsuke card) {§super(card);§}§@Override§public EbonyOwlNetsuke copy() {§return new EbonyOwlNetsuke(this);§}§}§class EbonyOwlNetsukeTriggeredAbility extends TriggeredAbilityImpl {§EbonyOwlNetsukeTriggeredAbility(Effect effect) {§super(Zone.BATTLEFIELD, effect, false);§}§EbonyOwlNetsukeTriggeredAbility(final EbonyOwlNetsukeTriggeredAbility ability) {§super(ability);§}§@Override§public EbonyOwlNetsukeTriggeredAbility copy() {§return new EbonyOwlNetsukeTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.UPKEEP_STEP_PRE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (game.getOpponents(controllerId).contains(event.getPlayerId())) {§Player player = game.getPlayer(event.getPlayerId());§if (player != null) {§for (Effect effect: getEffects() ) {§effect.setTargetPointer(new FixedTarget(player.getId()));§}§return true;§}§}§return false;§}§@Override§public boolean checkInterveningIfClause(Game game) {§Player player = game.getPlayer(game.getActivePlayerId());§return player != null && player.getHand().size() >= 7;§}§@Override§public String getRule() {§return "At the beginning of each opponent's upkeep, if that player has seven or more cards in hand, {this} deals 4 damage to him or her.";§}§}§
public class GnatMiser extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("blue creature");§static {§filter.add(new CardTypePredicate(CardType.ARTIFACT));§}§public GnatMiser(UUID ownerId) {§super(ownerId, 70, "Gnat Miser", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{B}");§this.expansionSetCode = "SOK";§this.subtype.add("Rat");§this.subtype.add("Shaman");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD,§new MaximumHandSizeControllerEffect(1, Duration.WhileOnBattlefield, HandSizeModification.REDUCE, TargetController.OPPONENT)));§}§public GnatMiser(final GnatMiser card) {§super(card);§}§@Override§public GnatMiser copy() {§return new GnatMiser(this);§}§}§
public class KahoMinamoHistorian extends CardImpl {§public KahoMinamoHistorian(UUID ownerId) {§super(ownerId, 41, "Kaho, Minamo Historian", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{U}{U}");§this.expansionSetCode = "SOK";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new EntersBattlefieldTriggeredAbility(new KahoMinamoHistorianEffect(), false));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new KahoMinamoHistorianCastEffect(), new ManaCostsImpl("{X}"));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public KahoMinamoHistorian(final KahoMinamoHistorian card) {§super(card);§}§@Override§public KahoMinamoHistorian copy() {§return new KahoMinamoHistorian(this);§}§}§class KahoMinamoHistorianEffect extends SearchEffect {§private static final FilterCard filter = new FilterCard("up to three instant cards");§static {§filter.add(new CardTypePredicate(CardType.INSTANT));§}§public KahoMinamoHistorianEffect() {§super(new TargetCardInLibrary(0, 3, filter), Outcome.Benefit);§this.staticText = "search your library for up to three instant cards and exile them. Then shuffle your library";§}§public KahoMinamoHistorianEffect(final KahoMinamoHistorianEffect effect) {§super(effect);§}§@Override§public KahoMinamoHistorianEffect copy() {§return new KahoMinamoHistorianEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = game.getObject(source.getSourceId());§if (controller != null && sourceObject != null) {§if (controller.searchLibrary(target, game)) {§UUID exileZone = CardUtil.getCardExileZoneId(game, source);§if (target.getTargets().size() > 0) {§for (UUID cardId : target.getTargets()) {§Card card = controller.getLibrary().getCard(cardId, game);§if (card != null) {§controller.moveCardToExileWithInfo(card, exileZone, sourceObject.getIdName(), source.getSourceId(), game, Zone.LIBRARY, true);§}§}§}§}§controller.shuffleLibrary(game);§return true;§}§return false;§}§}§class KahoMinamoHistorianCastEffect extends OneShotEffect {§public KahoMinamoHistorianCastEffect() {§super(Outcome.PlayForFree);§this.staticText = "you may cast a card with converted mana cost X exiled with {this} without paying its mana cost";§}§public KahoMinamoHistorianCastEffect(final KahoMinamoHistorianCastEffect effect) {§super(effect);§}§@Override§public KahoMinamoHistorianCastEffect copy() {§return new KahoMinamoHistorianCastEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§FilterCard filter = new FilterCard();§filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.Equal, source.getManaCostsToPay().getX()));§TargetCardInExile target = new TargetCardInExile(filter, CardUtil.getCardExileZoneId(game, source));§Cards cards = game.getExile().getExileZone(CardUtil.getCardExileZoneId(game, source));§if (cards.size() > 0 && controller.choose(Outcome.PlayForFree, cards, target, game)) {§Card card = game.getCard(target.getFirstTarget());§if (card != null) {§game.getExile().removeCard(card, game);§controller.cast(card.getSpellAbility(), game, true);§}§}§return true;§}§return false;§}§}§
public class MeasureOfWickedness extends CardImpl {§private static final FilterCard filter = new FilterCard("another card");§static {§filter.add(new AnotherCardPredicate());§}§public MeasureOfWickedness(UUID ownerId) {§super(ownerId, 82, "Measure of Wickedness", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{3}{B}");§this.expansionSetCode = "SOK";§Ability ability = new BeginningOfEndStepTriggeredAbility(Zone.BATTLEFIELD, new SacrificeSourceEffect(), TargetController.YOU, null, false);§Effect effect = new LoseLifeSourceControllerEffect(8);§effect.setText("and you lose 8 life");§ability.addEffect(effect);§this.addAbility(ability);§ability = new PutCardIntoGraveFromAnywhereAllTriggeredAbility(§new MeasureOfWickednessControlSourceEffect(), false, filter, TargetController.YOU);§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§}§public MeasureOfWickedness(final MeasureOfWickedness card) {§super(card);§}§@Override§public MeasureOfWickedness copy() {§return new MeasureOfWickedness(this);§}§}§class MeasureOfWickednessControlSourceEffect extends ContinuousEffectImpl {§public MeasureOfWickednessControlSourceEffect() {§super(Duration.Custom, Layer.ControlChangingEffects_2, SubLayer.NA, Outcome.GainControl);§staticText = "target opponent gains control of {this}";§}§public MeasureOfWickednessControlSourceEffect(final MeasureOfWickednessControlSourceEffect effect) {§super(effect);§}§@Override§public MeasureOfWickednessControlSourceEffect copy() {§return new MeasureOfWickednessControlSourceEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player targetOpponent = game.getPlayer(source.getFirstTarget());§Permanent permanent = (Permanent) source.getSourceObjectIfItStillExists(game);§if (permanent != null && targetOpponent != null) {§permanent.changeControllerId(targetOpponent.getId(), game);§} else {§discard();§}§return true;§}§}§
public class OppressiveWill extends CardImpl {§public OppressiveWill(UUID ownerId) {§super(ownerId, 50, "Oppressive Will", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{U}");§this.expansionSetCode = "SOK";§this.getSpellAbility().addEffect(new SpellSyphonEffect());§this.getSpellAbility().addTarget(new TargetSpell());§}§public OppressiveWill(final OppressiveWill card) {§super(card);§}§@Override§public OppressiveWill copy() {§return new OppressiveWill(this);§}§}§class SpellSyphonEffect extends OneShotEffect {§public SpellSyphonEffect() {§super(Outcome.Benefit);§}§public SpellSyphonEffect(final SpellSyphonEffect effect) {§super(effect);§}§@Override§public SpellSyphonEffect copy() {§return new SpellSyphonEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§StackObject spell = game.getStack().getStackObject(targetPointer.getFirst(game, source));§MageObject sourceObject = game.getObject(source.getSourceId());§if (sourceObject != null && spell != null) {§Player player = game.getPlayer(spell.getControllerId());§Player controller = game.getPlayer(source.getControllerId());§if (player != null && controller != null) {§int amount = controller.getHand().size();§if (amount > 0) {§GenericManaCost cost = new GenericManaCost(amount);§if (!cost.pay(source, game, spell.getControllerId(), spell.getControllerId(), false)) {§game.informPlayers(sourceObject.getLogName() + ": cost wasn't payed - countering target spell.");§return game.getStack().counter(source.getFirstTarget(), source.getSourceId(), game);§}§}§return true;§}§}§return false;§}§@Override§public String getText(Mode mode) {§return "Counter target spell unless its controller pays {1} for each card in your hand";§}§}§
public class SakuraTribeScout extends CardImpl {§public SakuraTribeScout(UUID ownerId) {§super(ownerId, 144, "Sakura-Tribe Scout", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "SOK";§this.subtype.add("Snake");§this.subtype.add("Shaman");§this.subtype.add("Scout");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PutLandFromHandOntoBattlefieldEffect(), new TapSourceCost());§ability.addTarget(new TargetCardInHand(new FilterLandCard()));§this.addAbility(ability);§}§public SakuraTribeScout(final SakuraTribeScout card) {§super(card);§}§@Override§public SakuraTribeScout copy() {§return new SakuraTribeScout(this);§}§}§
public class SoratamiCloudChariot extends CardImpl {§public SoratamiCloudChariot(UUID ownerId) {§super(ownerId, 160, "Soratami Cloud Chariot", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{5}");§this.expansionSetCode = "SOK";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilityTargetEffect(FlyingAbility.getInstance(), Duration.EndOfTurn), new GenericManaCost(2));§ability.addTarget(new TargetControlledCreaturePermanent());§this.addAbility(ability);§Effect effect = new PreventDamageToTargetEffect(Duration.EndOfTurn, true);§effect.setText("Prevent all combat damage that would be dealt to");§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl("{2}"));§effect = new PreventDamageByTargetEffect(Duration.EndOfTurn, true);§effect.setText("and dealt by target creature you control this turn.");§ability.addEffect(effect);§ability.addTarget(new TargetControlledCreaturePermanent());§this.addAbility(ability);§}§public SoratamiCloudChariot(final SoratamiCloudChariot card) {§super(card);§}§@Override§public SoratamiCloudChariot copy() {§return new SoratamiCloudChariot(this);§}§}§
public class AssaultStrobe extends CardImpl {§public AssaultStrobe (UUID ownerId) {§super(ownerId, 82, "Assault Strobe", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{R}");§this.expansionSetCode = "SOM";§this.color.setRed(true);§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(DoubleStrikeAbility.getInstance(), Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public AssaultStrobe (final AssaultStrobe card) {§super(card);§}§@Override§public AssaultStrobe copy() {§return new AssaultStrobe(this);§}§}§
public class CerebralEruption extends CardImpl {§public CerebralEruption(UUID ownerId) {§super(ownerId, 86, "Cerebral Eruption", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{2}{R}{R}");§this.expansionSetCode = "SOM";§this.getSpellAbility().addTarget(new TargetOpponent());§this.getSpellAbility().addEffect(new CerebralEruptionEffect());§}§public CerebralEruption(final CerebralEruption card) {§super(card);§}§@Override§public CerebralEruption copy() {§return new CerebralEruption(this);§}§}§class CerebralEruptionEffect extends OneShotEffect {§private static FilterPermanent filter = new FilterCreaturePermanent();§CerebralEruptionEffect() {§super(Outcome.Damage);§staticText = "Target opponent reveals the top card of his or her library. {this} deals damage equal to the revealed card's converted mana cost to that player and each creature he or she controls. If a land card is revealed this way, return {this} to its owner's hand";§}§CerebralEruptionEffect(final CerebralEruptionEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getFirstTarget());§MageObject sourceObject = game.getObject(source.getSourceId());§if (player != null && sourceObject != null && player.getLibrary().size() > 0) {§Card card = player.getLibrary().getFromTop(game);§Cards cards = new CardsImpl(card);§player.revealCards(sourceObject.getIdName(), cards, game);§game.getState().setValue(source.getSourceId().toString(), card);§int damage = card.getManaCost().convertedManaCost();§player.damage(damage, source.getSourceId(), game, false, true);§for (Permanent perm : game.getBattlefield().getAllActivePermanents(filter, player.getId(), game)) {§perm.damage(damage, source.getSourceId(), game, false, true);§}§if (card.getCardType().contains(CardType.LAND)) {§Card spellCard = game.getStack().getSpell(source.getSourceId()).getCard();§if (spellCard != null) {§player.moveCards(spellCard, null, Zone.HAND, source, game);§}§}§return true;§}§return false;§}§@Override§public CerebralEruptionEffect copy() {§return new CerebralEruptionEffect(this);§}§}§
public class Disperse extends CardImpl {§public Disperse (UUID ownerId) {§super(ownerId, 31, "Disperse", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "SOM";§this.getSpellAbility().addTarget(new TargetNonlandPermanent());§this.getSpellAbility().addEffect(new ReturnToHandTargetEffect());§}§public Disperse (final Disperse card) {§super(card);§}§@Override§public Disperse copy() {§return new Disperse(this);§}§}§
public class GenesisWave extends CardImpl {§public GenesisWave(UUID ownerId) {§super(ownerId, 122, "Genesis Wave", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{X}{G}{G}{G}");§this.expansionSetCode = "SOM";§this.getSpellAbility().addEffect(new GenesisWaveEffect());§}§public GenesisWave(final GenesisWave card) {§super(card);§}§@Override§public GenesisWave copy() {§return new GenesisWave(this);§}§}§class GenesisWaveEffect extends OneShotEffect {§public GenesisWaveEffect() {§super(Outcome.PutCardInPlay);§staticText = "Reveal the top X cards of your library. You may put any number of permanent cards with converted mana cost X or less from among them onto the battlefield. Then put all cards revealed this way that weren't put onto the battlefield into your graveyard";§}§public GenesisWaveEffect(final GenesisWaveEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = game.getObject(source.getSourceId());§if (controller == null || sourceObject == null) {§return false;§}§Cards cards = new CardsImpl();§int xValue = source.getManaCostsToPay().getX();§int numberCards = Math.min(controller.getLibrary().size(), xValue);§for (int i = 0; i < numberCards; i++) {§Card card = controller.getLibrary().removeFromTop(game);§cards.add(card);§}§if (cards.size() > 0) {§controller.revealCards(sourceObject.getIdName(), cards, game);§FilterCard filter = new FilterCard("cards with converted mana cost " + xValue + " or less to put onto the battlefield");§filter.add(new ConvertedManaCostPredicate(ComparisonType.LessThan, xValue + 1));§filter.add(§Predicates.or(new CardTypePredicate(CardType.ARTIFACT),§new CardTypePredicate(CardType.CREATURE),§new CardTypePredicate(CardType.ENCHANTMENT),§new CardTypePredicate(CardType.LAND),§new CardTypePredicate(CardType.PLANESWALKER)§));§TargetCard target1 = new TargetCard(0, Integer.MAX_VALUE, Zone.LIBRARY, filter);§target1.setRequired(false);§controller.choose(Outcome.PutCardInPlay, cards, target1, game);§Set<Card> toBattlefield = new LinkedHashSet<>();§for (UUID cardId : target1.getTargets()) {§Card card = cards.get(cardId, game);§if (card != null) {§cards.remove(card);§toBattlefield.add(card);§}§}§controller.moveCards(toBattlefield, Zone.BATTLEFIELD, source, game, false, false, false, null);§controller.moveCards(cards, Zone.LIBRARY, Zone.GRAVEYARD, source, game);§}§return true;§}§@Override§public GenesisWaveEffect copy() {§return new GenesisWaveEffect(this);§}§}§
public class HorizonSpellbomb extends CardImpl {§private static FilterBasicLandCard filter = new FilterBasicLandCard();§public HorizonSpellbomb(UUID ownerId) {§super(ownerId, 165, "Horizon Spellbomb", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "SOM";§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new SearchLibraryPutInHandEffect(new TargetCardInLibrary(filter), true),§new ManaCostsImpl("{2}"));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§this.addAbility(new DiesTriggeredAbility(new DoIfCostPaid(new DrawCardSourceControllerEffect(1), new ManaCostsImpl("{G}"))));§}§public HorizonSpellbomb(final HorizonSpellbomb card) {§super(card);§}§@Override§public HorizonSpellbomb copy() {§return new HorizonSpellbomb(this);§}§}§
public class LuxCannon extends CardImpl {§public LuxCannon (UUID ownerId) {§super(ownerId, 173, "Lux Cannon", Rarity.MYTHIC, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "SOM";§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.CHARGE.createInstance()), new TapSourceCost()));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new TapSourceCost());§ability.addCost(new RemoveCountersSourceCost(CounterType.CHARGE.createInstance(3)));§ability.addTarget(new TargetPermanent());§this.addAbility(ability);§}§public LuxCannon (final LuxCannon card) {§super(card);§}§@Override§public LuxCannon copy() {§return new LuxCannon(this);§}§}§
public class NecroticOoze extends CardImpl {§public NecroticOoze(UUID ownerId) {§super(ownerId, 72, "Necrotic Ooze", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{B}{B}");§this.expansionSetCode = "SOM";§this.subtype.add("Ooze");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new NecroticOozeEffect()));§}§public NecroticOoze(final NecroticOoze card) {§super(card);§}§@Override§public NecroticOoze copy() {§return new NecroticOoze(this);§}§class NecroticOozeEffect extends ContinuousEffectImpl {§public NecroticOozeEffect() {§super(Duration.WhileOnBattlefield, Layer.AbilityAddingRemovingEffects_6, SubLayer.NA, Outcome.AddAbility);§staticText = "As long as {this} is on the battlefield, it has all activated abilities of all creature cards in all graveyards";§}§public NecroticOozeEffect(final NecroticOozeEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent perm = game.getPermanent(source.getSourceId());§if (perm != null) {§for (UUID playerId : game.getState().getPlayersInRange(source.getControllerId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§for (Card card : player.getGraveyard().getCards(game)) {§if (card.getCardType().contains(CardType.CREATURE)) {§for (Ability ability : card.getAbilities()) {§if (ability instanceof ActivatedAbility) {§perm.addAbility(ability, game);§}§}§}§}§}§}§return true;§}§return false;§}§@Override§public NecroticOozeEffect copy() {§return new NecroticOozeEffect(this);§}§@Override§public Set<UUID> isDependentTo(List<ContinuousEffect> allEffectsInLayer) {§Set<UUID> dependentTo = null;§for (ContinuousEffect effect : allEffectsInLayer) {§if (YixlidJailer.class.equals(effect.getClass().getEnclosingClass())) {§if (dependentTo == null) {§dependentTo = new HashSet<>();§}§dependentTo.add(effect.getId());§}§}§return dependentTo;§}§}§}§
public class Putrefax extends CardImpl {§public Putrefax (UUID ownerId) {§super(ownerId, 126, "Putrefax", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{G}{G}");§this.expansionSetCode = "SOM";§this.subtype.add("Horror");§this.power = new MageInt(5);§this.toughness = new MageInt(3);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(HasteAbility.getInstance());§this.addAbility(InfectAbility.getInstance());§this.addAbility(new OnEventTriggeredAbility(GameEvent.EventType.END_TURN_STEP_PRE, "beginning of the end step", true, new SacrificeSourceEffect()));§}§public Putrefax (final Putrefax card) {§super(card);§}§@Override§public Putrefax copy() {§return new Putrefax(this);§}§}§
public class Skinrender extends CardImpl {§public Skinrender(UUID ownerId) {§super(ownerId, 78, "Skinrender", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{B}{B}");§this.expansionSetCode = "SOM";§this.subtype.add("Zombie");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§Effect putCountersEffect = new AddCountersTargetEffect(CounterType.M1M1.createInstance(3), Outcome.UnboostCreature);§Ability ability = new EntersBattlefieldTriggeredAbility(putCountersEffect, false);§Target target = new TargetCreaturePermanent();§ability.addTarget(target);§this.addAbility(ability);§}§public Skinrender(final Skinrender card) {§super(card);§}§@Override§public Skinrender copy() {§return new Skinrender(this);§}§}§
public class TelJiladDefiance extends CardImpl {§public TelJiladDefiance(UUID ownerId) {§super(ownerId, 129, "Tel-Jilad Defiance", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{G}");§this.expansionSetCode = "SOM";§this.getSpellAbility().addEffect(new GainProtectionFromTypeTargetEffect(Duration.EndOfTurn, new FilterArtifactCard("artifacts")));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));§}§public TelJiladDefiance(final TelJiladDefiance card) {§super(card);§}§@Override§public TelJiladDefiance copy() {§return new TelJiladDefiance(this);§}§}§
public class VectorAsp extends CardImpl {§public VectorAsp (UUID ownerId) {§super(ownerId, 219, "Vector Asp", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{1}");§this.expansionSetCode = "SOM";§this.subtype.add("Snake");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(InfectAbility.getInstance(), Duration.EndOfTurn), new ManaCostsImpl("{B}")));§}§public VectorAsp (final VectorAsp card) {§super(card);§}§@Override§public VectorAsp copy() {§return new VectorAsp(this);§}§}§
public class AvenLiberator extends CardImpl {§public AvenLiberator(UUID ownerId) {§super(ownerId, 4, "Aven Liberator", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}{W}");§this.expansionSetCode = "SCG";§this.subtype.add("Bird");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new MorphAbility(this, new ManaCostsImpl("{3}{W}")));§Ability ability = new TurnedFaceUpSourceTriggeredAbility(new GainProtectionFromColorTargetEffect(Duration.EndOfTurn));§ability.addTarget(new TargetControlledCreaturePermanent());§this.addAbility(ability);§}§public AvenLiberator(final AvenLiberator card) {§super(card);§}§@Override§public AvenLiberator copy() {§return new AvenLiberator(this);§}§}§
public class Edgewalker extends CardImpl {§private static final FilterCard filter = new FilterCard("Cleric spells");§static {§filter.add(new SubtypePredicate("Cleric"));§}§public Edgewalker(UUID ownerId) {§super(ownerId, 137, "Edgewalker", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{W}{B}");§this.expansionSetCode = "SCG";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new SpellsCostReductionControllerEffect(filter, new ManaCostsImpl<>("{W}{B}"))));§}§public Edgewalker(final Edgewalker card) {§super(card);§}§@Override§public Edgewalker copy() {§return new Edgewalker(this);§}§}§
public class OneWithNature extends CardImpl {§public OneWithNature(UUID ownerId) {§super(ownerId, 125, "One with Nature", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{G}");§this.expansionSetCode = "SCG";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.PutLandInPlay));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§ability = new DealsDamageToAPlayerAttachedTriggeredAbility(§new SearchLibraryPutInPlayEffect(new TargetCardInLibrary(new FilterBasicLandCard()), true, Outcome.PutLandInPlay),§"enchanted creature", true, false, true, TargetController.ANY);§this.addAbility(ability);§}§public OneWithNature(final OneWithNature card) {§super(card);§}§@Override§public OneWithNature copy() {§return new OneWithNature(this);§}§}§
public class ThundercloudElemental extends CardImpl {§private static final FilterCreaturePermanent toughnessFilter = new FilterCreaturePermanent("creatures with toughness 2 or less");§private static final FilterCreaturePermanent flyingFilter = new FilterCreaturePermanent("All other creatures");§static {§toughnessFilter.add(new ToughnessPredicate(Filter.ComparisonType.LessThan, 3));§flyingFilter.add(new AnotherPredicate());§}§public ThundercloudElemental(UUID ownerId) {§super(ownerId, 54, "Thundercloud Elemental", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{5}{U}{U}");§this.expansionSetCode = "SCG";§this.subtype.add("Elemental");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new TapAllEffect(toughnessFilter), new ManaCostsImpl("{3}{U}")));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new LoseAbilityAllEffect(flyingFilter, FlyingAbility.getInstance(), Duration.EndOfTurn), new ManaCostsImpl("{3}{U}")));§}§public ThundercloudElemental(final ThundercloudElemental card) {§super(card);§}§@Override§public ThundercloudElemental copy() {§return new ThundercloudElemental(this);§}§}§
public class CharcoalDiamond extends CardImpl {§public CharcoalDiamond(UUID ownerId) {§super(ownerId, 289, "Charcoal Diamond", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "7ED";§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new BlackManaAbility());§}§public CharcoalDiamond(final CharcoalDiamond card) {§super(card);§}§@Override§public CharcoalDiamond copy() {§return new CharcoalDiamond(this);§}§}§
public class HealingSalve extends CardImpl {§public HealingSalve(UUID ownerId) {§super(ownerId, 18, "Healing Salve", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{W}");§this.expansionSetCode = "7ED";§this.getSpellAbility().addEffect(new GainLifeTargetEffect(3));§this.getSpellAbility().addTarget(new TargetPlayer());§Mode mode = new Mode();§mode.getEffects().add(new PreventDamageToTargetEffect(Duration.EndOfTurn, 3));§mode.getTargets().add(new TargetCreatureOrPlayer());§this.getSpellAbility().addMode(mode);§}§public HealingSalve(final HealingSalve card) {§super(card);§}§@Override§public HealingSalve copy() {§return new HealingSalve(this);§}§}§
public class RaiseDead extends CardImpl {§private static FilterCreatureCard filter = new FilterCreatureCard("creature card from your graveyard");§public RaiseDead(UUID ownerId) {§super(ownerId, 157, "Raise Dead", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{B}");§this.expansionSetCode = "7ED";§this.getSpellAbility().addTarget(new TargetCardInYourGraveyard(filter));§this.getSpellAbility().addEffect(new ReturnToHandTargetEffect());§}§public RaiseDead(final RaiseDead card) {§super(card);§}§@Override§public RaiseDead copy() {§return new RaiseDead(this);§}§}§
public class TrainedOrgg extends CardImpl {§public TrainedOrgg(UUID ownerId) {§super(ownerId, 224, "Trained Orgg", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{6}{R}");§this.expansionSetCode = "7ED";§this.subtype.add("Orgg");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§}§public TrainedOrgg(final TrainedOrgg card) {§super(card);§}§@Override§public TrainedOrgg copy() {§return new TrainedOrgg(this);§}§}§
public class BeseechTheQueen extends CardImpl {§private static final FilterCard filter = new FilterCard("card with converted mana cost less than or equal to the number of lands you control");§static{§filter.add(new BeseechTheQueenPredicate());§}§public BeseechTheQueen(UUID ownerId) {§super(ownerId, 57, "Beseech the Queen", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{2/B}{2/B}{2/B}");§this.expansionSetCode = "SHM";§this.getSpellAbility().addEffect(new SearchLibraryPutInHandEffect(new TargetCardInLibrary(filter), true, true));§}§public BeseechTheQueen(final BeseechTheQueen card) {§super(card);§}§@Override§public BeseechTheQueen copy() {§return new BeseechTheQueen(this);§}§}§class BeseechTheQueenPredicate implements Predicate<Card> {§@Override§public final boolean apply(Card input, Game game) {§if(input.getManaCost().convertedManaCost() <= game.getBattlefield().getAllActivePermanents(new FilterControlledLandPermanent(), input.getOwnerId(), game).size()){§return true;§}§return false;§}§@Override§public String toString() {§return "card with converted mana cost less than or equal to the number of lands you control";§}§}§
public class ConsignToDream extends CardImpl {§public ConsignToDream(UUID ownerId) {§super(ownerId, 32, "Consign to Dream", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{U}");§this.expansionSetCode = "SHM";§this.getSpellAbility().addEffect(new ConsignToDreamEffect());§this.getSpellAbility().addTarget(new TargetPermanent());§}§public ConsignToDream(final ConsignToDream card) {§super(card);§}§@Override§public ConsignToDream copy() {§return new ConsignToDream(this);§}§}§class ConsignToDreamEffect extends OneShotEffect {§boolean applied = false;§public ConsignToDreamEffect() {§super(Outcome.ReturnToHand);§this.staticText = "Return target permanent to its owner's hand. If that permanent is red or green, put it on top of its owner's library instead";§}§public ConsignToDreamEffect(final ConsignToDreamEffect effect) {§super(effect);§}§@Override§public ConsignToDreamEffect copy() {§return new ConsignToDreamEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent target = game.getPermanent(source.getFirstTarget());§if (target != null) {§if (target.getColor(game).contains(ObjectColor.RED)§|| target.getColor(game).contains(ObjectColor.GREEN)) {§applied = target.moveToZone(Zone.LIBRARY, source.getSourceId(), game, true);§} else {§applied = target.moveToZone(Zone.HAND, source.getSourceId(), game, false);§}§}§return applied;§}§}§
public class DroveOfElves extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("green permanents you control");§static {§filter.add(new ColorPredicate(ObjectColor.GREEN));§}§public DroveOfElves(UUID ownerId) {§super(ownerId, 112, "Drove of Elves", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "SHM";§this.subtype.add("Elf");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(HexproofAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.ALL, new SetPowerToughnessSourceEffect(new PermanentsOnBattlefieldCount(filter), Duration.EndOfGame)));§}§public DroveOfElves(final DroveOfElves card) {§super(card);§}§@Override§public DroveOfElves copy() {§return new DroveOfElves(this);§}§}§
public class FossilFind extends CardImpl {§public FossilFind(UUID ownerId) {§super(ownerId, 206, "Fossil Find", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{R/G}");§this.expansionSetCode = "SHM";§this.getSpellAbility().addEffect(new FossilFindEffect());§}§public FossilFind(final FossilFind card) {§super(card);§}§@Override§public FossilFind copy() {§return new FossilFind(this);§}§}§class FossilFindEffect extends OneShotEffect {§public FossilFindEffect() {§super(Outcome.ReturnToHand);§this.staticText = "Return a card at random from your graveyard to your hand, then reorder your graveyard as you choose";§}§public FossilFindEffect(final FossilFindEffect effect) {§super(effect);§}§@Override§public FossilFindEffect copy() {§return new FossilFindEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null && !controller.getGraveyard().isEmpty()) {§Card card = controller.getGraveyard().getRandom(game);§if (card != null) {§controller.moveCards(card, Zone.HAND, source, game);§return true;§}§controller.moveCards(controller.getGraveyard(), Zone.GRAVEYARD, source, game);§}§return false;§}§}§
public class GrimPoppet extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("another target creature");§static {§filter.add(new AnotherPredicate());§}§public GrimPoppet(UUID ownerId) {§super(ownerId, 252, "Grim Poppet", Rarity.RARE, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{7}");§this.expansionSetCode = "SHM";§this.subtype.add("Scarecrow");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new EntersBattlefieldAbility(new AddCountersSourceEffect(CounterType.M1M1.createInstance(3), false)));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersTargetEffect(CounterType.M1M1.createInstance()), new RemoveCountersSourceCost(CounterType.M1M1.createInstance()));§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public GrimPoppet(final GrimPoppet card) {§super(card);§}§@Override§public GrimPoppet copy() {§return new GrimPoppet(this);§}§}§
public class KitchenFinks extends CardImpl {§public KitchenFinks(UUID ownerId) {§super(ownerId, 229, "Kitchen Finks", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{G/W}{G/W}");§this.expansionSetCode = "SHM";§this.subtype.add("Ouphe");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(new EntersBattlefieldTriggeredAbility(new GainLifeEffect(2)));§this.addAbility(new PersistAbility());§}§public KitchenFinks(final KitchenFinks card) {§super(card);§}§@Override§public KitchenFinks copy() {§return new KitchenFinks(this);§}§}§
public class MemoryPlunder extends CardImpl {§private static final FilterCard filter = new FilterCard("instant or sorcery card from an opponent's graveyard");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.INSTANT),§new CardTypePredicate(CardType.SORCERY)));§}§public MemoryPlunder(UUID ownerId) {§super(ownerId, 169, "Memory Plunder", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{U/B}{U/B}{U/B}{U/B}");§this.expansionSetCode = "SHM";§this.getSpellAbility().addEffect(new MemoryPlunderEffect());§this.getSpellAbility().addTarget(new TargetCardInOpponentsGraveyard(filter));§}§public MemoryPlunder(final MemoryPlunder card) {§super(card);§}§@Override§public MemoryPlunder copy() {§return new MemoryPlunder(this);§}§}§class MemoryPlunderEffect extends OneShotEffect {§public MemoryPlunderEffect() {§super(Outcome.Benefit);§this.staticText = "You may cast target instant or sorcery card from an opponent's graveyard without paying its mana cost";§}§public MemoryPlunderEffect(final MemoryPlunderEffect effect) {§super(effect);§}§@Override§public MemoryPlunderEffect copy() {§return new MemoryPlunderEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Card card = game.getCard(getTargetPointer().getFirst(game, source));§if (card != null) {§Player player = game.getPlayer(source.getControllerId());§if (player != null && player.chooseUse(Outcome.Benefit, "Cast " + card.getName() +" without paying cost?", source, game)) {§player.cast(card.getSpellAbility(), game, true);§}§}§return false;§}§}§
public class OldGhastbark extends CardImpl {§public OldGhastbark(UUID ownerId) {§super(ownerId, 232, "Old Ghastbark", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{G/W}{G/W}");§this.expansionSetCode = "SHM";§this.subtype.add("Treefolk");§this.subtype.add("Warrior");§this.power = new MageInt(3);§this.toughness = new MageInt(6);§}§public OldGhastbark(final OldGhastbark card) {§super(card);§}§@Override§public OldGhastbark copy() {§return new OldGhastbark(this);§}§}§
public class PuresightMerrow extends CardImpl {§public PuresightMerrow(UUID ownerId) {§super(ownerId, 146, "Puresight Merrow", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{W/U}{W/U}");§this.expansionSetCode = "SHM";§this.subtype.add("Merfolk");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PuresightMerrowEffect(), new ManaCostsImpl("{W/U}"));§ability.addCost(new UntapSourceCost());§this.addAbility(ability);§}§public PuresightMerrow(final PuresightMerrow card) {§super(card);§}§@Override§public PuresightMerrow copy() {§return new PuresightMerrow(this);§}§}§class PuresightMerrowEffect extends OneShotEffect {§public PuresightMerrowEffect() {§super(Outcome.Detriment);§staticText = "Look at the top card of your library. You may exile that card";§}§public PuresightMerrowEffect(final PuresightMerrowEffect effect) {§super(effect);§}§@Override§public PuresightMerrowEffect copy() {§return new PuresightMerrowEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = source.getSourceObject(game);§if (controller != null && sourceObject != null) {§Card card = controller.getLibrary().getFromTop(game);§if (card != null) {§Cards cards = new CardsImpl();§cards.add(card);§controller.lookAtCards("Puresight Merrow", cards, game);§if (controller.chooseUse(Outcome.Removal, "Do you wish to exile the card from the top of your library?", source, game)) {§controller.moveCardToExileWithInfo(card, source.getSourceId(), sourceObject.getIdName(), source.getSourceId(), game, Zone.LIBRARY, true);§} else {§game.informPlayers(controller.getLogName() + " puts the card back on top of their library.");§}§return true;§}§}§return false;§}§}§
public class RunesOfTheDeus extends CardImpl {§public RunesOfTheDeus(UUID ownerId) {§super(ownerId, 215, "Runes of the Deus", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{4}{R/G}");§this.expansionSetCode = "SHM";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§SimpleStaticAbility redAbility = new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(new BoostEnchantedEffect(1, 1), new EnchantedCreatureColorCondition(ObjectColor.RED), "As long as enchanted creature is red, it gets +1/+1"));§redAbility.addEffect(new ConditionalContinuousEffect(new GainAbilityAttachedEffect(DoubleStrikeAbility.getInstance(), AttachmentType.AURA), new EnchantedCreatureColorCondition(ObjectColor.RED), "and has double strike"));§this.addAbility(redAbility);§SimpleStaticAbility greenAbility = new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(new BoostEnchantedEffect(1, 1), new EnchantedCreatureColorCondition(ObjectColor.GREEN), "As long as enchanted creature is green, it gets +1/+1"));§greenAbility.addEffect(new ConditionalContinuousEffect(new GainAbilityAttachedEffect(TrampleAbility.getInstance(), AttachmentType.AURA), new EnchantedCreatureColorCondition(ObjectColor.GREEN), "and has trample"));§this.addAbility(greenAbility);§}§public RunesOfTheDeus(final RunesOfTheDeus card) {§super(card);§}§@Override§public RunesOfTheDeus copy() {§return new RunesOfTheDeus(this);§}§}§
public class SmashToSmithereens extends CardImpl {§public SmashToSmithereens(UUID ownerId) {§super(ownerId, 107, "Smash to Smithereens", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{R}");§this.expansionSetCode = "SHM";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§Effect effect = new DamageTargetControllerEffect(3);§effect.setText("{this} deals 3 damage to that artifact's controller");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetArtifactPermanent());§}§public SmashToSmithereens(final SmashToSmithereens card) {§super(card);§}§@Override§public SmashToSmithereens copy() {§return new SmashToSmithereens(this);§}§}§
public class ThistledownLiege extends CardImpl {§private static final FilterCreaturePermanent filterWhite = new FilterCreaturePermanent("white creatures");§private static final FilterCreaturePermanent filterBlue = new FilterCreaturePermanent("blue creatures");§static {§filterWhite.add(new ColorPredicate(ObjectColor.WHITE));§filterBlue.add(new ColorPredicate(ObjectColor.BLUE));§}§public ThistledownLiege(UUID ownerId) {§super(ownerId, 153, "Thistledown Liege", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{W/U}{W/U}{W/U}");§this.expansionSetCode = "SHM";§this.subtype.add("Kithkin");§this.subtype.add("Knight");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§this.addAbility(FlashAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostControlledEffect(1, 1, Duration.WhileOnBattlefield, filterWhite, true)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostControlledEffect(1, 1, Duration.WhileOnBattlefield, filterBlue, true)));§}§public ThistledownLiege(final ThistledownLiege card) {§super(card);§}§@Override§public ThistledownLiege copy() {§return new ThistledownLiege(this);§}§}§
public class WickerWarcrawler extends CardImpl {§public WickerWarcrawler(UUID ownerId) {§super(ownerId, 269, "Wicker Warcrawler", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{5}");§this.expansionSetCode = "SHM";§this.subtype.add("Scarecrow");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§Effect effect = new AddCountersSourceEffect(CounterType.M1M1.createInstance(), true);§effect.setText("put a -1/-1 counter on it at end of combat");§DelayedTriggeredAbility ability = new AtTheEndOfCombatDelayedTriggeredAbility(effect);§this.addAbility(new AttacksOrBlocksTriggeredAbility(new CreateDelayedTriggeredAbilityEffect(ability, false, false), false));§}§public WickerWarcrawler(final WickerWarcrawler card) {§super(card);§}§@Override§public WickerWarcrawler copy() {§return new WickerWarcrawler(this);§}§}§
public class AngelicBenediction extends CardImpl {§public AngelicBenediction(UUID ownerId) {§super(ownerId, 3, "Angelic Benediction", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{3}{W}");§this.expansionSetCode = "ALA";§this.addAbility(new ExaltedAbility());§this.addAbility(new AngelicBenedictionTriggeredAbility());§}§public AngelicBenediction(final AngelicBenediction card) {§super(card);§}§@Override§public AngelicBenediction copy() {§return new AngelicBenediction(this);§}§}§class AngelicBenedictionTriggeredAbility extends TriggeredAbilityImpl {§public AngelicBenedictionTriggeredAbility() {§super(Zone.BATTLEFIELD, new TapTargetEffect(), true);§this.addTarget(new TargetCreaturePermanent());§}§public AngelicBenedictionTriggeredAbility(final AngelicBenedictionTriggeredAbility ability) {§super(ability);§}§@Override§public AngelicBenedictionTriggeredAbility copy() {§return new AngelicBenedictionTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DECLARED_ATTACKERS;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (game.getActivePlayerId().equals(this.controllerId)) {§if (game.getCombat().attacksAlone()) {§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever a creature you control attacks alone, you may tap target creature";§}§}§
public class BullCerodon extends CardImpl {§public BullCerodon (UUID ownerId) {§super(ownerId, 161, "Bull Cerodon", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{R}{W}");§this.expansionSetCode = "ALA";§this.subtype.add("Beast");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(HasteAbility.getInstance());§}§public BullCerodon (final BullCerodon card) {§super(card);§}§@Override§public BullCerodon copy() {§return new BullCerodon(this);§}§}§
public class DeathBaron extends CardImpl {§private static final FilterCreaturePermanent filterSkeletons = new FilterCreaturePermanent("Skeleton creatures");§private static final FilterCreaturePermanent filterZombie = new FilterCreaturePermanent("Zombie creatures");§static {§filterSkeletons.add(new SubtypePredicate("Skeleton"));§filterZombie.add(new SubtypePredicate("Zombie"));§}§public DeathBaron(UUID ownerId) {§super(ownerId, 70, "Death Baron", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{B}{B}");§this.expansionSetCode = "ALA";§this.subtype.add("Zombie");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability firstPart = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostControlledEffect(1, 1, Duration.WhileOnBattlefield, filterSkeletons, false));§firstPart.addEffect(new GainAbilityControlledEffect(DeathtouchAbility.getInstance(), Duration.WhileOnBattlefield, filterSkeletons, false));§this.addAbility(firstPart);§Ability secondPart = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostControlledEffect(1, 1, Duration.WhileOnBattlefield, filterZombie, true));§secondPart.addEffect(new GainAbilityControlledEffect(DeathtouchAbility.getInstance(), Duration.WhileOnBattlefield, filterZombie, true));§this.addAbility(secondPart);§}§public DeathBaron(final DeathBaron card) {§super(card);§}§@Override§public DeathBaron copy() {§return new DeathBaron(this);§}§}§
public class Excommunicate extends CardImpl {§public Excommunicate(UUID ownerId) {§super(ownerId, 11, "Excommunicate", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{W}");§this.expansionSetCode = "ALA";§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new PutOnLibraryTargetEffect(true));§}§public Excommunicate(final Excommunicate card) {§super(card);§}§@Override§public Excommunicate copy() {§return new Excommunicate(this);§}§}§
public class GuardiansOfAkrasa extends CardImpl {§public GuardiansOfAkrasa (UUID ownerId) {§super(ownerId, 12, "Guardians of Akrasa", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "ALA";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(0);§this.toughness = new MageInt(4);§this.addAbility(DefenderAbility.getInstance());§this.addAbility(new ExaltedAbility());§}§public GuardiansOfAkrasa (final GuardiansOfAkrasa card) {§super(card);§}§@Override§public GuardiansOfAkrasa copy() {§return new GuardiansOfAkrasa(this);§}§}§
public class KeeperOfProgenitus extends CardImpl {§private static final FilterLandPermanent filter = new FilterLandPermanent("a player taps a Mountain, Forest, or Plains");§static {§filter.add(Predicates.or(§new SubtypePredicate("Mountain"),§new SubtypePredicate("Forest"),§new SubtypePredicate("Plains")§));§}§public KeeperOfProgenitus(UUID ownerId) {§super(ownerId, 135, "Keeper of Progenitus", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "ALA";§this.subtype.add("Elf");§this.subtype.add("Druid");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§this.addAbility(new TapForManaAllTriggeredManaAbility(§new AddManaOfAnyTypeProducedEffect(),§filter, SetTargetPointer.PERMANENT));§}§public KeeperOfProgenitus(final KeeperOfProgenitus card) {§super(card);§}§@Override§public KeeperOfProgenitus copy() {§return new KeeperOfProgenitus(this);§}§}§
public class Mycoloth extends CardImpl {§public Mycoloth(UUID ownerId) {§super(ownerId, 140, "Mycoloth", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{G}{G}");§this.expansionSetCode = "ALA";§this.subtype.add("Fungus");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new DevourAbility(DevourFactor.Devour2));§this.addAbility(new BeginningOfUpkeepTriggeredAbility(§new CreateTokenEffect(new SaprolingToken(),new CountersCount(CounterType.P1P1)),§TargetController.YOU,§false§));§}§public Mycoloth(final Mycoloth card) {§super(card);§}§@Override§public Mycoloth copy() {§return new Mycoloth(this);§}§}§
public class QuietusSpike extends CardImpl {§public QuietusSpike(UUID ownerId) {§super(ownerId, 217, "Quietus Spike", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "ALA";§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(DeathtouchAbility.getInstance(), AttachmentType.EQUIPMENT)));§this.addAbility(new QuietusSpikeTriggeredAbility());§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(3)));§}§public QuietusSpike(final QuietusSpike card) {§super(card);§}§@Override§public QuietusSpike copy() {§return new QuietusSpike(this);§}§}§class QuietusSpikeTriggeredAbility extends TriggeredAbilityImpl {§public QuietusSpikeTriggeredAbility() {§super(Zone.BATTLEFIELD, new QuietusSpikeEffect());§}§public QuietusSpikeTriggeredAbility(final QuietusSpikeTriggeredAbility ability) {§super(ability);§}§@Override§public QuietusSpikeTriggeredAbility copy() {§return new QuietusSpikeTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_PLAYER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§DamagedPlayerEvent damageEvent = (DamagedPlayerEvent) event;§Permanent p = game.getPermanent(event.getSourceId());§if (damageEvent.isCombatDamage() && p != null && p.getAttachments().contains(this.getSourceId())) {§for (Effect effect : this.getEffects()) {§effect.setTargetPointer(new FixedTarget(event.getPlayerId()));§}§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever equipped creature deals combat damage to a player, " + super.getRule();§}§}§class QuietusSpikeEffect extends OneShotEffect {§public QuietusSpikeEffect() {§super(Outcome.Damage);§this.staticText = "that player loses half his or her life, rounded up";§}§public QuietusSpikeEffect(final QuietusSpikeEffect effect) {§super(effect);§}§@Override§public QuietusSpikeEffect copy() {§return new QuietusSpikeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(getTargetPointer().getFirst(game, source));§if (player != null) {§Integer amount = (int) Math.ceil(player.getLife() / 2f);§if (amount > 0) {§player.loseLife(amount, game);§}§return true;§}§return false;§}§}§
public class SangriteSurge extends CardImpl {§public SangriteSurge(UUID ownerId) {§super(ownerId, 190, "Sangrite Surge", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{4}{R}{G}");§this.expansionSetCode = "ALA";§this.getSpellAbility().addEffect(new BoostTargetEffect(3, 3, Duration.EndOfTurn));§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(DoubleStrikeAbility.getInstance(), Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public SangriteSurge(final SangriteSurge card) {§super(card);§}§@Override§public SangriteSurge copy() {§return new SangriteSurge(this);§}§}§
public class SkillBorrower extends CardImpl {§public SkillBorrower(UUID ownerId) {§super(ownerId, 56, "Skill Borrower", Rarity.RARE, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "ALA";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new PlayWithTheTopCardRevealedEffect()));§this.addAbility(new SkillBorrowerAbility());§}§public SkillBorrower(final SkillBorrower card) {§super(card);§}§@Override§public SkillBorrower copy() {§return new SkillBorrower(this);§}§}§class SkillBorrowerAbility extends StaticAbility {§public SkillBorrowerAbility() {§super(Zone.BATTLEFIELD, new SkillBorrowerEffect());§}§public SkillBorrowerAbility(SkillBorrowerAbility ability) {§super(ability);§}§@Override§public SkillBorrowerAbility copy() {§return new SkillBorrowerAbility(this);§}§@Override§public String getRule() {§return "As long as the top card of your library is an artifact or creature card, Skill Borrower has all activated abilities of that card";§}§}§class SkillBorrowerEffect extends ContinuousEffectImpl {§public SkillBorrowerEffect() {§super(Duration.WhileOnBattlefield, Layer.AbilityAddingRemovingEffects_6, SubLayer.NA, Outcome.AddAbility);§staticText = "As long as the top card of your library is an artifact or creature card, Skill Borrower has all activated abilities of that card";§}§public SkillBorrowerEffect(final SkillBorrowerEffect effect) {§super(effect);§}§@Override§public SkillBorrowerEffect copy() {§return new SkillBorrowerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if(player != null){§Card card = player.getLibrary().getFromTop(game);§if(card != null && (card.getCardType().contains(CardType.CREATURE) || card.getCardType().contains(CardType.ARTIFACT))){§Permanent permanent = game.getPermanent(source.getSourceId());§if(permanent != null){§for(Ability ability : card.getAbilities()){§if(ability instanceof ActivatedAbility){§permanent.addAbility(ability, source.getSourceId(), game);§}§}§return true;§}§}§}§return false;§}§}§
public class TidehollowSculler extends CardImpl {§public TidehollowSculler(UUID ownerId) {§super(ownerId, 202, "Tidehollow Sculler", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{W}{B}");§this.expansionSetCode = "ALA";§this.subtype.add("Zombie");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new EntersBattlefieldTriggeredAbility(new TidehollowScullerExileEffect(), false);§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§this.addAbility(new LeavesBattlefieldTriggeredAbility(new TidehollowScullerLeaveEffect(), false));§}§public TidehollowSculler(final TidehollowSculler card) {§super(card);§}§@Override§public TidehollowSculler copy() {§return new TidehollowSculler(this);§}§}§class TidehollowScullerExileEffect extends OneShotEffect {§public TidehollowScullerExileEffect() {§super(Outcome.Exile);§this.staticText = "target opponent reveals his or her hand and you choose a nonland card from it. Exile that card";§}§public TidehollowScullerExileEffect(final TidehollowScullerExileEffect effect) {§super(effect);§}§@Override§public TidehollowScullerExileEffect copy() {§return new TidehollowScullerExileEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Player opponent = game.getPlayer(source.getFirstTarget());§Permanent sourcePermanent = (Permanent) source.getSourceObject(game);§if (controller != null && opponent != null && sourcePermanent != null) {§opponent.revealCards(sourcePermanent.getName(), opponent.getHand(), game);§TargetCard target = new TargetCard(Zone.HAND, new FilterNonlandCard("nonland card to exile"));§if (controller.choose(Outcome.Exile, opponent.getHand(), target, game)) {§Card card = opponent.getHand().get(target.getFirstTarget(), game);§if (card != null) {§controller.moveCardToExileWithInfo(card, CardUtil.getExileZoneId(game, source.getSourceId(), source.getSourceObjectZoneChangeCounter()), sourcePermanent.getIdName(), source.getSourceId(), game, Zone.HAND, true);§}§}§return true;§}§return false;§}§}§class TidehollowScullerLeaveEffect extends OneShotEffect {§public TidehollowScullerLeaveEffect() {§super(Outcome.ReturnToHand);§this.staticText = "return the exiled card to its owner's hand";§}§public TidehollowScullerLeaveEffect(final TidehollowScullerLeaveEffect effect) {§super(effect);§}§@Override§public TidehollowScullerLeaveEffect copy() {§return new TidehollowScullerLeaveEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = source.getSourceObject(game);§if (controller != null && sourceObject != null) {§int zoneChangeCounter = (sourceObject instanceof PermanentToken) ? source.getSourceObjectZoneChangeCounter() : source.getSourceObjectZoneChangeCounter() - 1;§ExileZone exZone = game.getExile().getExileZone(CardUtil.getExileZoneId(game, source.getSourceId(), zoneChangeCounter));§if (exZone != null) {§controller.moveCards(exZone, null, Zone.HAND, source, game);§}§return true;§}§return false;§}§}§
public class WoollyThoctar extends CardImpl {§public WoollyThoctar(UUID ownerId) {§super(ownerId, 209, "Woolly Thoctar", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{R}{G}{W}");§this.expansionSetCode = "ALA";§this.subtype.add("Beast");§this.power = new MageInt(5);§this.toughness = new MageInt(4);§}§public WoollyThoctar(final WoollyThoctar card) {§super(card);§}§@Override§public WoollyThoctar copy() {§return new WoollyThoctar(this);§}§}§
public class DevoutMonk extends CardImpl {§public DevoutMonk(UUID ownerId) {§super(ownerId, 14, "Devout Monk", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{W}");§this.expansionSetCode = "S99";§this.subtype.add("Human");§this.subtype.add("Monk");§this.subtype.add("Cleric");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new EntersBattlefieldTriggeredAbility(new GainLifeEffect(1), false));§}§public DevoutMonk(final DevoutMonk card) {§super(card);§}§@Override§public DevoutMonk copy() {§return new DevoutMonk(this);§}§}§
public class BreathOfLife extends CardImpl {§public BreathOfLife(UUID ownerId) {§super(ownerId, 2, "Breath of Life", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{3}{W}");§this.expansionSetCode = "S00";§this.getSpellAbility().addEffect(new ReturnFromGraveyardToBattlefieldTargetEffect());§this.getSpellAbility().addTarget(new TargetCardInYourGraveyard(new FilterCreatureCard("creature card from your graveyard")));§}§public BreathOfLife(final BreathOfLife card) {§super(card);§}§@Override§public BreathOfLife copy() {§return new BreathOfLife(this);§}§}§
public class CravenGiant extends CardImpl {§public CravenGiant(UUID ownerId) {§super(ownerId, 78, "Craven Giant", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "STH";§this.subtype.add("Giant");§this.power = new MageInt(4);§this.toughness = new MageInt(1);§this.addAbility(new CantBlockAbility());§}§public CravenGiant(final CravenGiant card) {§super(card);§}§@Override§public CravenGiant copy() {§return new CravenGiant(this);§}§}§
public class Hesitation extends CardImpl {§public Hesitation(UUID ownerId) {§super(ownerId, 33, "Hesitation", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{U}");§this.expansionSetCode = "STH";§Ability ability = new SpellCastAllTriggeredAbility(new SacrificeSourceEffect(), new FilterSpell("a spell"), false, SetTargetPointer.SPELL);§Effect effect = new CounterTargetEffect();§effect.setText("and counter that spell");§ability.addEffect(effect);§this.addAbility(ability);§}§public Hesitation(final Hesitation card) {§super(card);§}§@Override§public Hesitation copy() {§return new Hesitation(this);§}§}§
public class ReinsOfPower extends CardImpl {§public ReinsOfPower(UUID ownerId) {§super(ownerId, 41, "Reins of Power", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{2}{U}{U}");§this.expansionSetCode = "STH";§this.getSpellAbility().addEffect(new ReinsOfPowerEffect());§this.getSpellAbility().addTarget(new TargetOpponent());§}§public ReinsOfPower(final ReinsOfPower card) {§super(card);§}§@Override§public ReinsOfPower copy() {§return new ReinsOfPower(this);§}§}§class ReinsOfPowerEffect extends OneShotEffect {§ReinsOfPowerEffect() {§super(Outcome.Benefit);§this.staticText = "Untap all creatures you control and all creatures target opponent controls. You and that opponent each gain control of all creatures the other controls until end of turn. Those creatures gain haste until end of turn";§}§ReinsOfPowerEffect(final ReinsOfPowerEffect effect) {§super(effect);§}§@Override§public ReinsOfPowerEffect copy() {§return new ReinsOfPowerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§UUID opponentId = this.getTargetPointer().getFirst(game, source);§if (opponentId != null) {§FilterCreaturePermanent filter = new FilterCreaturePermanent();§filter.add(Predicates.or(new ControllerIdPredicate(source.getControllerId()), new ControllerIdPredicate(opponentId)));§new UntapAllEffect(filter).apply(game, source);§Set<UUID> yourCreatures = new HashSet<>();§Set<UUID> opponentCreatures = new HashSet<>();§for (Permanent permanent : game.getBattlefield().getActivePermanents(new FilterControlledCreaturePermanent(), source.getControllerId(), source.getSourceId(), game)) {§yourCreatures.add(permanent.getId());§}§FilterCreaturePermanent filterOpponent = new FilterCreaturePermanent();§filterOpponent.add(new ControllerIdPredicate(opponentId));§for (Permanent permanent : game.getBattlefield().getActivePermanents(filterOpponent, source.getControllerId(), source.getSourceId(), game)) {§opponentCreatures.add(permanent.getId());§}§for (UUID creatureId : yourCreatures) {§ContinuousEffect effect = new GainControlTargetEffect(Duration.EndOfTurn, opponentId);§effect.setTargetPointer(new FixedTarget(creatureId));§game.addEffect(effect, source);§}§for (UUID creatureId : opponentCreatures) {§ContinuousEffect effect = new GainControlTargetEffect(Duration.EndOfTurn);§effect.setTargetPointer(new FixedTarget(creatureId));§game.addEffect(effect, source);§}§game.addEffect(new GainAbilityAllEffect(HasteAbility.getInstance(), Duration.EndOfTurn, filter), source);§return true;§}§return false;§}§}§
public class SwordOfTheChosen extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("legendary creature");§static {§filter.add(new SupertypePredicate("Legendary"));§}§public SwordOfTheChosen(UUID ownerId) {§super(ownerId, 135, "Sword of the Chosen", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "STH";§this.supertype.add("Legendary");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(2, 2, Duration.EndOfTurn), new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public SwordOfTheChosen(final SwordOfTheChosen card) {§super(card);§}§@Override§public SwordOfTheChosen copy() {§return new SwordOfTheChosen(this);§}§}§
public class AncientTomb extends CardImpl {§public AncientTomb(UUID ownerId) {§super(ownerId, 305, "Ancient Tomb", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "TMP";§Ability ability = new SimpleManaAbility(Zone.BATTLEFIELD, Mana.ColorlessMana(2), new TapSourceCost());§ability.addEffect(new DamageControllerEffect(2));§this.addAbility(ability);§}§public AncientTomb(final AncientTomb card) {§super(card);§}§@Override§public AncientTomb copy() {§return new AncientTomb(this);§}§}§
public class CanyonDrake extends CardImpl {§public CanyonDrake(UUID ownerId) {§super(ownerId, 166, "Canyon Drake", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "TMP";§this.subtype.add("Drake");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(2, 0, Duration.EndOfTurn), new ManaCostsImpl("{1}"));§ability.addCost(new DiscardCardCost(true));§this.addAbility(ability);§}§public CanyonDrake(final CanyonDrake card) {§super(card);§}§@Override§public CanyonDrake copy() {§return new CanyonDrake(this);§}§}§
public class DarklingStalker extends CardImpl {§public DarklingStalker(UUID ownerId) {§super(ownerId, 13, "Darkling Stalker", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{B}");§this.expansionSetCode = "TMP";§this.subtype.add("Shade");§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new ColoredManaCost(ColoredManaSymbol.B)));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 1, Duration.EndOfTurn), new ColoredManaCost(ColoredManaSymbol.B)));§}§public DarklingStalker(final DarklingStalker card) {§super(card);§}§@Override§public DarklingStalker copy() {§return new DarklingStalker(this);§}§}§
public class ElvishFury extends CardImpl {§public ElvishFury(UUID ownerId) {§super(ownerId, 120, "Elvish Fury", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{G}");§this.expansionSetCode = "TMP";§this.addAbility(new BuybackAbility("{4}"));§this.getSpellAbility().addEffect(new BoostTargetEffect(2,2, Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public ElvishFury(final ElvishFury card) {§super(card);§}§@Override§public ElvishFury copy() {§return new ElvishFury(this);§}§}§
public class FrogTongue extends CardImpl {§public FrogTongue(UUID ownerId) {§super(ownerId, 122, "Frog Tongue", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{G}");§this.expansionSetCode = "TMP";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new EntersBattlefieldTriggeredAbility(new DrawCardSourceControllerEffect(1), false));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(ReachAbility.getInstance(), AttachmentType.AURA)));§}§public FrogTongue(final FrogTongue card) {§super(card);§}§@Override§public FrogTongue copy() {§return new FrogTongue(this);§}§}§
public class HornedSliver extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("All Sliver creatures");§static {§filter.add(new SubtypePredicate("Sliver"));§}§public HornedSliver(UUID ownerId) {§super(ownerId, 128, "Horned Sliver", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "TMP";§this.subtype.add("Sliver");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAllEffect(TrampleAbility.getInstance(), Duration.WhileOnBattlefield, filter, false)));§}§public HornedSliver(final HornedSliver card) {§super(card);§}§@Override§public HornedSliver copy() {§return new HornedSliver(this);§}§}§
public class LotusPetal extends CardImpl {§public LotusPetal(UUID ownerId) {§super(ownerId, 284, "Lotus Petal", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{0}");§this.expansionSetCode = "TMP";§Ability ability = new AnyColorManaAbility();§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public LotusPetal(final LotusPetal card) {§super(card);§}§@Override§public LotusPetal copy() {§return new LotusPetal(this);§}§}§
public class MoggRaider extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("a Goblin");§static {§filter.add(new SubtypePredicate("Goblin"));§}§public MoggRaider(UUID ownerId) {§super(ownerId, 191, "Mogg Raider", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "TMP";§this.subtype.add("Goblin");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(1, 1, Duration.EndOfTurn), new SacrificeTargetCost(new TargetControlledPermanent(filter)));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public MoggRaider(final MoggRaider card) {§super(card);§}§@Override§public MoggRaider copy() {§return new MoggRaider(this);§}§}§
public class PuppetStrings extends CardImpl {§public PuppetStrings(UUID ownerId) {§super(ownerId, 294, "Puppet Strings", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "TMP";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new MayTapOrUntapTargetEffect(), new GenericManaCost(2));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public PuppetStrings(final PuppetStrings card) {§super(card);§}§@Override§public PuppetStrings copy() {§return new PuppetStrings(this);§}§}§
public class SadisticGlee extends CardImpl {§public SadisticGlee(UUID ownerId) {§super(ownerId, 47, "Sadistic Glee", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{B}");§this.expansionSetCode = "TMP";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new DiesCreatureTriggeredAbility(new AddCountersAttachedEffect(§CounterType.P1P1.createInstance(), "enchanted creature"), false));§}§public SadisticGlee(final SadisticGlee card) {§super(card);§}§@Override§public SadisticGlee copy() {§return new SadisticGlee(this);§}§}§
public class Shadowstorm extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature with shadow");§static {§filter.add(new AbilityPredicate(ShadowAbility.class));§}§public Shadowstorm(UUID ownerId) {§super(ownerId, 202, "Shadowstorm", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{R}");§this.expansionSetCode = "TMP";§this.getSpellAbility().addEffect(new DamageAllEffect(2, filter));§}§public Shadowstorm(final Shadowstorm card) {§super(card);§}§@Override§public Shadowstorm copy() {§return new Shadowstorm(this);§}§}§
public class SqueesToy extends CardImpl {§public SqueesToy(UUID ownerId) {§super(ownerId, 299, "Squee's Toy", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "TMP";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PreventDamageToTargetEffect(Duration.EndOfTurn, 1), new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public SqueesToy(final SqueesToy card) {§super(card);§}§@Override§public SqueesToy copy() {§return new SqueesToy(this);§}§}§
public class TradewindRider extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("untapped creatures you control");§static {§filter.add(Predicates.not(new TappedPredicate()));§}§public TradewindRider(UUID ownerId) {§super(ownerId, 98, "Tradewind Rider", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "TMP";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ReturnToHandTargetEffect(), new TapSourceCost());§ability.addCost(new TapTargetCost(new TargetControlledCreaturePermanent(2, 2, filter, false)));§ability.addTarget(new TargetPermanent());§this.addAbility(ability);§}§public TradewindRider(final TradewindRider card) {§super(card);§}§@Override§public TradewindRider copy() {§return new TradewindRider(this);§}§}§
public class Cannibalize extends CardImpl {§public Cannibalize(UUID ownerId) {§super(ownerId, 83, "Cannibalize", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{1}{B}");§this.expansionSetCode = "TPR";§this.getSpellAbility().addEffect(new CannibalizeEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanentSameController(2,2,new FilterCreaturePermanent(),false));§}§public Cannibalize(final Cannibalize card) {§super(card);§}§@Override§public Cannibalize copy() {§return new Cannibalize(this);§}§}§class CannibalizeEffect extends OneShotEffect {§public CannibalizeEffect() {§super(Outcome.Benefit);§this.staticText = "Choose two target creatures controlled by the same player. Exile one of the creatures and put two +1/+1 counters on the other";§}§public CannibalizeEffect(final CannibalizeEffect effect) {§super(effect);§}§@Override§public CannibalizeEffect copy() {§return new CannibalizeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = source.getSourceObject(game);§if (controller != null && sourceObject != null) {§boolean exileDone = false;§int count = 0;§for(UUID targetId: getTargetPointer().getTargets(game, source)) {§Permanent creature = game.getPermanent(targetId);§if (creature != null) {§if ((count == 0 && controller.chooseUse(Outcome.Exile, "Exile " + creature.getLogName() +"?", source, game))§|| (count == 1 && !exileDone)) {§controller.moveCardToExileWithInfo(creature, null, "", source.getSourceId(), game, Zone.BATTLEFIELD, true);§exileDone = true;§} else {§creature.addCounters(CounterType.P1P1.createInstance(2), game);§game.informPlayers("Added two +1/+1 counters on " + creature.getLogName());§}§count++;§}§}§return true;§}§return false;§}§}§class TargetCreaturePermanentSameController extends TargetCreaturePermanent {§public TargetCreaturePermanentSameController(int minNumTargets, int maxNumTargets, FilterCreaturePermanent filter, boolean notTarget) {§super(minNumTargets, maxNumTargets, filter, notTarget);§this.targetName = filter.getMessage();§}§public TargetCreaturePermanentSameController(final TargetCreaturePermanentSameController target) {§super(target);§}§@Override§public boolean canTarget(UUID id, Ability source, Game game) {§UUID firstTarget = this.getFirstTarget();§if (firstTarget != null) {§Permanent permanent = game.getPermanent(firstTarget);§Permanent targetPermanent = game.getPermanent(id);§if (permanent == null || targetPermanent == null§|| !permanent.getControllerId().equals(targetPermanent.getOwnerId())) {§return false;§}§}§return super.canTarget(id, source, game);§}§@Override§public TargetCreaturePermanentSameController copy() {§return new TargetCreaturePermanentSameController(this);§}§}§
public class RollingThunder extends CardImpl {§public RollingThunder(UUID ownerId) {§super(ownerId, 152, "Rolling Thunder", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{X}{R}{R}");§this.expansionSetCode = "TPR";§DynamicValue xValue = new ManacostVariableValue();§this.getSpellAbility().addEffect(new DamageMultiEffect(xValue));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayerAmount(xValue));§}§public RollingThunder(final RollingThunder card) {§super(card);§}§@Override§public RollingThunder copy() {§return new RollingThunder(this);§}§}§
public class Abundance extends CardImpl {§public Abundance(UUID ownerId) {§super(ownerId, 249, "Abundance", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{2}{G}{G}");§this.expansionSetCode = "10E";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new AbundanceReplacementEffect()));§}§public Abundance(final Abundance card) {§super(card);§}§@Override§public Abundance copy() {§return new Abundance(this);§}§}§class AbundanceReplacementEffect extends ReplacementEffectImpl {§AbundanceReplacementEffect() {§super(Duration.WhileOnBattlefield, Outcome.Benefit);§staticText = "If you would draw a card, you may instead choose land or nonland and reveal cards from the top of your library until you reveal a card of the chosen kind. Put that card into your hand and put all other cards revealed this way on the bottom of your library in any order";§}§AbundanceReplacementEffect(final AbundanceReplacementEffect effect) {§super(effect);§}§@Override§public AbundanceReplacementEffect copy() {§return new AbundanceReplacementEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§Player controller = game.getPlayer(event.getPlayerId());§MageObject sourceObject = game.getObject(source.getSourceId());§if (controller != null && sourceObject != null) {§FilterCard filter = new FilterCard();§if (controller.chooseUse(Outcome.Benefit, "Choose land? (No = nonland)", source, game)) {§filter.add(new CardTypePredicate(CardType.LAND));§} else {§filter.add(Predicates.not(new CardTypePredicate(CardType.LAND)));§}§Cards cards = new CardsImpl();§while (controller.getLibrary().size() > 0) {§Card card = controller.getLibrary().removeFromTop(game);§if (filter.match(card, source.getSourceId(), source.getControllerId(), game)) {§controller.moveCards(card, null, Zone.HAND, source, game);§break;§}§cards.add(card);§}§controller.revealCards(sourceObject.getIdName(), cards, game);§controller.putCardsOnBottomOfLibrary(cards, game, source, true);§}§return true;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.DRAW_CARD;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (event.getPlayerId().equals(source.getControllerId())) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§return player.chooseUse(Outcome.Benefit, "Choose land or nonland?", source, game);§}§}§return false;§}§}§
public class BeaconOfImmortality extends CardImpl {§public BeaconOfImmortality(UUID ownerId) {§super(ownerId, 10, "Beacon of Immortality", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{5}{W}");§this.expansionSetCode = "10E";§this.getSpellAbility().addTarget(new TargetPlayer());§this.getSpellAbility().addEffect(new BeaconOfImmortalityEffect());§this.getSpellAbility().addEffect(ShuffleSpellEffect.getInstance());§}§public BeaconOfImmortality(final BeaconOfImmortality card) {§super(card);§}§@Override§public BeaconOfImmortality copy() {§return new BeaconOfImmortality(this);§}§}§class BeaconOfImmortalityEffect extends OneShotEffect {§public BeaconOfImmortalityEffect() {§super(Outcome.GainLife);§this.staticText = "Double target player's life total";§}§public BeaconOfImmortalityEffect(final BeaconOfImmortalityEffect effect) {§super(effect);§}§@Override§public BeaconOfImmortalityEffect copy() {§return new BeaconOfImmortalityEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getFirstTarget());§if (player != null) {§int amount = player.getLife();§if (amount < 0) {§player.loseLife(-amount, game);§return true;§}§if (amount > 0) {§player.gainLife(amount, game);§return true;§}§}§return false;§}§}§
public class CruelEdict extends CardImpl {§public CruelEdict(UUID ownerId) {§super(ownerId, 133, "Cruel Edict", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{1}{B}");§this.expansionSetCode = "10E";§this.getSpellAbility().addEffect(new SacrificeEffect(new FilterCreaturePermanent(), 1, "Target opponent sacrifices a creature"));§this.getSpellAbility().addTarget(new TargetOpponent());§}§public CruelEdict(final CruelEdict card) {§super(card);§}§@Override§public CruelEdict copy() {§return new CruelEdict(this);§}§}§
public class FaerieConclave extends CardImpl {§public FaerieConclave(UUID ownerId) {§super(ownerId, 351, "Faerie Conclave", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "10E";§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new BlueManaAbility());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BecomesCreatureSourceEffect(new FaerieConclaveToken(), "land", Duration.EndOfTurn), new ManaCostsImpl("{1}{U}")));§}§public FaerieConclave(final FaerieConclave card) {§super(card);§}§@Override§public FaerieConclave copy() {§return new FaerieConclave(this);§}§}§class FaerieConclaveToken extends Token {§FaerieConclaveToken() {§super("Faerie", "a 2/1 blue Faerie creature with flying");§cardType.add(CardType.CREATURE);§this.subtype.add("Faerie");§color.setBlue(true);§power = new MageInt(2);§toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§}§}§
public class GoblinKing extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Goblin creatures");§static {§filter.add(new SubtypePredicate("Goblin"));§}§public GoblinKing(UUID ownerId) {§super(ownerId, 207, "Goblin King", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{R}{R}");§this.expansionSetCode = "10E";§this.subtype.add("Goblin");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostAllEffect(1, 1, Duration.WhileOnBattlefield, filter, true)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAllEffect(new MountainwalkAbility(), Duration.WhileOnBattlefield, filter, true)));§}§public GoblinKing(final GoblinKing card) {§super(card);§}§@Override§public GoblinKing copy() {§return new GoblinKing(this);§}§}§
public class KamahlPitFighter extends CardImpl {§public KamahlPitFighter(UUID ownerId) {§super(ownerId, 214, "Kamahl, Pit Fighter", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{R}{R}");§this.expansionSetCode = "10E";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Barbarian");§this.power = new MageInt(6);§this.toughness = new MageInt(1);§this.addAbility(HasteAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(3), new TapSourceCost());§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public KamahlPitFighter(final KamahlPitFighter card) {§super(card);§}§@Override§public KamahlPitFighter copy() {§return new KamahlPitFighter(this);§}§}§
public class MirriCatWarrior extends CardImpl {§public MirriCatWarrior(UUID ownerId) {§super(ownerId, 279, "Mirri, Cat Warrior", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{G}{G}");§this.expansionSetCode = "10E";§this.supertype.add("Legendary");§this.subtype.add("Cat");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(FirstStrikeAbility.getInstance());§this.addAbility(new ForestwalkAbility());§this.addAbility(VigilanceAbility.getInstance());§}§public MirriCatWarrior(final MirriCatWarrior card) {§super(card);§}§@Override§public MirriCatWarrior copy() {§return new MirriCatWarrior(this);§}§}§
public class Pyroclasm extends CardImpl {§public Pyroclasm(UUID ownerId) {§super(ownerId, 222, "Pyroclasm", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{1}{R}");§this.expansionSetCode = "10E";§this.getSpellAbility().addEffect(new DamageAllEffect(2, new FilterCreaturePermanent()));§}§public Pyroclasm(final Pyroclasm card) {§super(card);§}§@Override§public Pyroclasm copy() {§return new Pyroclasm(this);§}§}§
public class RushwoodDryad extends CardImpl {§public RushwoodDryad(UUID ownerId) {§super(ownerId, 294, "Rushwood Dryad", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "10E";§this.subtype.add("Dryad");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new ForestwalkAbility());§}§public RushwoodDryad(final RushwoodDryad card) {§super(card);§}§@Override§public RushwoodDryad copy() {§return new RushwoodDryad(this);§}§}§
public class Soulblast extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creatures you control");§public Soulblast(UUID ownerId) {§super(ownerId, 236, "Soulblast", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{3}{R}{R}{R}");§this.expansionSetCode = "10E";§this.getSpellAbility().addCost(new SacrificeAllCost(filter));§this.getSpellAbility().addEffect(new SoulblastEffect());§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§}§public Soulblast(final Soulblast card) {§super(card);§}§@Override§public Soulblast copy() {§return new Soulblast(this);§}§}§class SoulblastEffect extends OneShotEffect {§public SoulblastEffect() {§super(Outcome.Benefit);§this.staticText = "Soulblast deals damage to target creature or player equal to the total power of the sacrificed creatures";§}§public SoulblastEffect(final SoulblastEffect effect) {§super(effect);§}§@Override§public SoulblastEffect copy() {§return new SoulblastEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§int power = 0;§for (Cost cost :source.getCosts()) {§if (cost instanceof SacrificeAllCost) {§for (Permanent permanent : ((SacrificeAllCost) cost).getPermanents()) {§power += permanent.getPower().getValue();§}§}§}§if (power > 0) {§Player player = game.getPlayer(this.getTargetPointer().getFirst(game, source));§if (player != null) {§player.damage(power, source.getSourceId(), game, false, true);§} else {§Permanent creature = game.getPermanent(this.getTargetPointer().getFirst(game, source));§if (creature != null) {§creature.damage(power, source.getSourceId(), game, false, true);§}§}§}§return true;§}§}§
public class Terror extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("nonartifact, nonblack creature");§static {§filter.add(Predicates.not(new CardTypePredicate(CardType.ARTIFACT)));§filter.add(Predicates.not(new ColorPredicate(ObjectColor.BLACK)));§}§public Terror(UUID ownerId) {§super(ownerId, 182, "Terror", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{B}");§this.expansionSetCode = "10E";§this.getSpellAbility().addTarget(new TargetCreaturePermanent(filter));§this.getSpellAbility().addEffect(new DestroyTargetEffect(true));§}§public Terror(final Terror card) {§super(card);§}§@Override§public Terror copy() {§return new Terror(this);§}§}§
public class WallOfAir extends CardImpl {§public WallOfAir(UUID ownerId) {§super(ownerId, 124, "Wall of Air", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{U}{U}");§this.expansionSetCode = "10E";§this.subtype.add("Wall");§this.power = new MageInt(1);§this.toughness = new MageInt(5);§this.addAbility(DefenderAbility.getInstance());§this.addAbility(FlyingAbility.getInstance());§}§public WallOfAir(final WallOfAir card) {§super(card);§}§@Override§public WallOfAir copy() {§return new WallOfAir(this);§}§}§
public class DustToDust extends CardImpl {§public DustToDust(UUID ownerId) {§super(ownerId, 78, "Dust to Dust", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{1}{W}{W}");§this.expansionSetCode = "DRK";§this.getSpellAbility().addEffect(new ExileTargetEffect());§this.getSpellAbility().addTarget(new TargetArtifactPermanent(2));§}§public DustToDust(final DustToDust card) {§super(card);§}§@Override§public DustToDust copy() {§return new DustToDust(this);§}§}§
public class Riptide extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("blue creatures");§static {§filter.add(new ColorPredicate(ObjectColor.BLUE));§}§public Riptide(UUID ownerId) {§super(ownerId, 34, "Riptide", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{U}");§this.expansionSetCode = "DRK";§this.getSpellAbility().addEffect(new TapAllEffect(filter));§}§public Riptide(final Riptide card) {§super(card);§}§@Override§public Riptide copy() {§return new Riptide(this);§}§}§
public class AqueousForm extends CardImpl {§public AqueousForm(UUID ownerId) {§super(ownerId, 39, "Aqueous Form", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{U}");§this.expansionSetCode = "THS";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CantBeBlockedAttachedEffect(AttachmentType.AURA)));§this.addAbility(new AttacksAttachedTriggeredAbility(new ScryEffect(1), AttachmentType.AURA,false));§}§public AqueousForm(final AqueousForm card) {§super(card);§}§@Override§public AqueousForm copy() {§return new AqueousForm(this);§}§}§
public class BronzeSable extends CardImpl {§public BronzeSable(UUID ownerId) {§super(ownerId, 212, "Bronze Sable", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{2}");§this.expansionSetCode = "THS";§this.subtype.add("Sable");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§}§public BronzeSable(final BronzeSable card) {§super(card);§}§@Override§public BronzeSable copy() {§return new BronzeSable(this);§}§}§
public class DecoratedGriffin extends CardImpl {§public DecoratedGriffin(UUID ownerId) {§super(ownerId, 7, "Decorated Griffin", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{W}");§this.expansionSetCode = "THS";§this.subtype.add("Griffin");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new DecoratedGriffinPreventEffect(), new ManaCostsImpl("{1}{W}")));§}§public DecoratedGriffin(final DecoratedGriffin card) {§super(card);§}§@Override§public DecoratedGriffin copy() {§return new DecoratedGriffin(this);§}§}§class DecoratedGriffinPreventEffect extends PreventionEffectImpl {§public DecoratedGriffinPreventEffect() {§super(Duration.EndOfTurn, 1, false, true);§this.staticText = "Prevent the next 1 damage that would be dealt to you this turn";§}§public DecoratedGriffinPreventEffect(final DecoratedGriffinPreventEffect effect) {§super(effect);§}§@Override§public DecoratedGriffinPreventEffect copy() {§return new DecoratedGriffinPreventEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (super.applies(event, source, game) && event.getTargetId().equals(source.getControllerId())) {§return true;§}§return false;§}§}§
public class FlamecastWheel extends CardImpl {§public FlamecastWheel(UUID ownerId) {§super(ownerId, 215, "Flamecast Wheel", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "THS";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(3), new GenericManaCost(5));§ability.addTarget(new TargetCreaturePermanent());§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public FlamecastWheel(final FlamecastWheel card) {§super(card);§}§@Override§public FlamecastWheel copy() {§return new FlamecastWheel(this);§}§}§
public class HythoniaTheCruel extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("non-Gorgon creatures");§static {§filter.add(Predicates.not(new SubtypePredicate("Gorgon")));§}§public HythoniaTheCruel(UUID ownerId) {§super(ownerId, 91, "Hythonia the Cruel", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{4}{B}{B}");§this.expansionSetCode = "THS";§this.supertype.add("Legendary");§this.subtype.add("Gorgon");§this.power = new MageInt(4);§this.toughness = new MageInt(6);§this.addAbility(DeathtouchAbility.getInstance());§this.addAbility(new MonstrosityAbility("{6}{B}{B}", 3));§this.addAbility(new BecomesMonstrousSourceTriggeredAbility(new DestroyAllEffect(filter)));§}§public HythoniaTheCruel(final HythoniaTheCruel card) {§super(card);§}§@Override§public HythoniaTheCruel copy() {§return new HythoniaTheCruel(this);§}§}§
public class MistcutterHydra extends CardImpl {§private static final FilterObject filter = new FilterObject("from blue");§static {§filter.add(new ColorPredicate(ObjectColor.BLUE));§}§public MistcutterHydra(UUID ownerId) {§super(ownerId, 162, "Mistcutter Hydra", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{X}{G}");§this.expansionSetCode = "THS";§this.subtype.add("Hydra");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(new CantBeCounteredAbility());§this.addAbility(HasteAbility.getInstance());§this.addAbility(new ProtectionAbility(filter));§this.addAbility(new EntersBattlefieldAbility(new EntersBattlefieldWithXCountersEffect(CounterType.P1P1.createInstance())));§}§public MistcutterHydra(final MistcutterHydra card) {§super(card);§}§@Override§public MistcutterHydra copy() {§return new MistcutterHydra(this);§}§}§
public class PhalanxLeader extends CardImpl {§public PhalanxLeader(UUID ownerId) {§super(ownerId, 26, "Phalanx Leader", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{W}{W}");§this.expansionSetCode = "THS";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new HeroicAbility(new AddCountersAllEffect(CounterType.P1P1.createInstance(), new FilterControlledCreaturePermanent())));§}§public PhalanxLeader(final PhalanxLeader card) {§super(card);§}§@Override§public PhalanxLeader copy() {§return new PhalanxLeader(this);§}§}§
public class ReaperOfTheWilds extends CardImpl {§public ReaperOfTheWilds(UUID ownerId) {§super(ownerId, 201, "Reaper of the Wilds", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{B}{G}");§this.expansionSetCode = "THS";§this.subtype.add("Gorgon");§this.power = new MageInt(4);§this.toughness = new MageInt(5);§this.addAbility(new DiesCreatureTriggeredAbility(new ScryEffect(1), false, true));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(DeathtouchAbility.getInstance(), Duration.EndOfTurn), new ManaCostsImpl("{B}")));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(HexproofAbility.getInstance(), Duration.EndOfTurn), new ManaCostsImpl("{1}{G}")));§}§public ReaperOfTheWilds(final ReaperOfTheWilds card) {§super(card);§}§@Override§public ReaperOfTheWilds copy() {§return new ReaperOfTheWilds(this);§}§}§
public class SipOfHemlock extends CardImpl {§public SipOfHemlock(UUID ownerId) {§super(ownerId, 106, "Sip of Hemlock", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{4}{B}{B}");§this.expansionSetCode = "THS";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new LoseLifeTargetControllerEffect(2));§}§public SipOfHemlock(final SipOfHemlock card) {§super(card);§}§@Override§public SipOfHemlock copy() {§return new SipOfHemlock(this);§}§}§
public class ThassasEmissary extends CardImpl {§public ThassasEmissary(UUID ownerId) {§super(ownerId, 68, "Thassa's Emissary", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "THS";§this.subtype.add("Crab");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new BestowAbility(this, "{5}{U}"));§this.addAbility(new ThassasEmissaryTriggeredAbility(new DrawCardSourceControllerEffect(1), false));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(3,3)));§}§public ThassasEmissary(final ThassasEmissary card) {§super(card);§}§@Override§public ThassasEmissary copy() {§return new ThassasEmissary(this);§}§}§class ThassasEmissaryTriggeredAbility extends TriggeredAbilityImpl {§public ThassasEmissaryTriggeredAbility(Effect effect, boolean optional) {§super(Zone.BATTLEFIELD, effect, optional);§}§public ThassasEmissaryTriggeredAbility(final ThassasEmissaryTriggeredAbility ability) {§super(ability);§}§@Override§public ThassasEmissaryTriggeredAbility copy() {§return new ThassasEmissaryTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_PLAYER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (((DamagedEvent) event).isCombatDamage()) {§if (event.getSourceId().equals(this.sourceId)) {§return true;§}§Permanent p = game.getPermanent(event.getSourceId());§if (p != null && p.getAttachments().contains(this.getSourceId())) {§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever {this} or enchanted creature deals combat damage to a player, " + super.getRule();§}§}§
public class WarriorsLesson extends CardImpl {§public WarriorsLesson(UUID ownerId) {§super(ownerId, 184, "Warriors' Lesson", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{G}");§this.expansionSetCode = "THS";§Ability ability = new DealsDamageToAPlayerTriggeredAbility(new DrawCardSourceControllerEffect(1),false);§Effect effect = new GainAbilityTargetEffect(ability, Duration.EndOfTurn);§effect.setText("Until end of turn, up to two target creatures you control each gain \"Whenever this creature deals combat damage to a player, draw a card.\"");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCreaturePermanent(0,2));§}§public WarriorsLesson(final WarriorsLesson card) {§super(card);§}§@Override§public WarriorsLesson copy() {§return new WarriorsLesson(this);§}§}§
public class BlazingBladeAskari extends CardImpl {§public BlazingBladeAskari(UUID ownerId) {§super(ownerId, 146, "Blazing Blade Askari", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "TSP";§this.subtype.add("Human");§this.subtype.add("Knight");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new FlankingAbility());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BecomesColorSourceEffect(new ObjectColor(), Duration.EndOfTurn), new ManaCostsImpl("{2}")));§}§public BlazingBladeAskari(final BlazingBladeAskari card) {§super(card);§}§@Override§public BlazingBladeAskari copy() {§return new BlazingBladeAskari(this);§}§}§
public class DementiaSliver extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("All Slivers");§static {§filter.add(new SubtypePredicate("Sliver"));§}§public DementiaSliver(UUID ownerId) {§super(ownerId, 236, "Dementia Sliver", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{U}{B}");§this.expansionSetCode = "TSP";§this.subtype.add("Sliver");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§Ability gainedAbility = new ActivateIfConditionActivatedAbility(Zone.BATTLEFIELD, new NameACardEffect(NameACardEffect.TypeOfName.ALL), new TapSourceCost(), MyTurnCondition.getInstance());§gainedAbility.addEffect(new DementiaSliverEffect());§gainedAbility.addTarget(new TargetOpponent());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD,§new GainAbilityAllEffect(gainedAbility, Duration.WhileOnBattlefield, filter,§"All Slivers have \"{T}: Name a card. Target opponent reveals a card at random from his or her hand. If it's the named card, that player discards it\"")));§}§public DementiaSliver(final DementiaSliver card) {§super(card);§}§@Override§public DementiaSliver copy() {§return new DementiaSliver(this);§}§}§class DementiaSliverEffect extends OneShotEffect {§public DementiaSliverEffect() {§super(Outcome.Damage);§staticText = "Target opponent reveals a card at random from his or her hand. If it's the named card, that player discards it";§}§public DementiaSliverEffect(final DementiaSliverEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player opponent = game.getPlayer(targetPointer.getFirst(game, source));§MageObject sourceObject = game.getObject(source.getSourceId());§String cardName = (String) game.getState().getValue(source.getSourceId().toString() + NameACardEffect.INFO_KEY);§if (opponent != null && sourceObject != null && !cardName.isEmpty()) {§if (opponent.getHand().size() > 0) {§Cards revealed = new CardsImpl();§Card card = opponent.getHand().getRandom(game);§if (card != null) {§revealed.add(card);§opponent.revealCards(sourceObject.getName(), revealed, game);§if (card.getName().equals(cardName)) {§opponent.discard(card, source, game);§}§}§}§return true;§}§return false;§}§@Override§public DementiaSliverEffect copy() {§return new DementiaSliverEffect(this);§}§}§
public class FlamecoreElemental extends CardImpl {§public FlamecoreElemental(UUID ownerId) {§super(ownerId, 154, "Flamecore Elemental", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "TSP";§this.subtype.add("Elemental");§this.power = new MageInt(5);§this.toughness = new MageInt(4);§this.addAbility(new EchoAbility("{2}{R}{R}"));§}§public FlamecoreElemental(final FlamecoreElemental card) {§super(card);§}§@Override§public FlamecoreElemental copy() {§return new FlamecoreElemental(this);§}§}§
public class GriffinGuide extends CardImpl {§public GriffinGuide(UUID ownerId) {§super(ownerId, 21, "Griffin Guide", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{W}");§this.expansionSetCode = "TSP";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(2,2, Duration.WhileOnBattlefield));§ability.addEffect(new GainAbilityAttachedEffect(FlyingAbility.getInstance(), AttachmentType.AURA, Duration.WhileOnBattlefield, "and has flying"));§this.addAbility(ability);§this.addAbility(new DiesAttachedTriggeredAbility(new CreateTokenEffect(new GriffinToken()), "enchanted creature"));§}§public GriffinGuide(final GriffinGuide card) {§super(card);§}§@Override§public GriffinGuide copy() {§return new GriffinGuide(this);§}§}§class GriffinToken extends Token {§public GriffinToken() {§super("Griffin", "2/2 white Griffin creature token with flying");§cardType.add(CardType.CREATURE);§color.setWhite(true);§subtype.add("Griffin");§power = new MageInt(2);§toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§}§}§
public class LivingEnd extends CardImpl {§public LivingEnd(UUID ownerId) {§super(ownerId, 115, "Living End", Rarity.RARE, new CardType[]{CardType.SORCERY}, "");§this.expansionSetCode = "TSP";§this.color.setBlack(true);§this.addAbility(new SuspendAbility(3, new ManaCostsImpl("{2}{B}{B}"), this));§this.getSpellAbility().addEffect(new LivingEndEffect());§}§public LivingEnd(final LivingEnd card) {§super(card);§}§@Override§public LivingEnd copy() {§return new LivingEnd(this);§}§}§class LivingEndEffect extends OneShotEffect {§public LivingEndEffect() {§super(Outcome.Benefit);§this.staticText = "Each player exiles all creature cards from his or her graveyard, then sacrifices all creatures he or she controls, then puts all cards he or she exiled this way onto the battlefield";§}§public LivingEndEffect(final LivingEndEffect effect) {§super(effect);§}§@Override§public LivingEndEffect copy() {§return new LivingEndEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = game.getObject(source.getSourceId());§if (controller != null && sourceObject != null) {§Map<UUID, Set<Card>> exiledCards = new HashMap<>();§for (UUID playerId : game.getState().getPlayersInRange(source.getControllerId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§Set<Card> cardsPlayer = player.getGraveyard().getCards(new FilterCreatureCard(), game);§if (!cardsPlayer.isEmpty()) {§exiledCards.put(player.getId(), cardsPlayer);§player.moveCards(cardsPlayer, Zone.EXILED, source, game);§}§}§}§for (Permanent permanent : game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(), source.getControllerId(), game)) {§permanent.sacrifice(source.getSourceId(), game);§}§for (UUID playerId : game.getState().getPlayersInRange(source.getControllerId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§Set<Card> cardsPlayer = exiledCards.get(playerId);§if (cardsPlayer != null && !cardsPlayer.isEmpty()) {§player.moveCards(cardsPlayer, Zone.BATTLEFIELD, source, game, false, false, false, null);§}§}§}§return true;§}§return false;§}§}§
public class NantukoShaman extends CardImpl {§private static final FilterLandPermanent filter = new FilterLandPermanent();§static {§filter.add(new TappedPredicate());§}§public NantukoShaman(UUID ownerId) {§super(ownerId, 208, "Nantuko Shaman", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "TSP";§this.subtype.add("Insect");§this.subtype.add("Shaman");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§Ability ability = new ConditionalTriggeredAbility(§new EntersBattlefieldTriggeredAbility(new DrawCardSourceControllerEffect(1)),§new PermanentsOnTheBattlefieldCondition(filter, PermanentsOnTheBattlefieldCondition.CountType.EQUAL_TO, 0),§"When {this} enters the battlefield, if you control no tapped lands, draw a card");§this.addAbility(ability);§this.addAbility(new SuspendAbility(1, new ManaCostsImpl("{2}{G}{G}"), this));§}§public NantukoShaman(final NantukoShaman card) {§super(card);§}§@Override§public NantukoShaman copy() {§return new NantukoShaman(this);§}§}§
public class PulmonicSliver extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Sliver", "All Sliver creatures");§private static final FilterPermanent filterSlivers = new FilterPermanent("Sliver", "All Slivers");§public PulmonicSliver(UUID ownerId) {§super(ownerId, 36, "Pulmonic Sliver", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{W}{W}");§this.expansionSetCode = "TSP";§this.subtype.add("Sliver");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAllEffect(§FlyingAbility.getInstance(), Duration.WhileOnBattlefield,§filter, "All Sliver creatures have flying.")));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAllEffect(§new PutIntoGraveFromAnywhereSourceAbility(new ReturnToLibrarySpellEffect(true)), Duration.WhileOnBattlefield,§filterSlivers, "All Slivers have \"If this permanent would be put into a graveyard, you may put it on top of its owner's library instead.\"")));§}§public PulmonicSliver(final PulmonicSliver card) {§super(card);§}§@Override§public PulmonicSliver copy() {§return new PulmonicSliver(this);§}§}§
public class SkitteringMonstrosity extends CardImpl {§private static final FilterSpell filter = new FilterSpell("a creature spell");§static {§filter.add(new CardTypePredicate(CardType.CREATURE));§}§public SkitteringMonstrosity(UUID ownerId) {§super(ownerId, 129, "Skittering Monstrosity", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{B}{B}");§this.expansionSetCode = "TSP";§this.subtype.add("Horror");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(new SpellCastControllerTriggeredAbility(new SacrificeSourceEffect(), filter, false));§}§public SkitteringMonstrosity(final SkitteringMonstrosity card) {§super(card);§}§@Override§public SkitteringMonstrosity copy() {§return new SkitteringMonstrosity(this);§}§}§
public class SuddenSpoiling extends CardImpl {§public SuddenSpoiling(UUID ownerId) {§super(ownerId, 135, "Sudden Spoiling", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{1}{B}{B}");§this.expansionSetCode = "TSP";§this.addAbility(new SplitSecondAbility());§this.getSpellAbility().addEffect(new SuddenSpoilingEffect(Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetPlayer());§}§public SuddenSpoiling(final SuddenSpoiling card) {§super(card);§}§@Override§public SuddenSpoiling copy() {§return new SuddenSpoiling(this);§}§}§class SuddenSpoilingEffect extends ContinuousEffectImpl {§public SuddenSpoilingEffect(Duration duration) {§super(duration, Outcome.LoseAbility);§staticText = "Until end of turn, creatures target player controls lose all abilities and have base power and toughness 0/2";§}§public SuddenSpoilingEffect(final SuddenSpoilingEffect effect) {§super(effect);§}§@Override§public SuddenSpoilingEffect copy() {§return new SuddenSpoilingEffect(this);§}§@Override§public void init(Ability source, Game game) {§super.init(source, game);§Player player = game.getPlayer(this.getTargetPointer().getFirst(game, source));§if (player != null) {§for (Permanent perm: game.getState().getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(), player.getId(), game)) {§affectedObjectList.add(new MageObjectReference(perm, game));§}§}§}§@Override§public boolean apply(Layer layer, SubLayer sublayer, Ability source, Game game) {§Player player = game.getPlayer(this.getTargetPointer().getFirst(game, source));§if (player != null) {§for (Permanent permanent : game.getState().getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(), player.getId(), game)) {§if (affectedObjectList.contains(new MageObjectReference(permanent, game))) {§switch (layer) {§case AbilityAddingRemovingEffects_6:§permanent.removeAllAbilities(source.getSourceId(), game);§break;§case PTChangingEffects_7:§if (sublayer.equals(SubLayer.SetPT_7b)) {§permanent.getPower().setValue(0);§permanent.getToughness().setValue(2);§}§}§}§}§return true;§}§return false;§}§@Override§public boolean apply(Game game, Ability source) {§return false;§}§@Override§public boolean hasLayer(Layer layer) {§return layer == Layer.AbilityAddingRemovingEffects_6 || layer == Layer.PTChangingEffects_7;§}§}§
public class UnyaroBees extends CardImpl {§public UnyaroBees(UUID ownerId) {§super(ownerId, 231, "Unyaro Bees", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{G}{G}{G}");§this.expansionSetCode = "TSP";§this.subtype.add("Insect");§this.power = new MageInt(0);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 1, Duration.EndOfTurn), new ManaCostsImpl("{G}")));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(2), new ManaCostsImpl("{3}{G}"));§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public UnyaroBees(final UnyaroBees card) {§super(card);§}§@Override§public UnyaroBees copy() {§return new UnyaroBees(this);§}§}§
public class CallOfTheHerd extends CardImpl {§public CallOfTheHerd(UUID ownerId) {§super(ownerId, 74, "Call of the Herd", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{G}");§this.expansionSetCode = "TSB";§this.getSpellAbility().addEffect(new CreateTokenEffect(new ElephantToken()));§this.addAbility(new FlashbackAbility(new ManaCostsImpl("{3}{G}"), TimingRule.SORCERY));§}§public CallOfTheHerd(final CallOfTheHerd card) {§super(card);§}§@Override§public CallOfTheHerd copy() {§return new CallOfTheHerd(this);§}§}§
public class MoorishCavalry extends CardImpl {§public MoorishCavalry(UUID ownerId) {§super(ownerId, 11, "Moorish Cavalry", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}{W}");§this.expansionSetCode = "TSB";§this.subtype.add("Human");§this.subtype.add("Knight");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(TrampleAbility.getInstance());§}§public MoorishCavalry(final MoorishCavalry card) {§super(card);§}§@Override§public MoorishCavalry copy() {§return new MoorishCavalry(this);§}§}§
public class WhirlingDervish extends CardImpl {§private static final String ruleText = "At the beginning of each end step, if {this} dealt damage to an opponent this turn, put a +1/+1 counter on it.";§private static final FilterCard filter = new FilterCard("black");§static {§filter.add(new ColorPredicate(ObjectColor.BLACK));§}§public WhirlingDervish(UUID ownerId) {§super(ownerId, 90, "Whirling Dervish", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{G}{G}");§this.expansionSetCode = "TSB";§this.subtype.add("Human");§this.subtype.add("Monk");§this.color.setGreen(true);§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new ProtectionAbility(filter));§TriggeredAbility triggered = new OnEventTriggeredAbility(GameEvent.EventType.END_TURN_STEP_PRE, "beginning of each end step", true, new AddCountersSourceEffect(CounterType.P1P1.createInstance()));§this.addAbility(new ConditionalTriggeredAbility(triggered, new DealtDamageToAnOpponent(), ruleText));§}§public WhirlingDervish(final WhirlingDervish card) {§super(card);§}§@Override§public WhirlingDervish copy() {§return new WhirlingDervish(this);§}§}§
public class CephalidSage extends CardImpl {§public CephalidSage(UUID ownerId) {§super(ownerId, 29, "Cephalid Sage", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "TOR";§this.subtype.add("Cephalid");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(§new GainAbilitySourceEffect(new EntersBattlefieldTriggeredAbility(new DrawDiscardControllerEffect(3, 2))),§new CardsInControllerGraveCondition(7),§"As long as seven or more cards are in your graveyard, {this} has \"When {this} enters the battlefield, draw three cards, then discard two cards.\""));§ability.setAbilityWord(AbilityWord.THRESHOLD);§this.addAbility(ability);§}§public CephalidSage(final CephalidSage card) {§super(card);§}§@Override§public CephalidSage copy() {§return new CephalidSage(this);§}§}§
public class HellBentRaider extends CardImpl {§private static final FilterCard protectionFilter = new FilterCard("White");§static {§protectionFilter.add(new ColorPredicate(ObjectColor.WHITE));§}§public HellBentRaider(UUID ownerId) {§super(ownerId, 101, "Hell-Bent Raider", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{R}{R}");§this.expansionSetCode = "TOR";§this.subtype.add("Human");§this.subtype.add("Barbarian");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FirstStrikeAbility.getInstance());§this.addAbility(HasteAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new GainAbilitySourceEffect( new ProtectionAbility(protectionFilter), Duration.EndOfTurn),§new DiscardCardCost(true));§this.addAbility(ability);§}§public HellBentRaider(final HellBentRaider card) {§super(card);§}§@Override§public HellBentRaider copy() {§return new HellBentRaider(this);§}§}§
public class NantukoCalmer extends CardImpl {§public NantukoCalmer(UUID ownerId) {§super(ownerId, 132, "Nantuko Calmer", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{G}{G}");§this.expansionSetCode = "TOR";§this.subtype.add("Insect");§this.subtype.add("Druid");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new ManaCostsImpl("{G}"));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetEnchantmentPermanent());§this.addAbility(ability);§ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(§new BoostSourceEffect(1, 1, Duration.WhileOnBattlefield), new CardsInControllerGraveCondition(7),§"{this} gets +1/+1 as long as seven or more cards are in your graveyard"));§ability.setAbilityWord(AbilityWord.THRESHOLD);§this.addAbility(ability);§}§public NantukoCalmer(final NantukoCalmer card) {§super(card);§}§@Override§public NantukoCalmer copy() {§return new NantukoCalmer(this);§}§}§
public class RancidEarth extends CardImpl {§public RancidEarth(UUID ownerId) {§super(ownerId, 78, "Rancid Earth", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{1}{B}{B}");§this.expansionSetCode = "TOR";§this.getSpellAbility().addEffect(new ConditionalOneShotEffect(§new RancidEarthEffect(),§new DestroyTargetEffect(),§new CardsInControllerGraveCondition(7),§"Destroy target land.<br/><br/><i>Threshold</i> - If seven or more cards are in your graveyard, instead destroy that land and Rancid Earth deals 1 damage to each creature and each player."));§this.getSpellAbility().addTarget(new TargetLandPermanent());§}§public RancidEarth(final RancidEarth card) {§super(card);§}§@Override§public RancidEarth copy() {§return new RancidEarth(this);§}§}§class RancidEarthEffect extends OneShotEffect {§public RancidEarthEffect() {§super(Outcome.DestroyPermanent);§this.staticText = "destroy that land and Rancid Earth deals 1 damage to each creature and each player";§}§public RancidEarthEffect(final RancidEarthEffect effect) {§super(effect);§}§@Override§public RancidEarthEffect copy() {§return new RancidEarthEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Effect effect1 = new DestroyTargetEffect("destroy that land");§effect1.apply(game, source);§return new DamageEverythingEffect(1).apply(game, source);§}§}§
public class ViolentEruption extends CardImpl {§public ViolentEruption(UUID ownerId) {§super(ownerId, 117, "Violent Eruption", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{R}{R}{R}");§this.expansionSetCode = "TOR";§this.getSpellAbility().addEffect(new DamageMultiEffect(4));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayerAmount(4));§this.addAbility(new MadnessAbility(this, new ManaCostsImpl("{1}{R}{R}")));§}§public ViolentEruption(final ViolentEruption card) {§super(card);§}§@Override§public ViolentEruption copy() {§return new ViolentEruption(this);§}§}§
public class AuraThief extends CardImpl {§public AuraThief(UUID ownerId) {§super(ownerId, 26, "Aura Thief", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "UDS";§this.subtype.add("Illusion");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new DiesTriggeredAbility(new AuraThiefDiesTriggeredEffect()));§}§public AuraThief(final AuraThief card) {§super(card);§}§@Override§public AuraThief copy() {§return new AuraThief(this);§}§}§class AuraThiefDiesTriggeredEffect extends OneShotEffect {§public AuraThiefDiesTriggeredEffect() {§super(Outcome.Benefit);§this.staticText = "gain control of all enchantments. <i>(You don't get to move Auras.)</i>";§}§public AuraThiefDiesTriggeredEffect(final AuraThiefDiesTriggeredEffect effect) {§super(effect);§}§@Override§public AuraThiefDiesTriggeredEffect copy() {§return new AuraThiefDiesTriggeredEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§boolean ret = false;§for(Permanent enchantment : game.getBattlefield().getActivePermanents(new FilterEnchantmentPermanent(), source.getControllerId(), source.getControllerId(), game)) {§ContinuousEffect gainControl = new GainControlTargetEffect(Duration.EndOfGame);§gainControl.setTargetPointer(new FixedTarget(enchantment.getId()));§game.addEffect(gainControl, source);§ret = true;§}§return ret;§}§}§
public class FalseProphet extends CardImpl {§public FalseProphet(UUID ownerId) {§super(ownerId, 6, "False Prophet", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{W}{W}");§this.expansionSetCode = "UDS";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new DiesTriggeredAbility(new ExileAllEffect(new FilterCreaturePermanent())));§}§public FalseProphet(final FalseProphet card) {§super(card);§}§@Override§public FalseProphet copy() {§return new FalseProphet(this);§}§}§
public class Masticore extends CardImpl {§public Masticore(UUID ownerId) {§super(ownerId, 134, "Masticore", Rarity.RARE, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{4}");§this.expansionSetCode = "UDS";§this.subtype.add("Masticore");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new SacrificeSourceUnlessPaysEffect(new DiscardTargetCost(new TargetCardInHand())), TargetController.YOU, false));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new GenericManaCost(2));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new GenericManaCost(2)));§}§public Masticore(final Masticore card) {§super(card);§}§@Override§public Masticore copy() {§return new Masticore(this);§}§}§
public class SigilOfSleep extends CardImpl {§private final UUID originalId;§public SigilOfSleep(UUID ownerId) {§super(ownerId, 46, "Sigil of Sleep", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{U}");§this.expansionSetCode = "UDS";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§Effect effect = new ReturnToHandTargetEffect();§effect.setText("return target creature that player controls to its owner's hand");§ability = new DealsDamageToAPlayerAttachedTriggeredAbility(effect, "enchanted", false, true, false);§originalId = ability.getOriginalId();§this.addAbility(ability);§}§@Override§public void adjustTargets(Ability ability, Game game) {§if (ability.getOriginalId().equals(originalId)) {§UUID playerId = ability.getEffects().get(0).getTargetPointer().getFirst(game, ability);§if (playerId != null) {§FilterCreaturePermanent filter = new FilterCreaturePermanent("creature that player controls");§filter.add(new ControllerIdPredicate(playerId));§Target target = new TargetCreaturePermanent(filter);§ability.getTargets().clear();§ability.addTarget(target);§ability.getEffects().get(0).setTargetPointer(new FirstTargetPointer());§}§}§}§public SigilOfSleep(final SigilOfSleep card) {§super(card);§this.originalId = card.originalId;§}§@Override§public SigilOfSleep copy() {§return new SigilOfSleep(this);§}§}§
public class AngelsTrumpet extends CardImpl {§public AngelsTrumpet(UUID ownerId) {§super(ownerId, 121, "Angel's Trumpet", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "ULG";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAllEffect(VigilanceAbility.getInstance(), Duration.WhileOnBattlefield, new FilterCreaturePermanent())));§this.addAbility(new BeginningOfEndStepTriggeredAbility(new AngelsTrumpetTapEffect(), TargetController.ANY, false), new AttackedThisTurnWatcher());§}§public AngelsTrumpet(final AngelsTrumpet card) {§super(card);§}§@Override§public AngelsTrumpet copy() {§return new AngelsTrumpet(this);§}§}§class AngelsTrumpetTapEffect extends OneShotEffect {§AngelsTrumpetTapEffect() {§super(Outcome.Tap);§this.staticText = "tap all untapped creatures that player controls that didn't attack this turn. Angel's Trumpet deals damage to the player equal to the number of creatures tapped this way";§}§AngelsTrumpetTapEffect(final AngelsTrumpetTapEffect effect) {§super(effect);§}§@Override§public AngelsTrumpetTapEffect copy() {§return new AngelsTrumpetTapEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(game.getActivePlayerId());§int count = 0;§if (player != null) {§for (Permanent creature : game.getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(), player.getId(), game)) {§if (creature.isTapped()) {§continue;§}§AttackedThisTurnWatcher watcher = (AttackedThisTurnWatcher) game.getState().getWatchers().get("AttackedThisTurn");§if (watcher != null && watcher.getAttackedThisTurnCreatures().contains(creature.getId())) {§continue;§}§creature.tap(game);§count++;§}§if (count > 0) {§player.damage(count, source.getSourceId(), game, false, true);§}§return true;§}§return false;§}§}§
public class DevoutHarpist extends CardImpl {§private static final FilterEnchantmentPermanent filter = new FilterEnchantmentPermanent("Auras attached to a creature");§static§{§filter.add(new SubtypePredicate("Aura"));§filter.add(new DevoutHarpistPredicate());§}§public DevoutHarpist(UUID ownerId) {§super(ownerId, 6, "Devout Harpist", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{W}");§this.expansionSetCode = "ULG";§this.subtype.add("Human");§this.color.setWhite(true);§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new TapSourceCost());§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§}§public DevoutHarpist(final DevoutHarpist card) {§super(card);§}§@Override§public DevoutHarpist copy() {§return new DevoutHarpist(this);§}§}§class DevoutHarpistPredicate implements ObjectPlayerPredicate<ObjectPlayer<Permanent>> {§@Override§public boolean apply(ObjectPlayer<Permanent> input, Game game) {§Permanent attachment = input.getObject();§if (attachment != null) {§Permanent permanent = game.getPermanent(attachment.getAttachedTo());§if (permanent != null && permanent.getCardType().contains(CardType.CREATURE)) {§return true;§}§}§return false;§}§@Override§public String toString() {§return "Attached to a creature";§}§}§
public class IronWill extends CardImpl {§public IronWill(UUID ownerId) {§super(ownerId, 10, "Iron Will", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{W}");§this.expansionSetCode = "ULG";§this.getSpellAbility().addEffect(new BoostTargetEffect(0, 4, Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.addAbility(new CyclingAbility(new ManaCostsImpl("{2}")));§}§public IronWill(final IronWill card) {§super(card);§}§@Override§public IronWill copy() {§return new IronWill(this);§}§}§
public class PeaceAndQuiet extends CardImpl {§public PeaceAndQuiet(UUID ownerId) {§super(ownerId, 17, "Peace and Quiet", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{W}");§this.expansionSetCode = "ULG";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addTarget(new TargetPermanent(2, new FilterEnchantmentPermanent()));§}§public PeaceAndQuiet(final PeaceAndQuiet card) {§super(card);§}§@Override§public PeaceAndQuiet copy() {§return new PeaceAndQuiet(this);§}§}§
public class RingOfGix extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("artifact, creature, or land");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.ARTIFACT),§new CardTypePredicate(CardType.CREATURE),§new CardTypePredicate(CardType.LAND)));§}§public RingOfGix(UUID ownerId) {§super(ownerId, 131, "Ring of Gix", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "ULG";§this.addAbility(new EchoAbility("{3}"));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TapTargetEffect(), new ManaCostsImpl("{1}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§}§public RingOfGix(final RingOfGix card) {§super(card);§}§@Override§public RingOfGix copy() {§return new RingOfGix(this);§}§}§
public class Tinker extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("an artifact");§static {§filter.add(new CardTypePredicate(CardType.ARTIFACT));§}§public Tinker(UUID ownerId) {§super(ownerId, 45, "Tinker", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{2}{U}");§this.expansionSetCode = "ULG";§this.getSpellAbility().addCost(new SacrificeTargetCost(new TargetControlledPermanent(filter)));§TargetCardInLibrary target = new TargetCardInLibrary(new FilterArtifactCard());§this.getSpellAbility().addEffect(new SearchLibraryPutInPlayEffect(target));§}§public Tinker(final Tinker card) {§super(card);§}§@Override§public Tinker copy() {§return new Tinker(this);§}§}§
public class Acridian extends CardImpl {§public Acridian (UUID ownerId) {§super(ownerId, 230, "Acridian", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "USG";§this.subtype.add("Insect");§this.power = new MageInt(2);§this.toughness = new MageInt(4);§this.addAbility(new EchoAbility("{1}{G}"));§}§public Acridian (final Acridian card) {§super(card);§}§@Override§public Acridian copy() {§return new Acridian(this);§}§}§
public class Bravado extends CardImpl {§public Bravado(UUID ownerId) {§super(ownerId, 177, "Bravado", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{R}");§this.expansionSetCode = "USG";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BravadoBoostEnchantedEffect()));§}§public Bravado(final Bravado card) {§super(card);§}§@Override§public Bravado copy() {§return new Bravado(this);§}§}§class BravadoBoostEnchantedEffect extends ContinuousEffectImpl {§public BravadoBoostEnchantedEffect() {§super(Duration.WhileOnBattlefield, Layer.PTChangingEffects_7, SubLayer.ModifyPT_7c, Outcome.BoostCreature);§staticText = "Enchanted creature gets +1/+1 for each other creature you control";§}§public BravadoBoostEnchantedEffect(final BravadoBoostEnchantedEffect effect) {§super(effect);§}§@Override§public BravadoBoostEnchantedEffect copy() {§return new BravadoBoostEnchantedEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent();§int count = game.getBattlefield().count(filter, source.getSourceId(), source.getControllerId(), game) - 1;§if (count > 0) {§Permanent enchantment = game.getPermanent(source.getSourceId());§if (enchantment != null && enchantment.getAttachedTo() != null) {§Permanent creature = game.getPermanent(enchantment.getAttachedTo());§if (creature != null) {§creature.addPower(count);§creature.addToughness(count);§return true;§}§}§}§return false;§}§}§
public class Congregate extends CardImpl {§public Congregate(UUID ownerId) {§super(ownerId, 8, "Congregate", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{3}{W}");§this.expansionSetCode = "USG";§this.getSpellAbility().addEffect(new GainLifeTargetEffect(new PermanentsOnBattlefieldCount(new FilterCreaturePermanent("creature on the battlefield"), 2)));§this.getSpellAbility().addTarget(new TargetPlayer());§}§public Congregate(final Congregate card) {§super(card);§}§@Override§public Congregate copy() {§return new Congregate(this);§}§}§
public class ElvishLyrist extends CardImpl {§public ElvishLyrist(UUID ownerId) {§super(ownerId, 248, "Elvish Lyrist", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "USG";§this.subtype.add("Elf");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new ManaCostsImpl("{G}"));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetPermanent(new FilterEnchantmentPermanent()));§this.addAbility(ability);§}§public ElvishLyrist(final ElvishLyrist card) {§super(card);§}§@Override§public ElvishLyrist copy() {§return new ElvishLyrist(this);§}§}§
public class GildedDrake extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature an opponent controls");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public GildedDrake(UUID ownerId) {§super(ownerId, 76, "Gilded Drake", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "USG";§this.subtype.add("Drake");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new GildedDrakeEffect());§ability.addTarget(new TargetCreaturePermanent(0, 1, filter, false));§this.addAbility(ability);§}§public GildedDrake(final GildedDrake card) {§super(card);§}§@Override§public GildedDrake copy() {§return new GildedDrake(this);§}§}§class GildedDrakeEffect extends OneShotEffect {§public GildedDrakeEffect() {§super(Outcome.GainControl);§this.staticText = "exchange control of {this} and up to one target creature an opponent controls. If you don't make an exchange, sacrifice {this}. This ability can't be countered except by spells and abilities";§}§public GildedDrakeEffect(final GildedDrakeEffect effect) {§super(effect);§}§@Override§public GildedDrakeEffect copy() {§return new GildedDrakeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent sourceObject = game.getPermanent(source.getSourceId());§Permanent targetPermanent;§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§if (targetPointer.getFirst(game, source) != null) {§targetPermanent = game.getPermanent(targetPointer.getFirst(game, source));§if (targetPermanent != null) {§ContinuousEffect effect = new ExchangeControlTargetEffect(Duration.EndOfGame, "", true);§effect.setTargetPointer(targetPointer);§game.addEffect(effect, source);§return true;§}§}§sourceObject.sacrifice(source.getSourceId(), game);§return true;§}§return false;§}§}§
public class Humble extends CardImpl {§public Humble(UUID ownerId) {§super(ownerId, 18, "Humble", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{W}");§this.expansionSetCode = "USG";§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new LoseAllAbilitiesTargetEffect(Duration.EndOfTurn));§this.getSpellAbility().addEffect(new SetPowerToughnessTargetEffect(0, 1, Duration.EndOfTurn));§}§public Humble(final Humble card) {§super(card);§}§@Override§public Humble copy() {§return new Humble(this);§}§}§
public class MonkRealist extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("enchantment");§static {§filter.add(new CardTypePredicate(CardType.ENCHANTMENT));§}§public MonkRealist(UUID ownerId) {§super(ownerId, 21, "Monk Realist", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "USG";§this.subtype.add("Human");§this.subtype.add("Monk");§this.subtype.add("Cleric");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new EntersBattlefieldTriggeredAbility(new DestroyTargetEffect(), false);§Target target = new TargetPermanent(filter);§ability.addTarget(target);§this.addAbility(ability);§}§public MonkRealist(final MonkRealist card) {§super(card);§}§@Override§public MonkRealist copy() {§return new MonkRealist(this);§}§}§
public class PollutedMire extends CardImpl {§public PollutedMire(UUID ownerId) {§super(ownerId, 323, "Polluted Mire", Rarity.COMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "USG";§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new CyclingAbility(new ManaCostsImpl("{2}")));§this.addAbility(new BlackManaAbility());§}§public PollutedMire(final PollutedMire card) {§super(card);§}§@Override§public PollutedMire copy() {§return new PollutedMire(this);§}§}§
public class RuneOfProtectionRed extends CardImpl {§public RuneOfProtectionRed(UUID ownerId) {§super(ownerId, 40, "Rune of Protection: Red", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{W}");§this.expansionSetCode = "USG";§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RuneOfProtectionRedEffect() , new ManaCostsImpl("W")));§this.addAbility(new CyclingAbility(new ManaCostsImpl("{2}")));§}§public RuneOfProtectionRed(final RuneOfProtectionRed card) {§super(card);§}§@Override§public RuneOfProtectionRed copy() {§return new RuneOfProtectionRed(this);§}§}§class RuneOfProtectionRedEffect extends PreventionEffectImpl {§private static final FilterObject filter = new FilterObject("red source");§static {§filter.add(new ColorPredicate(ObjectColor.RED));§}§private TargetSource target;§public RuneOfProtectionRedEffect() {§super(Duration.EndOfTurn);§target = new TargetSource(filter);§staticText = "The next time a red source of your choice would deal damage to you this turn, prevent that damage";§}§public RuneOfProtectionRedEffect(final RuneOfProtectionRedEffect effect) {§super(effect);§this.target = effect.target.copy();§}§@Override§public RuneOfProtectionRedEffect copy() {§return new RuneOfProtectionRedEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public void init(Ability source, Game game) {§this.target.choose(Outcome.PreventDamage, source.getControllerId(), source.getSourceId(), game);§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§if (event.getTargetId().equals(source.getControllerId()) && event.getSourceId().equals(target.getFirstTarget())) {§preventDamage(event, source, target.getFirstTarget(), game);§return true;§}§return false;§}§private void preventDamage(GameEvent event, Ability source, UUID target, Game game) {§GameEvent preventEvent = new GameEvent(GameEvent.EventType.PREVENT_DAMAGE, target, source.getSourceId(), source.getControllerId(), event.getAmount(), false);§if (!game.replaceEvent(preventEvent)) {§int damage = event.getAmount();§event.setAmount(0);§this.used = true;§game.fireEvent(GameEvent.getEvent(GameEvent.EventType.PREVENTED_DAMAGE, target, source.getSourceId(), source.getControllerId(), damage));§}§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (!this.used && super.applies(event, source, game)) {§if (event.getTargetId().equals(source.getControllerId()) && event.getSourceId().equals(target.getFirstTarget())) {§return true;§}§}§return false;§}§}§
public class Smokestack extends CardImpl {§public Smokestack(UUID ownerId) {§super(ownerId, 309, "Smokestack", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "USG";§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new AddCountersSourceEffect(new Counter("Soot")), TargetController.YOU, true));§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new SmokestackEffect(), TargetController.ANY, false));§}§public Smokestack(final Smokestack card) {§super(card);§}§@Override§public Smokestack copy() {§return new Smokestack(this);§}§}§class SmokestackEffect extends OneShotEffect {§public SmokestackEffect() {§super(Outcome.Sacrifice);§this.staticText = "that player sacrifices a permanent for each soot counter on Smokestack";§}§public SmokestackEffect(final SmokestackEffect effect) {§super(effect);§}§@Override§public SmokestackEffect copy() {§return new SmokestackEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player activePlayer = game.getPlayer(getTargetPointer().getFirst(game, source));§Permanent sourcePermanent = game.getPermanentOrLKIBattlefield(source.getSourceId());§if (activePlayer != null && sourcePermanent != null) {§int count = sourcePermanent.getCounters().getCount("Soot");§if (count > 0) {§int amount = Math.min(count, game.getBattlefield().countAll(new FilterControlledPermanent(), activePlayer.getId(), game));§Target target = new TargetControlledPermanent(amount, amount, new FilterControlledPermanent(), false);§if (target.canChoose(activePlayer.getId(), game)) {§while (!target.isChosen() && target.canChoose(activePlayer.getId(), game) && activePlayer.canRespond()) {§activePlayer.choose(Outcome.Sacrifice, target, source.getSourceId(), game);§}§for (int idx = 0; idx < target.getTargets().size(); idx++) {§Permanent permanent = game.getPermanent(target.getTargets().get(idx));§if (permanent != null) {§permanent.sacrifice(source.getSourceId(), game);§}§}§}§}§return true;§}§return false;§}§}§
public class TreefolkSeedlings extends CardImpl {§final static FilterControlledPermanent filterLands = new FilterControlledPermanent("Forests you control");§static {§filterLands.add(new SubtypePredicate("Forest"));§}§public TreefolkSeedlings(UUID ownerId) {§super(ownerId, 278, "Treefolk Seedlings", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "USG";§this.subtype.add("Treefolk");§this.power = new MageInt(2);§this.toughness = new MageInt(0);§this.addAbility(new SimpleStaticAbility(Zone.ALL, new SetToughnessSourceEffect(new PermanentsOnBattlefieldCount(filterLands), Duration.EndOfGame)));§}§public TreefolkSeedlings(final TreefolkSeedlings card) {§super(card);§}§@Override§public TreefolkSeedlings copy() {§return new TreefolkSeedlings(this);§}§}§
public class WitchEngine extends CardImpl {§public WitchEngine(UUID ownerId) {§super(ownerId, 169, "Witch Engine", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{B}");§this.expansionSetCode = "USG";§this.subtype.add("Horror");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new SwampwalkAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BasicManaEffect(new Mana(0, 0, 0, 0, 4, 0, 0, 0)), new TapSourceCost());§ability.addEffect(new WitchEngineEffect());§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§}§public WitchEngine(final WitchEngine card) {§super(card);§}§@Override§public WitchEngine copy() {§return new WitchEngine(this);§}§}§class WitchEngineEffect extends ContinuousEffectImpl {§public WitchEngineEffect() {§super(Duration.Custom, Layer.ControlChangingEffects_2, SubLayer.NA, Outcome.GainControl);§staticText = "target opponent gains control of {this}";§}§public WitchEngineEffect(final WitchEngineEffect effect) {§super(effect);§}§@Override§public WitchEngineEffect copy() {§return new WitchEngineEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = (Permanent) source.getSourceObjectIfItStillExists(game);§if (permanent != null) {§return permanent.changeControllerId(source.getFirstTarget(), game);§} else {§discard();§}§return false;§}§}§
public class ChaosWarp extends CardImpl {§public ChaosWarp(UUID ownerId) {§super(ownerId, 154, "Chaos Warp", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{2}{R}");§this.expansionSetCode = "VMA";§this.getSpellAbility().addEffect(new ChaosWarpShuffleIntoLibraryEffect());§this.getSpellAbility().addTarget(new TargetPermanent());§this.getSpellAbility().addEffect(new ChaosWarpRevealEffect());§}§public ChaosWarp(final ChaosWarp card) {§super(card);§}§@Override§public ChaosWarp copy() {§return new ChaosWarp(this);§}§}§class ChaosWarpShuffleIntoLibraryEffect extends OneShotEffect {§public ChaosWarpShuffleIntoLibraryEffect() {§super(Outcome.Detriment);§this.staticText = "The owner of target permanent shuffles it into his or her library";§}§public ChaosWarpShuffleIntoLibraryEffect(final ChaosWarpShuffleIntoLibraryEffect effect) {§super(effect);§}§@Override§public ChaosWarpShuffleIntoLibraryEffect copy() {§return new ChaosWarpShuffleIntoLibraryEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(targetPointer.getFirst(game, source));§if (permanent != null) {§Player owner = game.getPlayer(permanent.getOwnerId());§if (owner != null) {§owner.moveCardToLibraryWithInfo(permanent, source.getSourceId(), game, Zone.BATTLEFIELD, true, true);§owner.shuffleLibrary(game);§return true;§}§}§return false;§}§}§class ChaosWarpRevealEffect extends OneShotEffect {§public ChaosWarpRevealEffect() {§super(Outcome.PutCardInPlay);§this.staticText = "then reveals the top card of his or her library. If it's a permanent card, he or she puts it onto the battlefield";§}§public ChaosWarpRevealEffect(final ChaosWarpRevealEffect effect) {§super(effect);§}§@Override§public ChaosWarpRevealEffect copy() {§return new ChaosWarpRevealEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = (Permanent) game.getLastKnownInformation(targetPointer.getFirst(game, source), Zone.BATTLEFIELD);§if (permanent == null) {§return false;§}§Player owner = game.getPlayer(permanent.getOwnerId());§MageObject sourceObject = game.getObject(source.getSourceId());§if (owner == null || sourceObject == null) {§return false;§}§if (owner.getLibrary().size() > 0) {§Card card = owner.getLibrary().getFromTop(game);§if (card != null) {§Cards cards = new CardsImpl(card);§owner.revealCards(sourceObject.getIdName(), cards, game);§if (new FilterPermanentCard().match(card, game)) {§owner.moveCards(card, Zone.BATTLEFIELD, source, game);§}§}§}§return true;§}§}§
public class KaerveksTorch extends CardImpl {§public KaerveksTorch(UUID ownerId) {§super(ownerId, 175, "Kaervek's Torch", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{X}{R}");§this.expansionSetCode = "VMA";§this.addAbility(new SimpleStaticAbility(Zone.STACK, new KaerveksTorchCostIncreaseEffect()));§this.getSpellAbility().addEffect(new DamageTargetEffect(new ManacostVariableValue()));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§}§public KaerveksTorch(final KaerveksTorch card) {§super(card);§}§@Override§public KaerveksTorch copy() {§return new KaerveksTorch(this);§}§}§class KaerveksTorchCostIncreaseEffect extends CostModificationEffectImpl {§KaerveksTorchCostIncreaseEffect() {§super(Duration.WhileOnStack, Outcome.Benefit, CostModificationType.INCREASE_COST);§staticText = "Spells that target {this} cost {2} more to cast";§}§KaerveksTorchCostIncreaseEffect(KaerveksTorchCostIncreaseEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source, Ability abilityToModify) {§CardUtil.increaseCost(abilityToModify, 2);§return true;§}§@Override§public boolean applies(Ability abilityToModify, Ability source, Game game) {§if (abilityToModify instanceof SpellAbility || abilityToModify instanceof FlashbackAbility) {§for (Mode mode : abilityToModify.getModes().getSelectedModes()) {§for (Target target : mode.getTargets()) {§for (UUID targetId : target.getTargets()) {§if (targetId.equals(source.getSourceObject(game).getId())) {§return true;§}§}§}§}§}§return false;§}§@Override§public KaerveksTorchCostIncreaseEffect copy() {§return new KaerveksTorchCostIncreaseEffect(this);§}§}§
public class SaprolingBurst extends CardImpl {§public SaprolingBurst(UUID ownerId) {§super(ownerId, 230, "Saproling Burst", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{4}{G}");§this.expansionSetCode = "VMA";§this.addAbility(new FadingAbility(7, this));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new SaprolingBurstCreateTokenEffect(), new RemoveCountersSourceCost(CounterType.FADE.createInstance())));§this.addAbility(new SaprolingBurstLeavesBattlefieldTriggeredAbility());§}§public SaprolingBurst(final SaprolingBurst card) {§super(card);§}§@Override§public SaprolingBurst copy() {§return new SaprolingBurst(this);§}§}§class SaprolingBurstCreateTokenEffect extends OneShotEffect {§SaprolingBurstCreateTokenEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "Put a green Saproling creature token onto the battlefield. It has \"This creature's power and toughness are each equal to the number of fade counters on {this}.\"";§}§SaprolingBurstCreateTokenEffect(final SaprolingBurstCreateTokenEffect effect) {§super(effect);§}§@Override§public SaprolingBurstCreateTokenEffect copy() {§return new SaprolingBurstCreateTokenEffect(this);§}§@Override§@SuppressWarnings("unchecked")§public boolean apply(Game game, Ability source) {§Token token = new SaprolingBurstToken(new MageObjectReference(source.getSourceObject(game), game));§token.putOntoBattlefield(1, game, source.getSourceId(), source.getControllerId());§Permanent permanent = game.getPermanent(source.getSourceId());§if (permanent != null) {§Object object = game.getState().getValue(CardUtil.getCardZoneString("_tokensCreated", source.getSourceId(), game));§Set<UUID> tokensCreated;§if (object != null) {§tokensCreated = (Set<UUID>) object;§}§else {§tokensCreated = new HashSet<>();§}§for (UUID tokenId : token.getLastAddedTokenIds()) {§tokensCreated.add(tokenId);§}§game.getState().setValue(CardUtil.getCardZoneString("_tokensCreated", source.getSourceId(), game), tokensCreated);§}§return true;§}§}§class SaprolingBurstToken extends Token {§SaprolingBurstToken(MageObjectReference saprolingBurstMOR) {§super("Saproling", "green Saproling creature token with \"This creature's power and toughness are each equal to the number of fade counters on Saproling Burst.\"");§this.color.setGreen(true);§this.subtype.add("Saproling");§this.cardType.add(CardType.CREATURE);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new SetPowerToughnessSourceEffect(new SaprolingBurstTokenDynamicValue(saprolingBurstMOR), Duration.WhileOnBattlefield)));§}§}§class SaprolingBurstTokenDynamicValue implements DynamicValue {§private final MageObjectReference saprolingBurstMOR;§SaprolingBurstTokenDynamicValue(MageObjectReference saprolingBurstMOR) {§this.saprolingBurstMOR = saprolingBurstMOR;§}§SaprolingBurstTokenDynamicValue(final SaprolingBurstTokenDynamicValue dynamicValue) {§this.saprolingBurstMOR = dynamicValue.saprolingBurstMOR;§}§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§Permanent permanent = this.saprolingBurstMOR.getPermanent(game);§if (permanent != null) {§return permanent.getCounters().getCount(CounterType.FADE);§}§return 0;§}§@Override§public SaprolingBurstTokenDynamicValue copy() {§return new SaprolingBurstTokenDynamicValue(this);§}§@Override§public String toString() {§return "X";§}§@Override§public String getMessage() {§return "the number of fade counters on Saproling Burst";§}§}§class SaprolingBurstLeavesBattlefieldTriggeredAbility extends ZoneChangeTriggeredAbility {§SaprolingBurstLeavesBattlefieldTriggeredAbility() {§super(Zone.BATTLEFIELD, null, new SaprolingBurstDestroyEffect(), "When {this} leaves the battlefield, ", false);§}§SaprolingBurstLeavesBattlefieldTriggeredAbility(SaprolingBurstLeavesBattlefieldTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (super.checkTrigger(event, game)) {§for (Effect effect : this.getEffects()) {§if (effect instanceof SaprolingBurstDestroyEffect) {§((SaprolingBurstDestroyEffect) effect).setCardZoneString(CardUtil.getCardZoneString("_tokensCreated", this.getSourceId(), game, true));§}§}§return true;§}§return false;§}§@Override§public SaprolingBurstLeavesBattlefieldTriggeredAbility copy() {§return new SaprolingBurstLeavesBattlefieldTriggeredAbility(this);§}§}§class SaprolingBurstDestroyEffect extends OneShotEffect {§private String cardZoneString;§SaprolingBurstDestroyEffect() {§super(Outcome.Benefit);§this.staticText = "destroy all tokens put onto the battlefield with {this}. They can't be regenerated";§}§SaprolingBurstDestroyEffect(final SaprolingBurstDestroyEffect effect) {§super(effect);§this.cardZoneString = effect.cardZoneString;§}§@Override§public SaprolingBurstDestroyEffect copy() {§return new SaprolingBurstDestroyEffect(this);§}§@Override§@SuppressWarnings("unchecked")§public boolean apply(Game game, Ability source) {§Object object = game.getState().getValue(cardZoneString);§if (object != null) {§Set<UUID> tokensCreated = (Set<UUID>) object;§for (UUID tokenId : tokensCreated) {§Permanent token = game.getPermanent(tokenId);§if (token != null) {§token.destroy(source.getSourceId(), game, true);§}§}§}§return true;§}§public void setCardZoneString(String cardZoneString) {§this.cardZoneString = cardZoneString;§}§}§
public class Breezekeeper extends CardImpl {§public Breezekeeper(UUID ownerId) {§super(ownerId, 27, "Breezekeeper", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "VIS";§this.subtype.add("Djinn");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(PhasingAbility.getInstance());§}§public Breezekeeper(final Breezekeeper card) {§super(card);§}§@Override§public Breezekeeper copy() {§return new Breezekeeper(this);§}§}§
public class GoblinRecruiter extends CardImpl {§private static final FilterCard filter = new FilterCard("Goblin cards");§static {§filter.add(new SubtypePredicate("Goblin"));§}§public GoblinRecruiter(UUID ownerId) {§super(ownerId, 80, "Goblin Recruiter", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "VIS";§this.subtype.add("Goblin");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new EntersBattlefieldTriggeredAbility(new RecruiterEffect(filter), false));§}§public GoblinRecruiter(final GoblinRecruiter card) {§super(card);§}§@Override§public GoblinRecruiter copy() {§return new GoblinRecruiter(this);§}§}§
public class Necromancy extends CardImpl {§public Necromancy(UUID ownerId) {§super(ownerId, 14, "Necromancy", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{B}");§this.expansionSetCode = "VIS";§this.addAbility(new SimpleStaticAbility(Zone.ALL, new CastAsThoughItHadFlashSourceEffect(Duration.EndOfGame)));§this.addAbility(new SacrificeIfCastAtInstantTimeTriggeredAbility());§Ability ability = new ConditionalTriggeredAbility(§new EntersBattlefieldTriggeredAbility(new NecromancyReAttachEffect(), false),§SourceOnBattlefieldCondition.getInstance(),§"When {this} enters the battlefield, if it's on the battlefield, it becomes an Aura with \"enchant creature put onto the battlefield with {this}.\" Put target creature card from a graveyard onto the battlefield under your control and attach {this} to it.");§ability.addTarget(new TargetCardInGraveyard(new FilterCreatureCard("creature card from a graveyard")));§this.addAbility(ability);§this.addAbility(new LeavesBattlefieldTriggeredAbility(new NecromancyLeavesBattlefieldTriggeredEffect(), false));§}§public Necromancy(final Necromancy card) {§super(card);§}§@Override§public Necromancy copy() {§return new Necromancy(this);§}§}§class NecromancyReAttachEffect extends OneShotEffect {§public NecromancyReAttachEffect() {§super(Outcome.Benefit);§this.staticText = "it becomes an Aura with \"enchant creature put onto the battlefield with {this}\"";§}§public NecromancyReAttachEffect(final NecromancyReAttachEffect effect) {§super(effect);§}§@Override§public NecromancyReAttachEffect copy() {§return new NecromancyReAttachEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Permanent enchantment = game.getPermanent(source.getSourceId());§Card cardInGraveyard = game.getCard(getTargetPointer().getFirst(game, source));§if (controller != null && enchantment != null && cardInGraveyard != null) {§controller.moveCards(cardInGraveyard, Zone.BATTLEFIELD, source, game);§Permanent enchantedCreature = game.getPermanent(cardInGraveyard.getId());§if (enchantedCreature != null) {§enchantedCreature.addAttachment(enchantment.getId(), game);§FilterCreaturePermanent filter = new FilterCreaturePermanent("enchant creature put onto the battlefield with " + enchantment.getIdName());§filter.add(new PermanentIdPredicate(cardInGraveyard.getId()));§Target target = new TargetCreaturePermanent(filter);§target.addTarget(enchantedCreature.getId(), source, game);§game.addEffect(new NecromancyChangeAbilityEffect(target), source);§}§return true;§}§return false;§}§}§class NecromancyLeavesBattlefieldTriggeredEffect extends OneShotEffect {§public NecromancyLeavesBattlefieldTriggeredEffect() {§super(Outcome.Benefit);§this.staticText = "enchanted creature's controller sacrifices it";§}§public NecromancyLeavesBattlefieldTriggeredEffect(final NecromancyLeavesBattlefieldTriggeredEffect effect) {§super(effect);§}§@Override§public NecromancyLeavesBattlefieldTriggeredEffect copy() {§return new NecromancyLeavesBattlefieldTriggeredEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Permanent sourcePermanent = game.getPermanentOrLKIBattlefield(source.getSourceId());§if (controller != null && sourcePermanent != null) {§if (sourcePermanent.getAttachedTo() != null) {§Permanent attachedTo = game.getPermanent(sourcePermanent.getAttachedTo());§if (attachedTo != null) {§attachedTo.sacrifice(source.getSourceId(), game);§}§}§return true;§}§return false;§}§}§class NecromancyChangeAbilityEffect extends ContinuousEffectImpl implements SourceEffect {§private final static Ability newAbility = new EnchantAbility("creature put onto the battlefield with Necromancy");§static {§newAbility.setRuleAtTheTop(true);§}§Target target;§public NecromancyChangeAbilityEffect(Target target) {§super(Duration.Custom, Outcome.AddAbility);§staticText = "it becomes an Aura with \"enchant creature put onto the battlefield with {this}\"";§this.target = target;§dependencyTypes.add(DependencyType.AuraAddingRemoving);§}§public NecromancyChangeAbilityEffect(final NecromancyChangeAbilityEffect effect) {§super(effect);§this.target = effect.target;§}§@Override§public NecromancyChangeAbilityEffect copy() {§return new NecromancyChangeAbilityEffect(this);§}§@Override§public void init(Ability source, Game game) {§super.init(source, game);§affectedObjectList.add(new MageObjectReference(source.getSourceId(), game));§}§@Override§public boolean apply(Layer layer, SubLayer sublayer, Ability source, Game game) {§Permanent permanent = affectedObjectList.get(0).getPermanent(game);§if (permanent != null) {§switch (layer) {§case TypeChangingEffects_4:§if (sublayer == SubLayer.NA) {§if (!permanent.getSubtype().contains("Aura")) {§permanent.getSubtype().add("Aura");§}§}§break;§case AbilityAddingRemovingEffects_6:§if (sublayer == SubLayer.NA) {§permanent.addAbility(newAbility, source.getSourceId(), game);§permanent.getSpellAbility().getTargets().clear();§permanent.getSpellAbility().getTargets().add(target);§}§}§return true;§}§this.discard();§return false;§}§@Override§public boolean apply(Game game, Ability source) {§return false;§}§@Override§public boolean hasLayer(Layer layer) {§return Layer.AbilityAddingRemovingEffects_6.equals(layer) || Layer.TypeChangingEffects_4.equals(layer);§}§}§
public class SpiderClimb extends CardImpl {§public SpiderClimb(UUID ownerId) {§super(ownerId, 70, "Spider Climb", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{G}");§this.expansionSetCode = "VIS";§this.subtype.add("Aura");§this.addAbility(new SimpleStaticAbility(Zone.ALL, new CastAsThoughItHadFlashSourceEffect(Duration.EndOfGame)));§this.addAbility(new SacrificeIfCastAtInstantTimeTriggeredAbility());§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(0, 3, Duration.WhileOnBattlefield));§Effect effect = new GainAbilityAttachedEffect(ReachAbility.getInstance(), AttachmentType.AURA);§effect.setText("and has reach");§ability.addEffect(effect);§this.addAbility(ability);§}§public SpiderClimb(final SpiderClimb card) {§super(card);§}§@Override§public SpiderClimb copy() {§return new SpiderClimb(this);§}§}§
public class AncestralKnowledge extends CardImpl {§public AncestralKnowledge(UUID ownerId) {§super(ownerId, 32, "Ancestral Knowledge", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{1}{U}");§this.expansionSetCode = "WTH";§this.addAbility(new CumulativeUpkeepAbility(new ManaCostsImpl<>("{1}")));§this.addAbility(new EntersBattlefieldTriggeredAbility(new AncestralKnowledgeEffect()));§this.addAbility(new LeavesBattlefieldTriggeredAbility(new ShuffleLibrarySourceEffect(), false));§}§public AncestralKnowledge(final AncestralKnowledge card) {§super(card);§}§@Override§public AncestralKnowledge copy() {§return new AncestralKnowledge(this);§}§}§class AncestralKnowledgeEffect extends OneShotEffect {§AncestralKnowledgeEffect() {§super(Outcome.Benefit);§this.staticText = "look at the top ten cards of your library, then exile any number of them and put the rest back on top of your library in any order";§}§AncestralKnowledgeEffect(final AncestralKnowledgeEffect effect) {§super(effect);§}§@Override§public AncestralKnowledgeEffect copy() {§return new AncestralKnowledgeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§int numCards = Math.min(10, player.getLibrary().size());§if (numCards > 0) {§Cards cards = new CardsImpl();§for (int i = 0; i < numCards; i++) {§cards.add(player.getLibrary().removeFromTop(game));§}§TargetCard target = new TargetCard(0, numCards, Zone.LIBRARY, new FilterCard("cards to exile"));§player.choose(Outcome.Exile, cards, target, game);§for (UUID cardId : target.getTargets()) {§Card card = cards.get(cardId, game);§if (card != null) {§player.moveCardToExileWithInfo(card, null, "", source.getSourceId(), game, Zone.LIBRARY, true);§cards.remove(card);§}§}§while (cards.size() > 1) {§target = new TargetCard(1, Zone.LIBRARY, new FilterCard("card to put on top of library (last put is first drawn)"));§player.choose(Outcome.Benefit, cards, target, game);§Card card = cards.get(target.getFirstTarget(), game);§player.moveCardToLibraryWithInfo(card, source.getSourceId(), game, Zone.LIBRARY, true, false);§cards.remove(card);§}§if (cards.size() == 1) {§Card card = cards.get(cards.iterator().next(), game);§if (card != null) {§player.moveCardToLibraryWithInfo(card, source.getSourceId(), game, Zone.LIBRARY, true, false);§}§}§}§return true;§}§return false;§}§}§
public class DwarvenThaumaturgist extends CardImpl {§public DwarvenThaumaturgist(UUID ownerId) {§super(ownerId, 98, "Dwarven Thaumaturgist", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "WTH";§this.subtype.add("Dwarf");§this.subtype.add("Shaman");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new SwitchPowerToughnessTargetEffect(Duration.EndOfTurn), new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public DwarvenThaumaturgist(final DwarvenThaumaturgist card) {§super(card);§}§@Override§public DwarvenThaumaturgist copy() {§return new DwarvenThaumaturgist(this);§}§}§
public class ManaChains extends CardImpl {§public ManaChains(UUID ownerId) {§super(ownerId, 41, "Mana Chains", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{U}");§this.expansionSetCode = "WTH";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(§new CumulativeUpkeepAbility(new ManaCostsImpl("{1}")), AttachmentType.AURA)));§}§public ManaChains(final ManaChains card) {§super(card);§}§@Override§public ManaChains copy() {§return new ManaChains(this);§}§}§
public class ReveredUnicorn extends CardImpl {§public ReveredUnicorn(UUID ownerId) {§super(ownerId, 139, "Revered Unicorn", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "WTH";§this.subtype.add("Unicorn");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(new CumulativeUpkeepAbility(new ManaCostsImpl("{1}")));§this.addAbility(new LeavesBattlefieldTriggeredAbility(new GainLifeEffect(new CountersCount(CounterType.AGE)), false));§}§public ReveredUnicorn(final ReveredUnicorn card) {§super(card);§}§@Override§public ReveredUnicorn copy() {§return new ReveredUnicorn(this);§}§}§
public class WindingCanyons extends CardImpl {§public WindingCanyons(UUID ownerId) {§super(ownerId, 167, "Winding Canyons", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "WTH";§this.addAbility(new ColorlessManaAbility());§Effect effect = new AddContinuousEffectToGame(new CastAsThoughItHadFlashAllEffect(Duration.EndOfTurn, new FilterCreatureCard()));§effect.setText("Until end of turn, you may play creature cards as though they had flash");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new GenericManaCost(2));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public WindingCanyons(final WindingCanyons card) {§super(card);§}§@Override§public WindingCanyons copy() {§return new WindingCanyons(this);§}§}§
public class BojukaBrigand extends CardImpl {§public BojukaBrigand(UUID ownerId) {§super(ownerId, 51, "Bojuka Brigand", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "WWK";§this.subtype.add("Human");§this.subtype.add("Warrior");§this.subtype.add("Ally");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new CantBlockAbility());§this.addAbility(new AllyEntersBattlefieldTriggeredAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance()), true));§}§public BojukaBrigand(final BojukaBrigand card) {§super(card);§}§@Override§public BojukaBrigand copy() {§return new BojukaBrigand(this);§}§}§
public class DragonmasterOutcast extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("land");§static {§filter.add(new CardTypePredicate(CardType.LAND));§}§public DragonmasterOutcast(UUID ownerId) {§super(ownerId, 81, "Dragonmaster Outcast", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "WWK";§this.subtype.add("Human");§this.subtype.add("Shaman");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§TriggeredAbility ability = new BeginningOfUpkeepTriggeredAbility(new CreateTokenEffect(new DragonToken2(), 1), TargetController.YOU, false);§this.addAbility(new ConditionalTriggeredAbility(ability, new PermanentsOnTheBattlefieldCondition(filter, PermanentsOnTheBattlefieldCondition.CountType.MORE_THAN, 5), "At the beginning of your upkeep, if you control six or more lands, put a 5/5 red Dragon creature token with flying onto the battlefield."));§}§public DragonmasterOutcast(final DragonmasterOutcast card) {§super(card);§}§@Override§public DragonmasterOutcast copy() {§return new DragonmasterOutcast(this);§}§}§
public class HarabazDruid extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("Allies you control");§static {§filter.add(new SubtypePredicate("Ally"));§}§public HarabazDruid(UUID ownerId) {§super(ownerId, 105, "Harabaz Druid", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "WWK";§this.subtype.add("Human");§this.subtype.add("Druid");§this.subtype.add("Ally");§this.power = new MageInt(0);§this.toughness = new MageInt(1);§this.addAbility(new DynamicManaAbility(new Mana(0,0,0,0,0,0,1, 0), new PermanentsOnBattlefieldCount(filter), new TapSourceCost(),§"Add X mana of any one color to your mana pool, where X is the number of Allies you control", true));§}§public HarabazDruid(final HarabazDruid card) {§super(card);§}§@Override§public HarabazDruid copy() {§return new HarabazDruid(this);§}§}§
public class MarshalsAnthem extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Creatures you control");§private static final FilterCard filterCard = new FilterCard("creature card in your graveyard");§static {§filter.add(new ControllerPredicate(TargetController.YOU));§filterCard.add(new CardTypePredicate(CardType.CREATURE));§}§private final UUID originalId;§public MarshalsAnthem(UUID ownerId) {§super(ownerId, 15, "Marshal's Anthem", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{2}{W}{W}");§this.expansionSetCode = "WWK";§this.addAbility(new MultikickerAbility("{1}{W}"));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostAllEffect(1, 1, Duration.WhileOnBattlefield, filter, false)));§Ability ability = new ConditionalTriggeredAbility(§new EntersBattlefieldTriggeredAbility(new ReturnFromGraveyardToBattlefieldTargetEffect(), false),§KickedCondition.getInstance(),§"When {this} enters the battlefield, return up to X target creature cards from your graveyard to the battlefield, where X is the number of times {this} was kicked.");§originalId = ability.getOriginalId();§this.addAbility(ability);§}§@Override§public void adjustTargets(Ability ability, Game game) {§if (ability.getOriginalId().equals(originalId)) {§ability.getTargets().clear();§int numbTargets = new MultikickerCount().calculate(game, ability, null);§if (numbTargets > 0) {§ability.addTarget(new TargetCardInYourGraveyard(0, numbTargets, filterCard));§}§}§}§public MarshalsAnthem(final MarshalsAnthem card) {§super(card);§this.originalId = card.originalId;§}§@Override§public MarshalsAnthem copy() {§return new MarshalsAnthem(this);§}§}§
public class RefractionTrap extends CardImpl {§public RefractionTrap(UUID ownerId) {§super(ownerId, 17, "Refraction Trap", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{3}{W}");§this.expansionSetCode = "WWK";§this.subtype.add("Trap");§this.getSpellAbility().addAlternativeCost(new RefractionTrapAlternativeCost());§this.getSpellAbility().addEffect(new RefractionTrapPreventDamageEffect(Duration.EndOfTurn, 3));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§this.getSpellAbility().addWatcher(new RefractionTrapWatcher());§}§public RefractionTrap(final RefractionTrap card) {§super(card);§}§@Override§public RefractionTrap copy() {§return new RefractionTrap(this);§}§}§class RefractionTrapWatcher extends Watcher {§Set<UUID> playersMetCondition = new HashSet<>();§public RefractionTrapWatcher() {§super("RefractionTrapWatcher", WatcherScope.GAME);§}§public RefractionTrapWatcher(final RefractionTrapWatcher watcher) {§super(watcher);§this.playersMetCondition.addAll(watcher.playersMetCondition);§}§@Override§public RefractionTrapWatcher copy() {§return new RefractionTrapWatcher(this);§}§@Override§public void watch(GameEvent event, Game game) {§if (event.getType() == GameEvent.EventType.SPELL_CAST) {§Spell spell = game.getStack().getSpell(event.getTargetId());§if (spell.getColor(game).isRed()) {§if (spell.getCardType().contains(CardType.INSTANT)§|| spell.getCardType().contains(CardType.SORCERY)) {§playersMetCondition.add(event.getPlayerId());§}§}§}§}§public boolean conditionMetForAnOpponent(UUID controllerId, Game game) {§Player controller = game.getPlayer(controllerId);§if (controller != null) {§for (UUID playerId : playersMetCondition) {§if (controller.hasOpponent(playerId, game)) {§return true;§}§}§}§return false;§}§@Override§public void reset() {§playersMetCondition.clear();§super.reset();§}§}§class RefractionTrapAlternativeCost extends AlternativeCostImpl {§public RefractionTrapAlternativeCost() {§super("You may pay {W} rather than pay Refraction Trap's mana cost");§this.add(new ManaCostsImpl<ManaCost>("{W}"));§}§public RefractionTrapAlternativeCost(final RefractionTrapAlternativeCost cost) {§super(cost);§}§@Override§public RefractionTrapAlternativeCost copy() {§return new RefractionTrapAlternativeCost(this);§}§@Override§public boolean isAvailable(Game game, Ability source) {§RefractionTrapWatcher watcher = (RefractionTrapWatcher) game.getState().getWatchers().get("RefractionTrapWatcher");§return watcher != null && watcher.conditionMetForAnOpponent(source.getControllerId(), game);§}§@Override§public String getText() {§return "If an opponent cast a red instant or sorcery spell this turn, you may pay {W} rather than pay {this} mana cost";§}§}§class RefractionTrapPreventDamageEffect extends PreventionEffectImpl {§private final TargetSource target;§private int amount;§public RefractionTrapPreventDamageEffect(Duration duration, int amount) {§super(duration, amount, false, false);§this.amount = amount;§this.target = new TargetSource();§staticText = "The next " + amount + " damage that a source of your choice would deal to you and/or permanents you control this turn. If damage is prevented this way, {this} deals that much damage to target creature or player";§}§public RefractionTrapPreventDamageEffect(final RefractionTrapPreventDamageEffect effect) {§super(effect);§this.amount = effect.amount;§this.target = effect.target.copy();§}§@Override§public RefractionTrapPreventDamageEffect copy() {§return new RefractionTrapPreventDamageEffect(this);§}§@Override§public void init(Ability source, Game game) {§this.target.choose(Outcome.PreventDamage, source.getControllerId(), source.getSourceId(), game);§super.init(source, game);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§PreventionEffectData preventionData = preventDamageAction(event, source, game);§this.used = true;§this.discard(); §
public class SpellContortion extends CardImpl {§public SpellContortion(UUID ownerId) {§super(ownerId, 38, "Spell Contortion", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{2}{U}");§this.expansionSetCode = "WWK";§this.addAbility(new MultikickerAbility("{1}{U}"));§this.getSpellAbility().addEffect(new CounterUnlessPaysEffect(new GenericManaCost(2)));§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(new MultikickerCount()));§this.getSpellAbility().addTarget(new TargetSpell());§}§public SpellContortion(final SpellContortion card) {§super(card);§}§@Override§public SpellContortion copy() {§return new SpellContortion(this);§}§@Override§public List<String> getRules() {§List<String> rules = new ArrayList<String>();§rules.add("Counter target spell unless its controller pays {2}. Draw a card for each time Spell Contortion was kicked.");§return rules;§}§}§
public class VastwoodZendikon extends CardImpl {§public VastwoodZendikon(UUID ownerId) {§super(ownerId, 117, "Vastwood Zendikon", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{4}{G}");§this.expansionSetCode = "WWK";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetLandPermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.PutCreatureInPlay));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§Ability ability2 = new SimpleStaticAbility(Zone.BATTLEFIELD, new BecomesCreatureAttachedEffect(new VastwoodElementalToken(), "Enchanted land is a 6/4 green Elemental creature. It's still a land", Duration.WhileOnBattlefield ));§this.addAbility(ability2);§Ability ability3 = new DiesAttachedTriggeredAbility(new ReturnToHandAttachedEffect(), "enchanted land", false, false);§this.addAbility(ability3);§}§public VastwoodZendikon(final VastwoodZendikon card) {§super(card);§}§@Override§public VastwoodZendikon copy() {§return new VastwoodZendikon(this);§}§}§class VastwoodElementalToken extends Token {§VastwoodElementalToken() {§super("", "6/4 green Elemental creature");§cardType.add(CardType.CREATURE);§color.setGreen(true);§subtype.add("Elemental");§power = new MageInt(6);§toughness = new MageInt(4);§}§}§
public class BladeOfTheBloodchief extends CardImpl {§public BladeOfTheBloodchief(UUID ownerId) {§super(ownerId, 196, "Blade of the Bloodchief", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "ZEN";§this.getSubtype().add("Equipment");§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(1)));§this.addAbility(new BladeOfTheBloodChiefTriggeredAbility());§}§public BladeOfTheBloodchief(final BladeOfTheBloodchief card) {§super(card);§}§@Override§public BladeOfTheBloodchief copy() {§return new BladeOfTheBloodchief(this);§}§}§class BladeOfTheBloodChiefTriggeredAbility extends TriggeredAbilityImpl {§private static final String text = "Whenever a creature dies, put a +1/+1 counter on equipped "§+ "creature. If equipped creature is a Vampire, put two +1/+1 counters on it instead.";§BladeOfTheBloodChiefTriggeredAbility() {§super(Zone.BATTLEFIELD, new BladeOfTheBloodchiefEffect());§}§BladeOfTheBloodChiefTriggeredAbility(final BladeOfTheBloodChiefTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ZONE_CHANGE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§ZoneChangeEvent zEvent = (ZoneChangeEvent) event;§if (zEvent.getFromZone() == Zone.BATTLEFIELD && zEvent.getToZone() == Zone.GRAVEYARD) {§Permanent p = (Permanent) game.getLastKnownInformation(event.getTargetId(), Zone.BATTLEFIELD);§if (p != null && p.getCardType().contains(CardType.CREATURE)) {§Permanent enchantment = game.getPermanent(getSourceId());§if (enchantment != null && enchantment.getAttachedTo() != null) {§return true;§}§}§}§return false;§}§@Override§public BladeOfTheBloodChiefTriggeredAbility copy() {§return new BladeOfTheBloodChiefTriggeredAbility(this);§}§@Override§public String getRule() {§return text;§}§}§class BladeOfTheBloodchiefEffect extends OneShotEffect {§BladeOfTheBloodchiefEffect() {§super(Outcome.BoostCreature);§}§BladeOfTheBloodchiefEffect(final BladeOfTheBloodchiefEffect ability) {§super(ability);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent enchantment = game.getPermanent(source.getSourceId());§if (enchantment != null && enchantment.getAttachedTo() != null) {§Permanent creature = game.getPermanent(enchantment.getAttachedTo());§if (creature != null) {§if (creature.hasSubtype("Vampire")) {§creature.addCounters(CounterType.P1P1.createInstance(2), game);§} else {§creature.addCounters(CounterType.P1P1.createInstance(), game);§}§}§}§return true;§}§@Override§public BladeOfTheBloodchiefEffect copy() {§return new BladeOfTheBloodchiefEffect(this);§}§}§
public class CryptOfAgadeem extends CardImpl {§private static final FilterCreatureCard filter = new FilterCreatureCard("black creature card");§static {§filter.add(new ColorPredicate(ObjectColor.BLACK));§}§public CryptOfAgadeem(UUID ownerId) {§super(ownerId, 212, "Crypt of Agadeem", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "ZEN";§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new BlackManaAbility());§DynamicManaAbility ability = new DynamicManaAbility(Mana.BlackMana(1), new CardsInControllerGraveyardCount(filter), new GenericManaCost(2));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public CryptOfAgadeem(final CryptOfAgadeem card) {§super(card);§}§@Override§public CryptOfAgadeem copy() {§return new CryptOfAgadeem(this);§}§}§
public class Gigantiform extends CardImpl {§public Gigantiform(UUID ownerId) {§super(ownerId, 162, "Gigantiform", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{3}{G}{G}");§this.expansionSetCode = "ZEN";§this.subtype.add("Aura");§this.addAbility(new KickerAbility("{4}"));§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new GigantiformAbility());§this.addAbility(new ConditionalTriggeredAbility(§new EntersBattlefieldTriggeredAbility(new GigantiformEffect(), true),§KickedCondition.getInstance(),§"When {this} enters the battlefield, if it was kicked, you may search your library for a card named Gigantiform, put it onto the battlefield, then shuffle your library."));§}§public Gigantiform(final Gigantiform card) {§super(card);§}§@Override§public Gigantiform copy() {§return new Gigantiform(this);§}§}§class GigantiformAbility extends StaticAbility {§public GigantiformAbility() {§super(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(TrampleAbility.getInstance(), AttachmentType.AURA));§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new SetPowerToughnessSourceEffect(8, 8, Duration.WhileOnBattlefield, SubLayer.SetPT_7b));§this.addEffect(new GainAbilityAttachedEffect(ability, AttachmentType.AURA));§}§public GigantiformAbility(GigantiformAbility ability) {§super(ability);§}§@Override§public GigantiformAbility copy() {§return new GigantiformAbility(this);§}§@Override§public String getRule() {§return "Enchanted creature has base power and toughness 8/8 and has trample";§}§}§class GigantiformEffect extends OneShotEffect {§private static final FilterCard filter = new FilterCard("card named Gigantiform");§static {§filter.add(new NamePredicate("Gigantiform"));§}§public GigantiformEffect() {§super(Outcome.PutCardInPlay);§}§public GigantiformEffect(final GigantiformEffect effect) {§super(effect);§}§@Override§public GigantiformEffect copy() {§return new GigantiformEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§TargetCardInLibrary target = new TargetCardInLibrary(filter);§if (controller != null && controller.searchLibrary(target, game)) {§Card card = controller.getLibrary().getCard(target.getFirstTarget(), game);§if (card != null) {§controller.moveCards(card, Zone.BATTLEFIELD, source, game);§}§controller.shuffleLibrary(game);§return true;§}§return false;§}§}§
public class HedronScrabbler extends CardImpl {§public HedronScrabbler(UUID ownerId) {§super(ownerId, 204, "Hedron Scrabbler", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{2}");§this.expansionSetCode = "ZEN";§this.subtype.add("Construct");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new LandfallAbility(new BoostSourceEffect(1, 1, Duration.EndOfTurn), false));§}§public HedronScrabbler(final HedronScrabbler card) {§super(card);§}§@Override§public HedronScrabbler copy() {§return new HedronScrabbler(this);§}§}§
public class KorAeronaut extends CardImpl {§public KorAeronaut(UUID ownerId) {§super(ownerId, 17, "Kor Aeronaut", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{W}{W}");§this.expansionSetCode = "ZEN";§this.subtype.add("Kor");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new KickerAbility("{1}{W}"));§this.addAbility(FlyingAbility.getInstance());§EntersBattlefieldTriggeredAbility ability = new EntersBattlefieldTriggeredAbility(new GainAbilityTargetEffect(FlyingAbility.getInstance(), Duration.EndOfTurn), false);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(new ConditionalTriggeredAbility(ability, KickedCondition.getInstance(), "When {this} enters the battlefield, if it was kicked, target creature gains flying until end of turn."));§}§public KorAeronaut(final KorAeronaut card) {§super(card);§}§@Override§public KorAeronaut copy() {§return new KorAeronaut(this);§}§}§
public class MarkOfMutiny extends CardImpl {§public MarkOfMutiny(UUID ownerId) {§super(ownerId, 137, "Mark of Mutiny", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{2}{R}");§this.expansionSetCode = "ZEN";§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new GainControlTargetEffect(Duration.EndOfTurn));§Effect effect = new AddCountersTargetEffect(CounterType.P1P1.createInstance());§effect.setText("Put a +1/+1 counter on it");§this.getSpellAbility().addEffect(effect);§effect = new UntapTargetEffect();§effect.setText("and untap it");§this.getSpellAbility().addEffect(effect);§effect = new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.EndOfTurn);§effect.setText("That creature gains haste until end of turn. <i>(It can {T} attack and this turn.)</i>");§this.getSpellAbility().addEffect(effect);§}§public MarkOfMutiny(final MarkOfMutiny card) {§super(card);§}§@Override§public MarkOfMutiny copy() {§return new MarkOfMutiny(this);§}§}§
public class ObNixilisTheFallen extends CardImpl {§public ObNixilisTheFallen (UUID ownerId) {§super(ownerId, 107, "Ob Nixilis, the Fallen", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{3}{B}{B}");§this.expansionSetCode = "ZEN";§this.supertype.add("Legendary");§this.subtype.add("Demon");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§Ability ability = new LandfallAbility(new LoseLifeTargetEffect(3), true);§ability.addEffect(new AddCountersSourceEffect(CounterType.P1P1.createInstance(3)));§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public ObNixilisTheFallen (final ObNixilisTheFallen card) {§super(card);§}§@Override§public ObNixilisTheFallen copy() {§return new ObNixilisTheFallen(this);§}§}§
public class QuestForTheHolyRelic extends CardImpl {§private static final FilterSpell filter = new FilterSpell("a creature spell");§static {§filter.add(new CardTypePredicate(CardType.CREATURE));§}§public QuestForTheHolyRelic(UUID ownerId) {§super(ownerId, 33, "Quest for the Holy Relic", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{W}");§this.expansionSetCode = "ZEN";§this.addAbility(new SpellCastControllerTriggeredAbility(new AddCountersSourceEffect(CounterType.QUEST.createInstance()), filter, true));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new QuestForTheHolyRelicEffect(), new RemoveCountersSourceCost(CounterType.QUEST.createInstance(5)));§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public QuestForTheHolyRelic(final QuestForTheHolyRelic card) {§super(card);§}§@Override§public QuestForTheHolyRelic copy() {§return new QuestForTheHolyRelic(this);§}§}§class QuestForTheHolyRelicEffect extends OneShotEffect {§public QuestForTheHolyRelicEffect() {§super(Outcome.PutCardInPlay);§this.staticText = "Search your library for an Equipment card, put it onto the battlefield, and attach it to a creature you control. Then shuffle your library";§}§public QuestForTheHolyRelicEffect(final QuestForTheHolyRelicEffect effect) {§super(effect);§}§@Override§public QuestForTheHolyRelicEffect copy() {§return new QuestForTheHolyRelicEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller == null) {§return false;§}§FilterCard filter = new FilterCard("Equipment");§filter.add(new SubtypePredicate("Equipment"));§TargetCardInLibrary target = new TargetCardInLibrary(filter);§if (controller.searchLibrary(target, game)) {§Card card = controller.getLibrary().getCard(target.getFirstTarget(), game);§if (card != null && controller.moveCards(card, Zone.BATTLEFIELD, source, game)) {§Permanent equipment = game.getPermanent(card.getId());§Target targetCreature = new TargetControlledCreaturePermanent();§if (equipment != null && controller.choose(Outcome.BoostCreature, targetCreature, source.getSourceId(), game)) {§Permanent permanent = game.getPermanent(targetCreature.getFirstTarget());§permanent.addAttachment(equipment.getId(), game);§}§}§}§controller.shuffleLibrary(game);§return true;§}§}§
public class ShepherdOfTheLost extends CardImpl {§public ShepherdOfTheLost (UUID ownerId) {§super(ownerId, 34, "Shepherd of the Lost", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{W}");§this.expansionSetCode = "ZEN";§this.subtype.add("Angel");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(FirstStrikeAbility.getInstance());§this.addAbility(VigilanceAbility.getInstance());§}§public ShepherdOfTheLost (final ShepherdOfTheLost card) {§super(card);§}§@Override§public ShepherdOfTheLost copy() {§return new ShepherdOfTheLost(this);§}§}§
public class TajuruArcher extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Allies you control");§private static final FilterCreaturePermanent filterTarget = new FilterCreaturePermanent("creature with flying");§static {§filter.add(new SubtypePredicate("Ally"));§filter.add(new ControllerPredicate(TargetController.YOU));§filterTarget.add(new AbilityPredicate(FlyingAbility.class));§}§public TajuruArcher(UUID ownerId) {§super(ownerId, 185, "Tajuru Archer", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "ZEN";§this.subtype.add("Elf");§this.subtype.add("Archer");§this.subtype.add("Ally");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§Ability ability = new AllyEntersBattlefieldTriggeredAbility(new DamageTargetEffect(new PermanentsOnBattlefieldCount(filter)), true);§ability.addTarget(new TargetCreaturePermanent(filterTarget));§this.addAbility(ability);§}§public TajuruArcher(final TajuruArcher card) {§super(card);§}§@Override§public TajuruArcher copy() {§return new TajuruArcher(this);§}§}§
public class VampireLacerator extends CardImpl {§public VampireLacerator(UUID ownerId) {§super(ownerId, 115, "Vampire Lacerator", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{B}");§this.expansionSetCode = "ZEN";§this.subtype.add("Vampire");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new BeginningOfUpkeepTriggeredAbility(§new ConditionalOneShotEffect(§new LoseLifeSourceControllerEffect(1),§new InvertCondition( new TenOrLessLifeCondition(TenOrLessLifeCondition.CheckType.AN_OPPONENT) ),§"you lose 1 life unless an opponent has 10 or less life"), TargetController.YOU, false));§}§public VampireLacerator(final VampireLacerator card) {§super(card);§}§@Override§public VampireLacerator copy() {§return new VampireLacerator(this);§}§}§
