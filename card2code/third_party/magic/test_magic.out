public class ClovenCasting extends CardImpl {§private static final FilterSpell filter = new FilterSpell("a multicolored instant or sorcery spell");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.INSTANT),§new CardTypePredicate(CardType.SORCERY)));§filter.add(new MulticoloredPredicate());§}§public ClovenCasting(UUID ownerId) {§super(ownerId, 86, "Cloven Casting", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{5}{U}{R}");§this.expansionSetCode = "ARB";§this.addAbility(new SpellCastControllerTriggeredAbility(new DoIfCostPaid(new ClovenCastingEffect(), new GenericManaCost(1)), filter, true, true));§}§public ClovenCasting(final ClovenCasting card) {§super(card);§}§@Override§public ClovenCasting copy() {§return new ClovenCasting(this);§}§}§class ClovenCastingEffect extends OneShotEffect {§public ClovenCastingEffect() {§super(Outcome.Copy);§staticText = "copy that spell. You may choose new targets for the copy";§}§public ClovenCastingEffect(final ClovenCastingEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Spell spell = game.getStack().getSpell(targetPointer.getFirst(game, source));§if (spell != null) {§Spell copy = spell.copySpell();§copy.setControllerId(source.getControllerId());§copy.setCopiedSpell(true);§game.getStack().push(copy);§copy.chooseNewTargets(game, source.getControllerId());§Player player = game.getPlayer(source.getControllerId());§String activateMessage = copy.getActivatedMessage(game);§if (activateMessage.startsWith(" casts ")) {§activateMessage = activateMessage.substring(6);§}§game.informPlayers(player.getLogName() + " copies " + activateMessage);§return true;§}§return false;§}§@Override§public ClovenCastingEffect copy() {§return new ClovenCastingEffect(this);§}§}§
public class EtherswornShieldmage extends CardImpl {§final private static FilterCreaturePermanent filter = new FilterCreaturePermanent("artifact creatures");§static {§filter.add(new CardTypePredicate(CardType.ARTIFACT));§}§public EtherswornShieldmage(UUID ownerId) {§super(ownerId, 4, "Ethersworn Shieldmage", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{1}{W}{U}");§this.expansionSetCode = "ARB";§this.subtype.add("Vedalken");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlashAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new PreventAllDamageToAllEffect(Duration.EndOfTurn, filter), false));§}§public EtherswornShieldmage(final EtherswornShieldmage card) {§super(card);§}§@Override§public EtherswornShieldmage copy() {§return new EtherswornShieldmage(this);§}§}§
public class IntimidationBolt extends CardImpl {§public IntimidationBolt(UUID ownerId) {§super(ownerId, 99, "Intimidation Bolt", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{R}{W}");§this.expansionSetCode = "ARB";§this.getSpellAbility().addEffect(new DamageTargetEffect(3));§this.getSpellAbility().addEffect(new IntimidationEffect(Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public IntimidationBolt(final IntimidationBolt card) {§super(card);§}§@Override§public IntimidationBolt copy() {§return new IntimidationBolt(this);§}§}§class IntimidationEffect extends RestrictionEffect {§public IntimidationEffect(Duration duration) {§super(duration);§staticText = "Other creatures can't attack this turn";§}§public IntimidationEffect(final IntimidationEffect effect) {§super(effect);§}§@Override§public boolean applies(Permanent permanent, Ability source, Game game) {§if (!permanent.getId().equals(source.getFirstTarget())) {§return true;§}§return false;§}§@Override§public boolean canAttack(Game game) {§return false;§}§@Override§public IntimidationEffect copy() {§return new IntimidationEffect(this);§}§}§
public class MageSlayer extends CardImpl {§public MageSlayer(UUID ownerId) {§super(ownerId, 57, "Mage Slayer", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{1}{R}{G}");§this.expansionSetCode = "ARB";§this.subtype.add("Equipment");§this.addAbility(new AttacksAttachedTriggeredAbility(new MageSlayerEffect(), false));§this.addAbility(new EquipAbility(Outcome.Benefit, new GenericManaCost(3), new TargetControlledCreaturePermanent()));§}§public MageSlayer(final MageSlayer card) {§super(card);§}§@Override§public MageSlayer copy() {§return new MageSlayer(this);§}§}§class MageSlayerEffect extends OneShotEffect {§public MageSlayerEffect() {§super(Outcome.Damage);§staticText = "it deals damage equal to its power to defending player";§}§public MageSlayerEffect(final MageSlayerEffect effect) {§super(effect);§}§@Override§public MageSlayerEffect copy() {§return new MageSlayerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent equipment = game.getPermanent(source.getSourceId());§if (equipment != null && equipment.getAttachedTo() != null) {§int power = game.getPermanent(equipment.getAttachedTo()).getPower().getValue();§UUID defendingPlayerId = game.getCombat().getDefendingPlayerId(equipment.getAttachedTo(), game);§if (defendingPlayerId != null) {§game.getPlayer(defendingPlayerId).damage(power, source.getSourceId(), game, false, true);§return true;§}§}§return false;§}§}§
public class PutridLeech extends CardImpl {§public PutridLeech(UUID ownerId) {§super(ownerId, 95, "Putrid Leech", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{B}{G}");§this.expansionSetCode = "ARB";§this.subtype.add("Zombie");§this.subtype.add("Leech");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new LimitedTimesPerTurnActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(2, 2, Duration.EndOfTurn), new PayLifeCost(2)));§}§public PutridLeech(final PutridLeech card) {§super(card);§}§@Override§public PutridLeech copy() {§return new PutridLeech(this);§}§}§
public class SovereignsOfLostAlara extends CardImpl {§public SovereignsOfLostAlara(UUID ownerId) {§super(ownerId, 12, "Sovereigns of Lost Alara", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{W}{U}");§this.expansionSetCode = "ARB";§this.subtype.add("Spirit");§this.power = new MageInt(4);§this.toughness = new MageInt(5);§this.addAbility(new ExaltedAbility());§this.addAbility(new CreatureControlledAttacksAloneTriggeredAbility());§}§public SovereignsOfLostAlara(final SovereignsOfLostAlara card) {§super(card);§}§@Override§public SovereignsOfLostAlara copy() {§return new SovereignsOfLostAlara(this);§}§}§class CreatureControlledAttacksAloneTriggeredAbility extends TriggeredAbilityImpl {§public CreatureControlledAttacksAloneTriggeredAbility() {§super(Zone.BATTLEFIELD, new SovereignsOfLostAlaraEffect(), true);§}§public CreatureControlledAttacksAloneTriggeredAbility(final CreatureControlledAttacksAloneTriggeredAbility ability) {§super(ability);§}§@Override§public CreatureControlledAttacksAloneTriggeredAbility copy() {§return new CreatureControlledAttacksAloneTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DECLARED_ATTACKERS;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (game.getActivePlayerId().equals(this.controllerId)) {§if (game.getCombat().attacksAlone()) {§this.getEffects().get(0).setTargetPointer(new FixedTarget(game.getCombat().getAttackers().get(0)));§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever a creature you control attacks alone, " + super.getRule();§}§}§class SovereignsOfLostAlaraEffect extends OneShotEffect {§public SovereignsOfLostAlaraEffect() {§super(Outcome.BoostCreature);§staticText = "you may search your library for an Aura card that could enchant that creature, put it onto the battlefield attached to that creature, then shuffle your library";§}§public SovereignsOfLostAlaraEffect(final SovereignsOfLostAlaraEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player you = game.getPlayer(source.getControllerId());§Permanent attackingCreature = game.getPermanent(getTargetPointer().getFirst(game, source));§if (you != null && attackingCreature != null) {§FilterCard filter = new FilterCard("aura that could enchant the lone attacking creature");§filter.add(new SubtypePredicate("Aura"));§filter.add(new AuraCardCanAttachToPermanentId(attackingCreature.getId()));§if (you.chooseUse(Outcome.Benefit, "Do you want to search your library?", source, game)) {§TargetCardInLibrary target = new TargetCardInLibrary(filter);§target.setNotTarget(true);§if (you.searchLibrary(target, game)) {§if (target.getFirstTarget() != null) {§Card aura = game.getCard(target.getFirstTarget());§game.getState().setValue("attachTo:" + aura.getId(), attackingCreature);§aura.putOntoBattlefield(game, Zone.LIBRARY, source.getSourceId(), you.getId());§return attackingCreature.addAttachment(aura.getId(), game);§}§}§}§you.shuffleLibrary(game);§}§return false;§}§@Override§public SovereignsOfLostAlaraEffect copy() {§return new SovereignsOfLostAlaraEffect(this);§}§}§
public class VedalkenHeretic extends CardImpl {§public VedalkenHeretic(UUID ownerId) {§super(ownerId, 104, "Vedalken Heretic", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{G}{U}");§this.expansionSetCode = "ARB";§this.subtype.add("Vedalken");§this.subtype.add("Rogue");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new DealsDamageToOpponentTriggeredAbility(new DrawCardSourceControllerEffect(1), true));§}§public VedalkenHeretic(final VedalkenHeretic card) {§super(card);§}§@Override§public VedalkenHeretic copy() {§return new VedalkenHeretic(this);§}§}§
public class Dystopia extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("green or white permanent");§static {§filter.add(Predicates.or(new ColorPredicate(ObjectColor.GREEN), new ColorPredicate(ObjectColor.WHITE)));§}§public Dystopia(UUID ownerId) {§super(ownerId, 6, "Dystopia", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{1}{B}{B}");§this.expansionSetCode = "ALL";§this.addAbility(new CumulativeUpkeepAbility(new PayLifeCost(1)));§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new SacrificeEffect(filter, 1, "that player"), TargetController.ANY, false));§}§public Dystopia(final Dystopia card) {§super(card);§}§@Override§public Dystopia copy() {§return new Dystopia(this);§}§}§
public class Phelddagrif extends CardImpl {§public Phelddagrif(UUID ownerId) {§super(ownerId, 196, "Phelddagrif", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{G}{W}{U}");§this.expansionSetCode = "ALL";§this.supertype.add("Legendary");§this.subtype.add("Phelddagrif");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(TrampleAbility.getInstance(), Duration.EndOfTurn),new ManaCostsImpl("{G}"));§ability.addEffect(new CreateTokenTargetEffect(new HippoToken()));§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(FlyingAbility.getInstance(), Duration.EndOfTurn),new ManaCostsImpl("{W}"));§ability.addEffect(new GainLifeTargetEffect(2));§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ReturnToHandSourceEffect(true),new ManaCostsImpl("{U}"));§ability.addEffect(new DrawCardTargetEffect(1, true));§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§}§public Phelddagrif(final Phelddagrif card) {§super(card);§}§@Override§public Phelddagrif copy() {§return new Phelddagrif(this);§}§}§class HippoToken extends Token {§public HippoToken() {§super("Hippo", "1/1 green Hippo creature token");§cardType.add(CardType.CREATURE);§color.setGreen(true);§subtype.add("Hippo");§power = new MageInt(1);§toughness = new MageInt(1);§}§}§
public class YavimayaAnts extends CardImpl {§public YavimayaAnts(UUID ownerId) {§super(ownerId, 93, "Yavimaya Ants", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{G}{G}");§this.expansionSetCode = "ALL";§this.subtype.add("Insect");§this.power = new MageInt(5);§this.toughness = new MageInt(1);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(HasteAbility.getInstance());§this.addAbility(new CumulativeUpkeepAbility(new ManaCostsImpl("{G}{G}")));§}§public YavimayaAnts(final YavimayaAnts card) {§super(card);§}§@Override§public YavimayaAnts copy() {§return new YavimayaAnts(this);§}§}§
public class PriestOfYawgmoth extends CardImpl {§public PriestOfYawgmoth(UUID ownerId) {§super(ownerId, 49, "Priest of Yawgmoth", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "ATQ";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§Ability ability = new DynamicManaAbility(Mana.BlackMana(1), new SacrificeCostConvertedMana("artifact"),§new TapSourceCost(), "add to your mana pool an amount of {B} equal to the sacrificed artifact's converted mana cost");§ability.addCost(new SacrificeTargetCost(new TargetControlledPermanent(new FilterControlledArtifactPermanent())));§this.addAbility(ability);§}§public PriestOfYawgmoth(final PriestOfYawgmoth card) {§super(card);§}§@Override§public PriestOfYawgmoth copy() {§return new PriestOfYawgmoth(this);§}§}§
public class Cromat extends CardImpl {§public Cromat(UUID ownerId) {§super(ownerId, 94, "Cromat", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{W}{U}{B}{R}{G}");§this.expansionSetCode = "APC";§this.supertype.add("Legendary");§this.subtype.add("Illusion");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§FilterCreaturePermanent filter = new FilterCreaturePermanent("creature blocking or blocked by Cromat");§filter.add(Predicates.or(new BlockedByIdPredicate(this.getId()),§new BlockingAttackerIdPredicate(this.getId())));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new ManaCostsImpl("{W}{B}"));§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(FlyingAbility.getInstance(), Duration.EndOfTurn), new ManaCostsImpl("{U}{R}")));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new ManaCostsImpl("{B}{G}")));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1,1, Duration.EndOfTurn), new ManaCostsImpl("{R}{W}")));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new PutOnLibrarySourceEffect(true), new ManaCostsImpl("{G}{U}")));§}§public Cromat(final Cromat card) {§super(card);§}§@Override§public Cromat copy() {§return new Cromat(this);§}§}§
public class FungalShambler extends CardImpl {§public FungalShambler(UUID ownerId) {§super(ownerId, 100, "Fungal Shambler", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{G}{U}{B}");§this.expansionSetCode = "APC";§this.subtype.add("Fungus");§this.subtype.add("Beast");§this.power = new MageInt(6);§this.toughness = new MageInt(4);§this.addAbility(TrampleAbility.getInstance());§Effect effect = new DrawCardSourceControllerEffect(1);§effect.setText("you draw a card");§Ability ability = new DealsDamageToOpponentTriggeredAbility(effect, false, false, true);§effect = new DiscardTargetEffect(1);§effect.setText("and that opponent discards a card");§ability.addEffect(effect);§this.addAbility(ability);§}§public FungalShambler(final FungalShambler card) {§super(card);§}§@Override§public FungalShambler copy() {§return new FungalShambler(this);§}§}§
public class LegacyWeapon extends CardImpl {§public LegacyWeapon(UUID ownerId) {§super(ownerId, 137, "Legacy Weapon", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{7}");§this.expansionSetCode = "APC";§this.supertype.add("Legendary");§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new ExileTargetEffect(),§new ManaCostsImpl("{W}{U}{B}{R}{G}"));§ability.addTarget(new TargetPermanent());§this.addAbility(ability);§this.addAbility(new PutIntoGraveFromAnywhereSourceAbility(new RevealAndShuffleIntoLibrarySourceEffect()));§}§public LegacyWeapon(final LegacyWeapon card) {§super(card);§}§@Override§public LegacyWeapon copy() {§return new LegacyWeapon(this);§}§}§
public class PhyrexianArena extends CardImpl {§public PhyrexianArena(UUID ownerId) {§super(ownerId, 47, "Phyrexian Arena", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{1}{B}{B}");§this.expansionSetCode = "APC";§Ability ability = new BeginningOfUpkeepTriggeredAbility(new DrawCardSourceControllerEffect(1), TargetController.YOU, false);§ability.addEffect(new LoseLifeSourceControllerEffect(1));§this.addAbility(ability);§}§public PhyrexianArena(final PhyrexianArena card) {§super(card);§}§@Override§public PhyrexianArena copy() {§return new PhyrexianArena(this);§}§}§
public class StrengthOfNight extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Zombie creatures");§static {§filter.add(new SubtypePredicate("Zombie"));§}§public StrengthOfNight(UUID ownerId) {§super(ownerId, 86, "Strength of Night", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{G}");§this.expansionSetCode = "APC";§this.addAbility(new KickerAbility("{B}"));§this.getSpellAbility().addEffect(new BoostControlledEffect(1, 1, Duration.EndOfTurn));§ContinuousEffect effect = new BoostControlledEffect(2, 2, Duration.EndOfTurn, filter);§this.getSpellAbility().addEffect(new ConditionalContinuousEffect(effect, new LockedInCondition(KickedCondition.getInstance()),§"If {this} was kicked, Zombie creatures you control get an additional +2/+2 until end of turn."));§}§public StrengthOfNight(final StrengthOfNight card) {§super(card);§}§@Override§public StrengthOfNight copy() {§return new StrengthOfNight(this);§}§}§
public class ArmyOfAllah extends CardImpl {§private static final FilterAttackingCreature filter = new FilterAttackingCreature("Attacking creatures");§public ArmyOfAllah(UUID ownerId) {§super(ownerId, 56, "Army of Allah", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{W}{W}");§this.expansionSetCode = "ARN";§this.getSpellAbility().addEffect(new BoostAllEffect(2, 0, Duration.EndOfTurn, filter, false));§}§public ArmyOfAllah(final ArmyOfAllah card) {§super(card);§}§@Override§public ArmyOfAllah copy() {§return new ArmyOfAllah(this);§}§}§
public class SkirkCommando extends CardImpl {§public SkirkCommando(UUID ownerId) {§super(ownerId, 47, "Skirk Commando", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{R}{R}");§this.expansionSetCode = "ARC";§this.subtype.add("Goblin");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new SkirkCommandoTriggeredAbility());§this.addAbility(new MorphAbility(this, new ManaCostsImpl("{2}{R}")));§}§public SkirkCommando(final SkirkCommando card) {§super(card);§}§@Override§public SkirkCommando copy() {§return new SkirkCommando(this);§}§}§class SkirkCommandoTriggeredAbility extends DealsCombatDamageToAPlayerTriggeredAbility {§public SkirkCommandoTriggeredAbility() {§super(new DamageTargetEffect(2), true, false);§}§public SkirkCommandoTriggeredAbility(SkirkCommandoTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (super.checkTrigger(event, game)) {§FilterCreaturePermanent filter = new FilterCreaturePermanent("creature that player controls");§filter.add(new ControllerIdPredicate(event.getPlayerId()));§addTarget(new TargetCreaturePermanent(filter));§}§return false;§}§@Override§public SkirkCommandoTriggeredAbility copy() {§return new SkirkCommandoTriggeredAbility(this);§}§@Override§public String getRule() {§return "Whenever {this} deals combat damage to a player, you may have it deal 2 damage to target creature that player controls.";§}§}§
public class BannersRaised extends CardImpl {§public BannersRaised(UUID ownerId) {§super(ownerId, 127, "Banners Raised", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{R}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new BoostControlledEffect(1, 0, Duration.EndOfTurn));§}§public BannersRaised(final BannersRaised card) {§super(card);§}§@Override§public BannersRaised copy() {§return new BannersRaised(this);§}§}§
public class CommandersAuthority extends CardImpl {§public CommandersAuthority(UUID ownerId) {§super(ownerId, 13, "Commander's Authority", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{4}{W}");§this.expansionSetCode = "AVR";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§ability = new BeginningOfUpkeepTriggeredAbility(new CreateTokenEffect(new HumanToken()), TargetController.YOU, false);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(ability, AttachmentType.AURA)));§}§public CommandersAuthority(final CommandersAuthority card) {§super(card);§}§@Override§public CommandersAuthority copy() {§return new CommandersAuthority(this);§}§}§
public class DevoutChaplain extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("artifact or enchantment");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.ARTIFACT),§new CardTypePredicate(CardType.ENCHANTMENT)));§}§private static final FilterControlledPermanent humanFilter = new FilterControlledPermanent("untapped Human you control");§static {§humanFilter.add(Predicates.not(new TappedPredicate()));§humanFilter.add(new SubtypePredicate("Human"));§}§public DevoutChaplain(UUID ownerId) {§super(ownerId, 17, "Devout Chaplain", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.color.setWhite(true);§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ExileTargetEffect(), new TapSourceCost());§ability.addCost(new TapTargetCost(new TargetControlledPermanent(2, 2, humanFilter, false)));§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§}§public DevoutChaplain(final DevoutChaplain card) {§super(card);§}§@Override§public DevoutChaplain copy() {§return new DevoutChaplain(this);§}§}§
public class Fettergeist extends CardImpl {§public Fettergeist(UUID ownerId) {§super(ownerId, 52, "Fettergeist", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "AVR";§this.subtype.add("Spirit");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new FettergeistUnlessPaysEffect(), TargetController.YOU, false));§}§public Fettergeist(final Fettergeist card) {§super(card);§}§@Override§public Fettergeist copy() {§return new Fettergeist(this);§}§}§class FettergeistUnlessPaysEffect extends OneShotEffect {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent();§static {§filter.add(new AnotherPredicate());§}§public FettergeistUnlessPaysEffect() {§super(Outcome.Sacrifice);§staticText = "sacrifice {this} unless you pay {1} for each other creature you control.";§}§public FettergeistUnlessPaysEffect(final FettergeistUnlessPaysEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§Permanent permanent = game.getPermanent(source.getSourceId());§if (player != null && permanent != null) {§PermanentsOnBattlefieldCount amount = new PermanentsOnBattlefieldCount(filter, 1);§int count = amount.calculate(game, source, this);§if (player.chooseUse(Outcome.Benefit, "Pay " + count + "? Or " + permanent.getName() + " will be sacrificed.", source, game)) {§GenericManaCost cost = new GenericManaCost(count);§if (cost.pay(source, game, source.getSourceId(), source.getControllerId(), false)) {§return true;§}§}§permanent.sacrifice(source.getSourceId(), game);§return true;§}§return false;§}§@Override§public FettergeistUnlessPaysEffect copy() {§return new FettergeistUnlessPaysEffect(this);§}§}§
public class GuiseOfFire extends CardImpl {§public GuiseOfFire(UUID ownerId) {§super(ownerId, 137, "Guise of Fire", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{R}");§this.expansionSetCode = "AVR";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(1, -1, Duration.WhileOnBattlefield));§Effect effect = new AttacksIfAbleAttachedEffect(Duration.WhileOnBattlefield, AttachmentType.AURA);§effect.setText("and attacks each turn if able");§ability.addEffect(effect);§this.addAbility(ability);§}§public GuiseOfFire(final GuiseOfFire card) {§super(card);§}§@Override§public GuiseOfFire copy() {§return new GuiseOfFire(this);§}§}§
public class LairDelve extends CardImpl {§public LairDelve(UUID ownerId) {§super(ownerId, 184, "Lair Delve", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{G}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new LairDelveEffect());§}§public LairDelve(final LairDelve card) {§super(card);§}§@Override§public LairDelve copy() {§return new LairDelve(this);§}§}§class LairDelveEffect extends OneShotEffect {§public LairDelveEffect() {§super(Outcome.DrawCard);§this.staticText = "Reveal the top two cards of your library. Put all creature and land cards revealed this way into your hand and the rest on the bottom of your library in any order";§}§public LairDelveEffect(final LairDelveEffect effect) {§super(effect);§}§@Override§public LairDelveEffect copy() {§return new LairDelveEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player == null) {§return false;§}§CardsImpl cards = new CardsImpl();§int amount = Math.min(2, player.getLibrary().size());§for (int i = 0; i < amount; i++) {§cards.add(player.getLibrary().removeFromTop(game));§}§player.revealCards("Lair Delve", cards, game);§Set<Card> cardsList = cards.getCards(game);§for (Card card : cardsList) {§if (card.getCardType().contains(CardType.CREATURE) || card.getCardType().contains(CardType.LAND)) {§card.moveToZone(Zone.HAND, source.getSourceId(), game, true);§cards.remove(card);§}§}§player.putCardsOnBottomOfLibrary(cards, game, source, true);§return true;§}§}§
public class MoorlandInquisitor extends CardImpl {§public MoorlandInquisitor(UUID ownerId) {§super(ownerId, 30, "Moorland Inquisitor", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "AVR";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn),§new ManaCostsImpl("{2}{W}")));§}§public MoorlandInquisitor(final MoorlandInquisitor card) {§super(card);§}§@Override§public MoorlandInquisitor copy() {§return new MoorlandInquisitor(this);§}§}§
public class RestorationAngel extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("non-Angel creature you control");§static {§filter.add(Predicates.not(new SubtypePredicate("Angel")));§}§public RestorationAngel(UUID ownerId) {§super(ownerId, 32, "Restoration Angel", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "AVR";§this.subtype.add("Angel");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§this.addAbility(FlashAbility.getInstance());§this.addAbility(FlyingAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new RestorationAngelEffect(), true);§ability.addTarget(new TargetControlledCreaturePermanent(1, 1, filter, false));§this.addAbility(ability);§}§public RestorationAngel(final RestorationAngel card) {§super(card);§}§@Override§public RestorationAngel copy() {§return new RestorationAngel(this);§}§}§class RestorationAngelEffect extends OneShotEffect {§public RestorationAngelEffect() {§super(Outcome.Exile);§staticText = "you may exile target non-Angel creature you control, then return that card to the battlefield under your control";§}§public RestorationAngelEffect(final RestorationAngelEffect effect) {§super(effect);§}§@Override§public RestorationAngelEffect copy() {§return new RestorationAngelEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Permanent sourcePermanent = game.getPermanentOrLKIBattlefield(source.getSourceId());§Permanent permanent = game.getPermanent(targetPointer.getFirst(game, source));§if (permanent != null && sourcePermanent != null) {§int zcc = permanent.getZoneChangeCounter(game);§controller.moveCards(permanent, Zone.EXILED, source, game);§Card card = game.getCard(permanent.getId());§if (card != null§&& card.getZoneChangeCounter(game) == zcc + 1§&& game.getState().getZone(card.getId()).equals(Zone.EXILED)) {§return controller.moveCards(card, Zone.BATTLEFIELD, source, game);§}§}§}§return false;§}§}§
public class SnareTheSkies extends CardImpl {§public SnareTheSkies(UUID ownerId) {§super(ownerId, 193, "Snare the Skies", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{G}");§this.expansionSetCode = "AVR";§this.getSpellAbility().addEffect(new BoostTargetEffect(1, 1, Duration.EndOfTurn));§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(ReachAbility.getInstance(), Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public SnareTheSkies(final SnareTheSkies card) {§super(card);§}§@Override§public SnareTheSkies copy() {§return new SnareTheSkies(this);§}§}§
public class TibaltTheFiendBlooded extends CardImpl {§public TibaltTheFiendBlooded(UUID ownerId) {§super(ownerId, 161, "Tibalt, the Fiend-Blooded", Rarity.MYTHIC, new CardType[]{CardType.PLANESWALKER}, "{R}{R}");§this.expansionSetCode = "AVR";§this.subtype.add("Tibalt");§this.addAbility(new PlanswalkerEntersWithLoyalityCountersAbility(2));§LoyaltyAbility ability = new LoyaltyAbility(new DrawCardSourceControllerEffect(1), 1);§Effect effect = new DiscardControllerEffect(1, true);§effect.setText(", then discard a card at random");§ability.addEffect(effect);§this.addAbility(ability);§effect = new DamageTargetEffect(new CardsInTargetHandCount(), true);§effect.setText("{this} deals damage equal to the number of cards in target player's hand to that player");§ability = new LoyaltyAbility(effect, -4);§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§this.addAbility(new LoyaltyAbility(new TibaltTheFiendBloodedThirdEffect(), -6));§}§public TibaltTheFiendBlooded(final TibaltTheFiendBlooded card) {§super(card);§}§@Override§public TibaltTheFiendBlooded copy() {§return new TibaltTheFiendBlooded(this);§}§}§class TibaltTheFiendBloodedFirstEffect extends OneShotEffect {§public TibaltTheFiendBloodedFirstEffect() {§super(Outcome.Benefit);§this.staticText = "Draw a card, then discard a card at random";§}§public TibaltTheFiendBloodedFirstEffect(final TibaltTheFiendBloodedFirstEffect effect) {§super(effect);§}§@Override§public TibaltTheFiendBloodedFirstEffect copy() {§return new TibaltTheFiendBloodedFirstEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§player.drawCards(1, game);§Card card = player.getHand().getRandom(game);§if (card != null) {§player.discard(card, source, game);§}§return true;§}§return false;§}§}§class TibaltTheFiendBloodedThirdEffect extends OneShotEffect {§public TibaltTheFiendBloodedThirdEffect() {§super(Outcome.GainControl);§this.staticText = "Gain control of all creatures until end of turn. Untap them. They gain haste until end of turn";§}§public TibaltTheFiendBloodedThirdEffect(final TibaltTheFiendBloodedThirdEffect effect) {§super(effect);§}§@Override§public TibaltTheFiendBloodedThirdEffect copy() {§return new TibaltTheFiendBloodedThirdEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§List<Permanent> permanents = game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(), source.getControllerId(), source.getSourceId(), game);§for (Permanent permanent : permanents) {§permanent.untap(game);§ContinuousEffect effect = new TibaltTheFiendBloodedControlEffect(source.getControllerId());§effect.setTargetPointer(new FixedTarget(permanent.getId()));§game.addEffect(effect, source);§effect = new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.EndOfTurn);§effect.setTargetPointer(new FixedTarget(permanent.getId()));§game.addEffect(effect, source);§}§return true;§}§}§class TibaltTheFiendBloodedControlEffect extends ContinuousEffectImpl {§private final UUID controllerId;§public TibaltTheFiendBloodedControlEffect(UUID controllerId) {§super(Duration.EndOfTurn, Layer.ControlChangingEffects_2, SubLayer.NA, Outcome.GainControl);§this.controllerId = controllerId;§}§public TibaltTheFiendBloodedControlEffect(final TibaltTheFiendBloodedControlEffect effect) {§super(effect);§this.controllerId = effect.controllerId;§}§@Override§public TibaltTheFiendBloodedControlEffect copy() {§return new TibaltTheFiendBloodedControlEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(targetPointer.getFirst(game, source));§if (permanent != null && controllerId != null) {§return permanent.changeControllerId(controllerId, game);§}§return false;§}§}§class CardsInTargetHandCount implements DynamicValue {§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§if (sourceAbility != null) {§Player player = game.getPlayer(sourceAbility.getFirstTarget());§if (player != null) {§return player.getHand().size();§}§}§return 0;§}§@Override§public DynamicValue copy() {§return new CardsInTargetHandCount();§}§@Override§public String getMessage() {§return "cards in that player's hand";§}§@Override§public String toString() {§return "";§}§}§
public class WildDefiance extends CardImpl {§public WildDefiance(UUID ownerId) {§super(ownerId, 203, "Wild Defiance", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{2}{G}");§this.expansionSetCode = "AVR";§this.addAbility(new CreaturesYouControlBecomesTargetTriggeredAbility(new BoostTargetEffect(3, 3, Duration.EndOfTurn)));§}§public WildDefiance(final WildDefiance card) {§super(card);§}§@Override§public WildDefiance copy() {§return new WildDefiance(this);§}§}§class CreaturesYouControlBecomesTargetTriggeredAbility extends TriggeredAbilityImpl {§public CreaturesYouControlBecomesTargetTriggeredAbility(Effect effect) {§super(Zone.BATTLEFIELD, effect);§}§public CreaturesYouControlBecomesTargetTriggeredAbility(final CreaturesYouControlBecomesTargetTriggeredAbility ability) {§super(ability);§}§@Override§public CreaturesYouControlBecomesTargetTriggeredAbility copy() {§return new CreaturesYouControlBecomesTargetTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.TARGETED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent permanent = game.getPermanent(event.getTargetId());§if (permanent != null && permanent.getControllerId().equals(this.controllerId) && permanent.getCardType().contains(CardType.CREATURE)) {§MageObject object = game.getObject(event.getSourceId());§if (object != null && object instanceof Spell) {§Card c = (Spell) object;§if (c.getCardType().contains(CardType.INSTANT) || c.getCardType().contains(CardType.SORCERY)) {§if (getTargets().size() == 0) {§for (Effect effect : getEffects()) {§effect.setTargetPointer(new FixedTarget(event.getTargetId()));§}§}§return true;§}§}§}§return false;§}§@Override§public String getRule() {§return "Whenever a creature you control becomes the target of an instant or sorcery spell, that creature gets +3/+3 until end of turn.";§}§}§
public class BelligerentWhiptail extends CardImpl {§public BelligerentWhiptail(UUID ownerId) {§super(ownerId, 141, "Belligerent Whiptail", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "BFZ";§this.subtype.add("Wurm");§this.power = new MageInt(4);§this.toughness = new MageInt(2);§this.addAbility(new LandfallAbility(new GainAbilitySourceEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn), false));§}§public BelligerentWhiptail(final BelligerentWhiptail card) {§super(card);§}§@Override§public BelligerentWhiptail copy() {§return new BelligerentWhiptail(this);§}§}§
public class CarrierThrall extends CardImpl {§public CarrierThrall(UUID ownerId) {§super(ownerId, 106, "Carrier Thrall", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "BFZ";§this.subtype.add("Vampire");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Effect effect = new CreateTokenEffect(new EldraziScionToken());§effect.setText("put a 1/1 colorless Eldrazi Scion creature token onto the battlefield. It has \"Sacrifice this creature: Add {C} to your mana pool.\"");§this.addAbility(new DiesTriggeredAbility(effect, false));§}§public CarrierThrall(final CarrierThrall card) {§super(card);§}§@Override§public CarrierThrall copy() {§return new CarrierThrall(this);§}§}§
public class DominatorDrone extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("another colorless creature");§static {§filter.add(new AnotherPredicate());§filter.add(new ColorlessPredicate());§}§public DominatorDrone(UUID ownerId) {§super(ownerId, 92, "Dominator Drone", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Drone");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(new DevoidAbility(this.color));§this.addAbility(new IngestAbility());§TriggeredAbility triggeredAbility = new EntersBattlefieldTriggeredAbility(new DamagePlayersEffect(2, TargetController.OPPONENT));§this.addAbility(new ConditionalTriggeredAbility(§triggeredAbility,§new PermanentsOnTheBattlefieldCondition(filter, CountType.MORE_THAN, 0),§"When {this} enters the battlefield, if you control another colorless creature, each opponent loses 2 life."));§}§public DominatorDrone(final DominatorDrone card) {§super(card);§}§@Override§public DominatorDrone copy() {§return new DominatorDrone(this);§}§}§
public class GeyserfieldStalker extends CardImpl {§public GeyserfieldStalker(UUID ownerId) {§super(ownerId, 111, "Geyserfield Stalker", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{B}");§this.expansionSetCode = "BFZ";§this.subtype.add("Elemental");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(new MenaceAbility());§this.addAbility(new LandfallAbility(new BoostSourceEffect(2, 2, Duration.EndOfTurn), false));§}§public GeyserfieldStalker(final GeyserfieldStalker card) {§super(card);§}§@Override§public GeyserfieldStalker copy() {§return new GeyserfieldStalker(this);§}§}§
public class InfuseWithTheElements extends CardImpl {§public InfuseWithTheElements(UUID ownerId) {§super(ownerId, 175, "Infuse with the Elements", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{3}{G}");§this.expansionSetCode = "BFZ";§this.getSpellAbility().setAbilityWord(AbilityWord.CONVERGE);§Effect effect = new AddCountersTargetEffect(CounterType.P1P1.createInstance(0), ColorsOfManaSpentToCastCount.getInstance());§effect.setText("Put X +1/+1 counters on target creature, where X is the number of colors of mana spent to cast {this}");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§effect = new GainAbilityTargetEffect(TrampleAbility.getInstance(), Duration.EndOfTurn);§effect.setText("That creature gains trample until end of turn");§this.getSpellAbility().addEffect(effect);§}§public InfuseWithTheElements(final InfuseWithTheElements card) {§super(card);§}§@Override§public InfuseWithTheElements copy() {§return new InfuseWithTheElements(this);§}§}§
public class MarchFromTheTomb extends CardImpl {§public MarchFromTheTomb(UUID ownerId) {§super(ownerId, 214, "March from the Tomb", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{W}{B}");§this.expansionSetCode = "BFZ";§Effect effect = new ReturnFromGraveyardToBattlefieldTargetEffect();§effect.setText("Return any number of target Ally creature cards with total converted mana cost of 8 or less from your graveyard to the battlefield");§this.getSpellAbility().addEffect(effect);§FilterCard filter = new FilterCreatureCard();§filter.add(new SubtypePredicate("Ally"));§this.getSpellAbility().addTarget(new MarchFromTheTombTarget(0, Integer.MAX_VALUE, filter));§}§public MarchFromTheTomb(final MarchFromTheTomb card) {§super(card);§}§@Override§public MarchFromTheTomb copy() {§return new MarchFromTheTomb(this);§}§}§class MarchFromTheTombTarget extends TargetCardInYourGraveyard {§public MarchFromTheTombTarget(int minNumTargets, int maxNumTargets, FilterCard filter) {§super(minNumTargets, maxNumTargets, filter);§}§public MarchFromTheTombTarget(MarchFromTheTombTarget target) {§super(target);§}§@Override§public Set<UUID> possibleTargets(UUID sourceId, UUID sourceControllerId, Game game) {§int cmcLeft = 8;§for (UUID targetId : this.getTargets()) {§Card card = game.getCard(targetId);§if (card != null) {§cmcLeft -= card.getManaCost().convertedManaCost();§}§}§Set<UUID> possibleTargets = super.possibleTargets(sourceId, sourceControllerId, game);§Set<UUID> leftPossibleTargets = new HashSet<>();§for (UUID targetId : possibleTargets) {§Card card = game.getCard(targetId);§if (card != null && card.getManaCost().convertedManaCost() <= cmcLeft) {§leftPossibleTargets.add(targetId);§}§}§setTargetName("any number of target Ally creature cards with total converted mana cost of 8 or less (" + cmcLeft + " left) from your graveyard");§return leftPossibleTargets;§}§@Override§public boolean canTarget(UUID playerId, UUID objectId, Ability source, Game game) {§if (super.canTarget(playerId, objectId, source, game)) {§int cmcLeft = 8;§for (UUID targetId : this.getTargets()) {§Card card = game.getCard(targetId);§if (card != null) {§cmcLeft -= card.getManaCost().convertedManaCost();§}§}§Card card = game.getCard(objectId);§return card != null && card.getManaCost().convertedManaCost() <= cmcLeft;§}§return false;§}§@Override§public MarchFromTheTombTarget copy() {§return new MarchFromTheTombTarget(this);§}§}§
public class OracleOfDust extends CardImpl {§public OracleOfDust(UUID ownerId) {§super(ownerId, 63, "Oracle of Dust", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{U}");§this.expansionSetCode = "BFZ";§this.subtype.add("Eldrazi");§this.subtype.add("Processor");§this.power = new MageInt(3);§this.toughness = new MageInt(5);§this.addAbility(new DevoidAbility(this.color));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawDiscardControllerEffect(1, 1), new ManaCostsImpl<>("{2}"));§ability.addCost(new ExileOpponentsCardFromExileToGraveyardCost(true));§this.addAbility(ability);§}§public OracleOfDust(final OracleOfDust card) {§super(card);§}§@Override§public OracleOfDust copy() {§return new OracleOfDust(this);§}§}§
public class RetreatToValakut extends CardImpl {§public RetreatToValakut(UUID ownerId) {§super(ownerId, 153, "Retreat to Valakut", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{R}");§this.expansionSetCode = "BFZ";§LandfallAbility ability = new LandfallAbility(new BoostTargetEffect(2, 0, Duration.EndOfTurn), false);§ability.addTarget(new TargetCreaturePermanent());§Mode mode = new Mode();§mode.getEffects().add(new CantBlockTargetEffect(Duration.EndOfTurn));§mode.getTargets().add(new TargetCreaturePermanent());§ability.addMode(mode);§this.addAbility(ability);§}§public RetreatToValakut(final RetreatToValakut card) {§super(card);§}§@Override§public RetreatToValakut copy() {§return new RetreatToValakut(this);§}§}§
public class ShamblingVent extends CardImpl {§public ShamblingVent(UUID ownerId) {§super(ownerId, 244, "Shambling Vent", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "BFZ";§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new WhiteManaAbility());§this.addAbility(new BlackManaAbility());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BecomesCreatureSourceEffect(§new ShamblingVentToken(), "land", Duration.EndOfTurn), new ManaCostsImpl("{1}{W}{B}")));§}§public ShamblingVent(final ShamblingVent card) {§super(card);§}§@Override§public ShamblingVent copy() {§return new ShamblingVent(this);§}§}§class ShamblingVentToken extends Token {§public ShamblingVentToken() {§super("", "2/3 white and black Elemental creature with lifelink");§cardType.add(CardType.CREATURE);§subtype.add("Elemental");§color.setWhite(true);§color.setBlack(true);§power = new MageInt(2);§toughness = new MageInt(3);§addAbility(LifelinkAbility.getInstance());§}§}§
public class SwarmSurge extends CardImpl {§private static final FilterCreaturePermanent FILTER = new FilterCreaturePermanent("Colorless creatures you control");§static {§FILTER.add(new ColorlessPredicate());§}§public SwarmSurge(UUID ownerId) {§super(ownerId, 100, "Swarm Surge", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{B}");§this.expansionSetCode = "BFZ";§Ability ability = new DevoidAbility(this.color);§ability.setRuleAtTheTop(true);§this.addAbility(ability);§this.getSpellAbility().addEffect(new BoostControlledEffect(2, 0, Duration.EndOfTurn));§Effect effect = new GainAbilityControlledEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn, FILTER);§effect.setText("Colorless creatures you control also gain first strike until end of turn");§this.getSpellAbility().addEffect(effect);§}§public SwarmSurge(final SwarmSurge card) {§super(card);§}§@Override§public SwarmSurge copy() {§return new SwarmSurge(this);§}§}§
public class UnnaturalAggression extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature an opponent controls");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public UnnaturalAggression(UUID ownerId) {§super(ownerId, 168, "Unnatural Aggression", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{G}");§this.expansionSetCode = "BFZ";§Ability ability = new DevoidAbility(this.color);§ability.setRuleAtTheTop(true);§this.addAbility(ability);§this.getSpellAbility().addEffect(new FightTargetsEffect());§this.getSpellAbility().addTarget(new TargetControlledCreaturePermanent());§this.getSpellAbility().addTarget(new TargetCreaturePermanent(filter));§this.getSpellAbility().addEffect(new DealtDamageToOpponentsCreatureDiesEffect(Duration.EndOfTurn));§}§public UnnaturalAggression(final UnnaturalAggression card) {§super(card);§}§@Override§public UnnaturalAggression copy() {§return new UnnaturalAggression(this);§}§}§class DealtDamageToOpponentsCreatureDiesEffect extends ReplacementEffectImpl {§public DealtDamageToOpponentsCreatureDiesEffect(Duration duration) {§super(Duration.EndOfTurn, Outcome.Exile);§staticText = "If the creature an opponent controls would die this turn, exile it instead";§}§public DealtDamageToOpponentsCreatureDiesEffect(final DealtDamageToOpponentsCreatureDiesEffect effect) {§super(effect);§}§@Override§public DealtDamageToOpponentsCreatureDiesEffect copy() {§return new DealtDamageToOpponentsCreatureDiesEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public void init(Ability source, Game game) {§super.init(source, game);§Permanent opponentCreature = game.getPermanent(source.getTargets().get(1).getFirstTarget());§if (opponentCreature != null) {§this.setTargetPointer(new FixedTarget(opponentCreature, game));§} else {§discard();§}§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§Permanent permanent = ((ZoneChangeEvent) event).getTarget();§Player controller = game.getPlayer(source.getControllerId());§if (controller != null && permanent != null) {§return controller.moveCards(permanent, null, Zone.EXILED, source, game);§}§return false;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == EventType.ZONE_CHANGE;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§ZoneChangeEvent zce = (ZoneChangeEvent) event;§return zce.isDiesEvent() && zce.getTargetId().equals(getTargetPointer().getFirst(game, source));§}§}§
public class BakuAltar extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public BakuAltar(UUID ownerId) {§super(ownerId, 152, "Baku Altar", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "BOK";§this.addAbility(new SpellCastControllerTriggeredAbility(new AddCountersSourceEffect(CounterType.KI.createInstance(1)), filter, true));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CreateTokenEffect(new SpiritToken(), 1), new GenericManaCost(2));§ability.addCost(new TapSourceCost());§ability.addCost(new RemoveCountersSourceCost(CounterType.KI.createInstance(1)));§this.addAbility(ability);§}§public BakuAltar(final BakuAltar card) {§super(card);§}§@Override§public BakuAltar copy() {§return new BakuAltar(this);§}§}§
public class Eradicate extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("nonblack creature");§static {§filter.add(Predicates.not(new ColorPredicate(ObjectColor.BLACK)));§}§public Eradicate(UUID ownerId) {§super(ownerId, 65, "Eradicate", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{2}{B}{B}");§this.expansionSetCode = "BOK";§this.getSpellAbility().addTarget(new TargetCreaturePermanent(filter));§this.getSpellAbility().addEffect(new ExileTargetAndSearchGraveyardHandLibraryEffect(false, "its controller's","all cards with the same name as that creature"));§}§public Eradicate(final Eradicate card) {§super(card);§}§@Override§public Eradicate copy() {§return new Eradicate(this);§}§}§
public class HarbingerOfSpring extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("non-Spirit creatures");§static {§filter.add(Predicates.not(new SubtypePredicate("Spirit")));§}§public HarbingerOfSpring(UUID ownerId) {§super(ownerId, 128, "Harbinger of Spring", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{G}");§this.expansionSetCode = "BOK";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new ProtectionAbility(filter));§this.addAbility(new SoulshiftAbility(4));§}§public HarbingerOfSpring(final HarbingerOfSpring card) {§super(card);§}§@Override§public HarbingerOfSpring copy() {§return new HarbingerOfSpring(this);§}§}§
public class KamiOfTatteredShoji extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public KamiOfTatteredShoji(UUID ownerId) {§super(ownerId, 11, "Kami of Tattered Shoji", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{W}");§this.expansionSetCode = "BOK";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(5);§this.addAbility(new SpellCastControllerTriggeredAbility(new GainAbilitySourceEffect(FlyingAbility.getInstance(), Duration.EndOfTurn), filter, false));§}§public KamiOfTatteredShoji(final KamiOfTatteredShoji card) {§super(card);§}§@Override§public KamiOfTatteredShoji copy() {§return new KamiOfTatteredShoji(this);§}§}§
public class MoonlitStrider extends CardImpl {§public MoonlitStrider(UUID ownerId) {§super(ownerId, 16, "Moonlit Strider", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "BOK";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(4);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainProtectionFromColorTargetEffect(Duration.EndOfTurn), new SacrificeSourceCost());§ability.addTarget(new TargetControlledCreaturePermanent());§this.addAbility(ability);§this.addAbility(new SoulshiftAbility(3));§}§public MoonlitStrider(final MoonlitStrider card) {§super(card);§}§@Override§public MoonlitStrider copy() {§return new MoonlitStrider(this);§}§}§
public class PsychicSpear extends CardImpl {§private static final FilterCard filter = new FilterCard("a Spirit or Arcane card to discard");§static {§filter.add(Predicates.or(new SubtypePredicate("Spirit"),new SubtypePredicate("Arcane")));§}§public PsychicSpear(UUID ownerId) {§super(ownerId, 78, "Psychic Spear", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{B}");§this.expansionSetCode = "BOK";§this.getSpellAbility().addTarget(new TargetPlayer());§this.getSpellAbility().addEffect(new DiscardCardYouChooseTargetEffect(filter, TargetController.ANY));§}§public PsychicSpear(final PsychicSpear card) {§super(card);§}§@Override§public PsychicSpear copy() {§return new PsychicSpear(this);§}§}§
public class Shuriken extends CardImpl {§public Shuriken(UUID ownerId) {§super(ownerId, 160, "Shuriken", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "BOK";§this.subtype.add("Equipment");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ShurikenDamageEffect(), new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§ability.addCost(new ShurikenUnattachCost());§ability.addEffect(new ShurikenControlEffect());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(ability, AttachmentType.EQUIPMENT, Duration.WhileOnBattlefield)));§this.addAbility(new EquipAbility(Outcome.PreventDamage, new GenericManaCost(2)));§}§public Shuriken(final Shuriken card) {§super(card);§}§@Override§public Shuriken copy() {§return new Shuriken(this);§}§}§class ShurikenDamageEffect extends OneShotEffect {§public ShurikenDamageEffect() {§super(Outcome.Damage);§this.staticText = "Shuriken deals 2 damage to target creature";§}§public ShurikenDamageEffect(final ShurikenDamageEffect effect) {§super(effect);§}§@Override§public ShurikenDamageEffect copy() {§return new ShurikenDamageEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent equipment = null;§for(Cost cost : source.getCosts()) {§if (cost instanceof ShurikenUnattachCost) {§equipment = ((ShurikenUnattachCost) cost).getEquipment();§break;§}§}§if (equipment != null) {§Permanent creature = game.getPermanent(this.getTargetPointer().getFirst(game, source));§if (creature != null) {§creature.damage(2, equipment.getId(), game, false, true);§}§return true;§}§return false;§}§}§class ShurikenUnattachCost extends CostImpl {§Permanent equipment;§public ShurikenUnattachCost() {§this.text = "Unattach Shuriken";§}§public ShurikenUnattachCost(final ShurikenUnattachCost cost) {§super(cost);§this.equipment = cost.equipment;§}§@Override§public boolean pay(Ability ability, Game game, UUID sourceId, UUID controllerId, boolean noMana, Cost costToPay) {§Permanent permanent = game.getPermanent(sourceId);§if (permanent != null) {§for (UUID attachmentId :permanent.getAttachments()) {§Permanent attachment = game.getPermanent(attachmentId);§if (attachment != null && attachment.getName().equals("Shuriken")) {§paid = permanent.removeAttachment(attachmentId, game);§if (paid) {§equipment = attachment;§break;§}§}§}§}§return paid;§}§@Override§public boolean canPay(Ability ability, UUID sourceId, UUID controllerId, Game game) {§Permanent permanent = game.getPermanent(sourceId);§if (permanent != null) {§for (UUID attachmentId :permanent.getAttachments()) {§Permanent attachment = game.getPermanent(attachmentId);§if (attachment != null && attachment.getName().equals("Shuriken")) {§return true;§}§}§}§return false;§}§@Override§public ShurikenUnattachCost copy() {§return new ShurikenUnattachCost(this);§}§public Permanent getEquipment() {§return equipment;§}§}§class ShurikenControlEffect extends OneShotEffect {§public ShurikenControlEffect() {§super(Outcome.Benefit);§this.staticText = "That creature's controller gains control of Shuriken unless it was unattached from a Ninja";§}§public ShurikenControlEffect(final ShurikenControlEffect effect) {§super(effect);§}§@Override§public ShurikenControlEffect copy() {§return new ShurikenControlEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent equipment = null; §
public class TerashisVerdict extends CardImpl {§private static final FilterAttackingCreature filter = new FilterAttackingCreature("attacking creature with power 3 or less");§static {§filter.add(new PowerPredicate(Filter.ComparisonType.LessThan, 4));§}§public TerashisVerdict(UUID ownerId) {§super(ownerId, 27, "Terashi's Verdict", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{W}");§this.expansionSetCode = "BOK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addTarget(new TargetAttackingCreature(1, 1, filter, false));§}§public TerashisVerdict(final TerashisVerdict card) {§super(card);§}§@Override§public TerashisVerdict copy() {§return new TerashisVerdict(this);§}§}§
public class YukoraThePrisoner extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("non-Ogre creatures");§static {§filter.add(Predicates.not(new SubtypePredicate("Ogre")));§}§public YukoraThePrisoner(UUID ownerId) {§super(ownerId, 90, "Yukora, the Prisoner", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{B}{B}");§this.expansionSetCode = "BOK";§this.supertype.add("Legendary");§this.subtype.add("Demon");§this.subtype.add("Spirit");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(new LeavesBattlefieldTriggeredAbility(new YukoraThePrisonerEffect(), false));§}§public YukoraThePrisoner(final YukoraThePrisoner card) {§super(card);§}§@Override§public YukoraThePrisoner copy() {§return new YukoraThePrisoner(this);§}§}§class YukoraThePrisonerEffect extends OneShotEffect {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("non-Ogre creatures");§static {§filter.add(Predicates.not(new SubtypePredicate("Ogre")));§}§public YukoraThePrisonerEffect() {§super(Outcome.Sacrifice);§this.staticText = "sacrifice all non-Ogre creatures you control";§}§public YukoraThePrisonerEffect(final YukoraThePrisonerEffect effect) {§super(effect);§}§@Override§public YukoraThePrisonerEffect copy() {§return new YukoraThePrisonerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§List<Permanent> permanents = game.getBattlefield().getAllActivePermanents(filter, source.getControllerId(), game);§for (Permanent permanent : permanents) {§permanent.sacrifice(source.getSourceId(), game);§}§return true;§}§}§
public class BrimazKingOfOreskos extends CardImpl {§public BrimazKingOfOreskos(UUID ownerId) {§super(ownerId, 5, "Brimaz, King of Oreskos", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{1}{W}{W}");§this.expansionSetCode = "BNG";§this.supertype.add("Legendary");§this.subtype.add("Cat");§this.subtype.add("Soldier");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(new AttacksTriggeredAbility(new CreateTokenEffect(new CatSoldierCreatureToken(), 1, false, true), false));§this.addAbility(new BlocksCreatureTriggeredAbility(new BrimazKingOfOreskosEffect(), false, true));§}§public BrimazKingOfOreskos(final BrimazKingOfOreskos card) {§super(card);§}§@Override§public BrimazKingOfOreskos copy() {§return new BrimazKingOfOreskos(this);§}§}§class BrimazKingOfOreskosEffect extends OneShotEffect {§public BrimazKingOfOreskosEffect() {§super(Outcome.Benefit);§this.staticText = "put a 1/1 white Cat Soldier creature token with vigilance onto the battlefield blocking that creature";§}§public BrimazKingOfOreskosEffect(final BrimazKingOfOreskosEffect effect) {§super(effect);§}§@Override§public BrimazKingOfOreskosEffect copy() {§return new BrimazKingOfOreskosEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Token token = new CatSoldierCreatureToken();§token.putOntoBattlefield(1, game, source.getSourceId(), source.getControllerId());§Permanent attackingCreature = game.getPermanent(getTargetPointer().getFirst(game, source));§if (attackingCreature != null && game.getState().getCombat() != null) {§CombatGroup combatGroup = game.getState().getCombat().findGroup(attackingCreature.getId());§if (combatGroup != null) {§for (UUID tokenId : token.getLastAddedTokenIds()) {§Permanent catToken = game.getPermanent(tokenId);§if (catToken != null) {§combatGroup.addBlocker(tokenId, source.getControllerId(), game);§game.getCombat().addBlockingGroup(tokenId, attackingCreature.getId(), controller.getId(), game);§}§}§combatGroup.pickBlockerOrder(attackingCreature.getControllerId(), game);§}§}§return true;§}§return false;§}§}§
public class EvanescentIntellect extends CardImpl {§public EvanescentIntellect(UUID ownerId) {§super(ownerId, 38, "Evanescent Intellect", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{U}");§this.expansionSetCode = "BNG";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PutTopCardOfLibraryIntoGraveTargetEffect(3), new ManaCostsImpl("{1}{U}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetPlayer());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(ability, AttachmentType.AURA, Duration.WhileOnBattlefield)));§}§public EvanescentIntellect(final EvanescentIntellect card) {§super(card);§}§@Override§public EvanescentIntellect copy() {§return new EvanescentIntellect(this);§}§}§
public class ForsakenDrifters extends CardImpl {§public ForsakenDrifters(UUID ownerId) {§super(ownerId, 72, "Forsaken Drifters", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{B}");§this.expansionSetCode = "BNG";§this.subtype.add("Zombie");§this.power = new MageInt(4);§this.toughness = new MageInt(2);§this.addAbility(new DiesTriggeredAbility(new PutTopCardOfLibraryIntoGraveControllerEffect(4)));§}§public ForsakenDrifters(final ForsakenDrifters card) {§super(card);§}§@Override§public ForsakenDrifters copy() {§return new ForsakenDrifters(this);§}§}§
public class KioraTheCrashingWave extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("permanent an opponent control");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public KioraTheCrashingWave(UUID ownerId) {§super(ownerId, 149, "Kiora, the Crashing Wave", Rarity.MYTHIC, new CardType[]{CardType.PLANESWALKER}, "{2}{G}{U}");§this.expansionSetCode = "BNG";§this.subtype.add("Kiora");§this.addAbility(new PlanswalkerEntersWithLoyalityCountersAbility(2));§LoyaltyAbility ability = new LoyaltyAbility(new KioraPreventionEffect(), 1);§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§ability = new LoyaltyAbility(new DrawCardSourceControllerEffect(1), -1);§ability.addEffect(new PlayAdditionalLandsControllerEffect(1, Duration.EndOfTurn));§this.addAbility(ability);§this.addAbility(new LoyaltyAbility(new GetEmblemEffect(new KioraEmblem()), -5));§}§public KioraTheCrashingWave(final KioraTheCrashingWave card) {§super(card);§}§@Override§public KioraTheCrashingWave copy() {§return new KioraTheCrashingWave(this);§}§}§class KioraPreventionEffect extends PreventionEffectImpl {§public KioraPreventionEffect() {§super(Duration.UntilYourNextTurn, Integer.MAX_VALUE, false, false);§staticText = "Until your next turn, prevent all damage that would be dealt to and dealt by target permanent an opponent controls";§}§public KioraPreventionEffect(final KioraPreventionEffect effect) {§super(effect);§}§@Override§public KioraPreventionEffect copy() {§return new KioraPreventionEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public void init(Ability source, Game game) {§super.init(source, game);§for (UUID targetId : this.getTargetPointer().getTargets(game, source)) {§Permanent permanent = game.getPermanent(targetId);§if (permanent != null) {§permanent.addInfo(new StringBuilder("kioraPrevention").append(getId()).toString(), CardUtil.addToolTipMarkTags("All damage that would be dealt to and dealt by this permanent is prevented."), game);§}§}§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (super.applies(event, source, game) && event instanceof DamageEvent) {§Permanent targetPermanent = game.getPermanent(this.getTargetPointer().getFirst(game, source));§if (targetPermanent != null§&& (event.getSourceId().equals(targetPermanent.getId()) || event.getTargetId().equals(targetPermanent.getId()))) {§return true;§}§}§return false;§}§@Override§public boolean isInactive(Ability source, Game game) {§if (super.isInactive(source, game)) {§for (UUID targetId : this.getTargetPointer().getTargets(game, source)) {§Permanent permanent = game.getPermanent(targetId);§if (permanent != null) {§permanent.addInfo(new StringBuilder("kioraPrevention").append(getId()).toString(), "", game);§}§}§return true;§}§return false;§}§}§/**§* Emblem: "At the beginning of your end step, put a 9/9 blue Kraken creature§* token onto the battlefield."§*/§class KioraEmblem extends Emblem {§public KioraEmblem() {§this.setName("EMBLEM: Kiora, the Crashing Wave");§Ability ability = new BeginningOfEndStepTriggeredAbility(Zone.COMMAND, new CreateTokenEffect(new KioraKrakenToken()), TargetController.YOU, null, false);§this.getAbilities().add(ability);§}§}§class KioraKrakenToken extends Token {§public KioraKrakenToken() {§super("Kraken", "9/9 blue Kraken creature token");§cardType.add(CardType.CREATURE);§color.setBlue(true);§subtype.add("Kraken");§power = new MageInt(9);§toughness = new MageInt(9);§this.setOriginalExpansionSetCode("BNG");§}§}§
public class NyxbornWolf extends CardImpl {§public NyxbornWolf(UUID ownerId) {§super(ownerId, 131, "Nyxborn Wolf", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "BNG";§this.subtype.add("Wolf");§this.power = new MageInt(3);§this.toughness = new MageInt(1);§this.addAbility(new BestowAbility(this, "{4}{G}"));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(3,1, Duration.WhileOnBattlefield)));§}§public NyxbornWolf(final NyxbornWolf card) {§super(card);§}§@Override§public NyxbornWolf copy() {§return new NyxbornWolf(this);§}§}§
public class RetractionHelix extends CardImpl {§public RetractionHelix(UUID ownerId) {§super(ownerId, 49, "Retraction Helix", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{U}");§this.expansionSetCode = "BNG";§Ability gainedAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ReturnToHandTargetEffect(), new TapSourceCost());§Target target = new TargetNonlandPermanent();§gainedAbility.addTarget(target);§Effect effect = new GainAbilityTargetEffect(gainedAbility, Duration.EndOfTurn);§effect.setText("Until end of turn, target creature gains \"{T}: Return target nonland permanent to its owner's hand.\"");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public RetractionHelix(final RetractionHelix card) {§super(card);§}§@Override§public RetractionHelix copy() {§return new RetractionHelix(this);§}§}§
public class SpiritOfTheLabyrinth extends CardImpl {§public SpiritOfTheLabyrinth(UUID ownerId) {§super(ownerId, 27, "Spirit of the Labyrinth", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "BNG";§this.subtype.add("Spirit");§this.power = new MageInt(3);§this.toughness = new MageInt(1);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new SpiritOfTheLabyrinthEffect()), new SpiritOfTheLabyrinthWatcher());§}§public SpiritOfTheLabyrinth(final SpiritOfTheLabyrinth card) {§super(card);§}§@Override§public SpiritOfTheLabyrinth copy() {§return new SpiritOfTheLabyrinth(this);§}§}§class SpiritOfTheLabyrinthWatcher extends Watcher {§private final HashSet<UUID> playersThatDrewCard;§public SpiritOfTheLabyrinthWatcher() {§super("DrewCard", WatcherScope.GAME);§this.playersThatDrewCard = new HashSet<>();§}§public SpiritOfTheLabyrinthWatcher(final SpiritOfTheLabyrinthWatcher watcher) {§super(watcher);§this.playersThatDrewCard = new HashSet<>();§playersThatDrewCard.addAll(watcher.playersThatDrewCard);§}§@Override§public SpiritOfTheLabyrinthWatcher copy() {§return new SpiritOfTheLabyrinthWatcher(this);§}§@Override§public void watch(GameEvent event, Game game) {§if (event.getType() == GameEvent.EventType.DREW_CARD ) {§if (!playersThatDrewCard.contains(event.getPlayerId())) {§playersThatDrewCard.add(event.getPlayerId());§}§}§}§@Override§public void reset() {§super.reset();§playersThatDrewCard.clear();§}§public boolean hasPlayerDrewCardThisTurn(UUID playerId) {§return playersThatDrewCard.contains(playerId);§}§}§class SpiritOfTheLabyrinthEffect extends ContinuousRuleModifyingEffectImpl {§public SpiritOfTheLabyrinthEffect() {§super(Duration.WhileOnBattlefield, Outcome.Detriment, false, false);§staticText = "Each player can't draw more than one card each turn";§}§public SpiritOfTheLabyrinthEffect(final SpiritOfTheLabyrinthEffect effect) {§super(effect);§}§@Override§public SpiritOfTheLabyrinthEffect copy() {§return new SpiritOfTheLabyrinthEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.DRAW_CARD;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§SpiritOfTheLabyrinthWatcher watcher = (SpiritOfTheLabyrinthWatcher) game.getState().getWatchers().get("DrewCard");§if (watcher != null && watcher.hasPlayerDrewCardThisTurn(event.getPlayerId())) {§return true;§}§return false;§}§}§
public class WhelmingWave extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent();§static {§filter.add(Predicates.not(§Predicates.or(§new SubtypePredicate("Kraken"),§new SubtypePredicate("Leviathan"),§new SubtypePredicate("Octopus"),§new SubtypePredicate("Serpent"))));§}§public WhelmingWave(UUID ownerId) {§super(ownerId, 57, "Whelming Wave", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{2}{U}{U}");§this.expansionSetCode = "BNG";§Effect effect = new ReturnToHandFromBattlefieldAllEffect(filter);§effect.setText("Return all creatures to their owners' hands except for Krakens, Leviathans, Octopuses and Serpents");§this.getSpellAbility().addEffect(effect);§}§public WhelmingWave(final WhelmingWave card) {§super(card);§}§@Override§public WhelmingWave copy() {§return new WhelmingWave(this);§}§}§
public class BoseijuWhoSheltersAll extends CardImpl {§public BoseijuWhoSheltersAll(UUID ownerId) {§super(ownerId, 273, "Boseiju, Who Shelters All", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.addAbility(new EntersBattlefieldTappedAbility());§Mana mana = new Mana(0, 0, 0, 0, 0, 0, 0, 1);§mana.setFlag(true); §
public class DeathcurseOgre extends CardImpl {§public DeathcurseOgre (UUID ownerId) {§super(ownerId, 109, "Deathcurse Ogre", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{5}{B}");§this.expansionSetCode = "CHK";§this.subtype.add("Ogre");§this.subtype.add("Warrior");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new DiesTriggeredAbility(new LoseLifeAllPlayersEffect(3)));§}§public DeathcurseOgre (final DeathcurseOgre card) {§super(card);§}§@Override§public DeathcurseOgre copy() {§return new DeathcurseOgre(this);§}§}§
public class GeneralsKabuto extends CardImpl {§public GeneralsKabuto (UUID ownerId) {§super(ownerId, 251, "General's Kabuto", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "CHK";§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(ShroudAbility.getInstance(), AttachmentType.EQUIPMENT)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new PreventAllDamageToAttachedEffect(Duration.WhileOnBattlefield, "equipped creature", true)));§this.addAbility(new EquipAbility(Outcome.PreventDamage, new GenericManaCost(2)));§}§public GeneralsKabuto (final GeneralsKabuto card) {§super(card);§}§@Override§public GeneralsKabuto copy() {§return new GeneralsKabuto(this);§}§}§
public class Hinder extends CardImpl {§public Hinder(UUID ownerId) {§super(ownerId, 65, "Hinder", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{U}{U}");§this.expansionSetCode = "CHK";§this.getSpellAbility().addEffect(new CounterTargetWithReplacementEffect(Zone.LIBRARY, ZoneDetail.CHOOSE));§this.getSpellAbility().addTarget(new TargetSpell());§}§public Hinder(final Hinder card) {§super(card);§}§@Override§public Hinder copy() {§return new Hinder(this);§}§}§
public class InnocenceKami extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public InnocenceKami(UUID ownerId) {§super(ownerId, 18, "Innocence Kami", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{W}{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TapTargetEffect(), new ColoredManaCost(ColoredManaSymbol.W));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§this.addAbility(new SpellCastControllerTriggeredAbility(new UntapSourceEffect(), filter, false));§}§public InnocenceKami(final InnocenceKami card) {§super(card);§}§@Override§public InnocenceKami copy() {§return new InnocenceKami(this);§}§}§
public class KashiTribeWarriors extends CardImpl {§public KashiTribeWarriors(UUID ownerId) {§super(ownerId, 221, "Kashi-Tribe Warriors", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{G}{G}");§this.expansionSetCode = "CHK";§this.subtype.add("Snake");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(4);§Ability ability;§ability = new DealsDamageToACreatureTriggeredAbility(new TapTargetEffect("that creature"), true, false, true);§ability.addEffect(new DontUntapInControllersNextUntapStepTargetEffect("and it"));§this.addAbility(ability);§}§public KashiTribeWarriors(final KashiTribeWarriors card) {§super(card);§}§@Override§public KashiTribeWarriors copy() {§return new KashiTribeWarriors(this);§}§}§
public class LanternKami extends CardImpl {§public LanternKami (UUID ownerId) {§super(ownerId, 32, "Lantern Kami", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{W}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§}§public LanternKami (final LanternKami card) {§super(card);§}§@Override§public LanternKami copy() {§return new LanternKami(this);§}§}§
public class MyojinOfNightsReach extends CardImpl {§public MyojinOfNightsReach(UUID ownerId) {§super(ownerId, 126, "Myojin of Night's Reach", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{B}{B}{B}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Spirit");§this.power = new MageInt(5);§this.toughness = new MageInt(2);§this.getSpellAbility().addWatcher(new CastFromHandWatcher());§this.addAbility(new EntersBattlefieldAbility(new ConditionalOneShotEffect(new AddCountersSourceEffect(CounterType.DIVINITY.createInstance()), new CastFromHandCondition(), ""), "{this} enters the battlefield with a divinity counter on it if you cast it from your hand"));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(new GainAbilitySourceEffect(IndestructibleAbility.getInstance(), Duration.WhileOnBattlefield),§new SourceHasCounterCondition(CounterType.DIVINITY), "{this} is indestructible as long as it has a divinity counter on it")));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new MyojinOfNightsReachEffect(), new RemoveCountersSourceCost(CounterType.DIVINITY.createInstance()));§this.addAbility(ability);§}§public MyojinOfNightsReach(final MyojinOfNightsReach card) {§super(card);§}§@Override§public MyojinOfNightsReach copy() {§return new MyojinOfNightsReach(this);§}§}§class MyojinOfNightsReachEffect extends OneShotEffect {§public MyojinOfNightsReachEffect() {§super(Outcome.Discard);§staticText = "Each opponent discards his or her hand";§}§public MyojinOfNightsReachEffect(final MyojinOfNightsReachEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§for (UUID opponentId : game.getOpponents(source.getControllerId())) {§Player opponent = game.getPlayer(opponentId);§for (Card c : opponent.getHand().getCards(game)) {§opponent.discard(c, source, game);§}§}§return true;§}§@Override§public MyojinOfNightsReachEffect copy() {§return new MyojinOfNightsReachEffect(this);§}§}§
public class OreGorger extends CardImpl {§private static final FilterSpiritOrArcaneCard filter = new FilterSpiritOrArcaneCard();§public OreGorger(UUID ownerId) {§super(ownerId, 182, "Ore Gorger", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{R}{R}");§this.expansionSetCode = "CHK";§this.subtype.add("Spirit");§this.power = new MageInt(3);§this.toughness = new MageInt(1);§Ability ability = new SpellCastControllerTriggeredAbility(new DestroyTargetEffect(), filter, true);§ability.addTarget(new TargetNonBasicLandPermanent());§this.addAbility(ability);§}§public OreGorger(final OreGorger card) {§super(card);§}§@Override§public OreGorger copy() {§return new OreGorger(this);§}§}§
public class ReitoLantern extends CardImpl {§public ReitoLantern(UUID ownerId) {§super(ownerId, 267, "Reito Lantern", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "CHK";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PutOnLibraryTargetEffect(false), new GenericManaCost(3));§ability.addTarget(new TargetCardInGraveyard());§this.addAbility(ability);§}§public ReitoLantern(final ReitoLantern card) {§super(card);§}§@Override§public ReitoLantern copy() {§return new ReitoLantern(this);§}§}§
public class ShimatsuTheBloodcloaked extends CardImpl {§public ShimatsuTheBloodcloaked(UUID ownerId) {§super(ownerId, 186, "Shimatsu the Bloodcloaked", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "CHK";§this.supertype.add("Legendary");§this.subtype.add("Demon");§this.subtype.add("Spirit");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(new SimpleStaticAbility(Zone.ALL, new ShimatsuTheBloodcloakedEffect()));§}§public ShimatsuTheBloodcloaked(final ShimatsuTheBloodcloaked card) {§super(card);§}§@Override§public ShimatsuTheBloodcloaked copy() {§return new ShimatsuTheBloodcloaked(this);§}§}§class ShimatsuTheBloodcloakedEffect extends ReplacementEffectImpl {§public ShimatsuTheBloodcloakedEffect() {§super(Duration.EndOfGame, Outcome.BoostCreature);§this.staticText = "As {this} enters the battlefield, sacrifice any number of permanents. {this} enters the battlefield with that many +1/+1 counters on it";§}§public ShimatsuTheBloodcloakedEffect(final ShimatsuTheBloodcloakedEffect effect) {§super(effect);§}§@Override§public ShimatsuTheBloodcloakedEffect copy() {§return new ShimatsuTheBloodcloakedEffect(this);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.ENTERS_THE_BATTLEFIELD;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§return event.getTargetId().equals(source.getSourceId());§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§Permanent creature = ((EntersTheBattlefieldEvent) event).getTarget();§Player controller = game.getPlayer(source.getControllerId());§if (creature != null && controller != null) {§Target target = new TargetControlledPermanent(0, Integer.MAX_VALUE, new FilterControlledPermanent(), true);§if (!target.canChoose(source.getSourceId(), source.getControllerId(), game)) {§return false;§}§controller.chooseTarget(Outcome.Detriment, target, source, game);§if (target.getTargets().size() > 0) {§int sacrificedCreatures = target.getTargets().size();§game.informPlayers(controller.getLogName() + " sacrifices " + sacrificedCreatures + " creatures for " + creature.getLogName());§for (UUID targetId : target.getTargets()) {§Permanent targetCreature = game.getPermanent(targetId);§if (targetCreature == null || !targetCreature.sacrifice(source.getSourceId(), game)) {§return false;§}§}§creature.addCounters(CounterType.P1P1.createInstance(sacrificedCreatures), game);§}§}§return false;§}§}§
public class StrangeInversion extends CardImpl {§public StrangeInversion(UUID ownerId) {§super(ownerId, 192, "Strange Inversion", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{2}{R}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new SwitchPowerToughnessTargetEffect(Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.addAbility(new SpliceOntoArcaneAbility("{1}{R}"));§}§public StrangeInversion(final StrangeInversion card) {§super(card);§}§@Override§public StrangeInversion copy() {§return new StrangeInversion(this);§}§}§
public class UnnaturalSpeed extends CardImpl {§public UnnaturalSpeed (UUID ownerId) {§super(ownerId, 197, "Unnatural Speed", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{R}");§this.expansionSetCode = "CHK";§this.subtype.add("Arcane");§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public UnnaturalSpeed (final UnnaturalSpeed card) {§super(card);§}§@Override§public UnnaturalSpeed copy() {§return new UnnaturalSpeed(this);§}§}§
public class AdarkarWindform extends CardImpl {§public AdarkarWindform(UUID ownerId) {§super(ownerId, 26, "Adarkar Windform", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{U}");§this.expansionSetCode = "CSP";§this.supertype.add("Snow");§this.subtype.add("Illusion");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new LoseAbilityTargetEffect(§FlyingAbility.getInstance(), Duration.EndOfTurn), new ManaCostsImpl("{1}{S}"));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public AdarkarWindform(final AdarkarWindform card) {§super(card);§}§@Override§public AdarkarWindform copy() {§return new AdarkarWindform(this);§}§}§
public class DiamondFaerie extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Snow creatures");§static {§filter.add(new SupertypePredicate("Snow"));§}§public DiamondFaerie(UUID ownerId) {§super(ownerId, 128, "Diamond Faerie", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{G}{W}{U}");§this.expansionSetCode = "CSP";§this.supertype.add("Snow");§this.subtype.add("Faerie");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostControlledEffect(1, 1,§Duration.EndOfTurn, filter), new ManaCostsImpl("{1}{S}")));§}§public DiamondFaerie(final DiamondFaerie card) {§super(card);§}§@Override§public DiamondFaerie copy() {§return new DiamondFaerie(this);§}§}§
public class KarplusanWolverine extends CardImpl {§public KarplusanWolverine(UUID ownerId) {§super(ownerId, 87, "Karplusan Wolverine", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "CSP";§this.supertype.add("Snow");§this.subtype.add("Wolverine");§this.subtype.add("Beast");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new BecomesBlockedTriggeredAbility(new DamageTargetEffect(1), true);§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public KarplusanWolverine(final KarplusanWolverine card) {§super(card);§}§@Override§public KarplusanWolverine copy() {§return new KarplusanWolverine(this);§}§}§
public class PhyrexianSnowcrusher extends CardImpl {§public PhyrexianSnowcrusher(UUID ownerId) {§super(ownerId, 140, "Phyrexian Snowcrusher", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{6}");§this.expansionSetCode = "CSP";§this.supertype.add("Snow");§this.subtype.add("Juggernaut");§this.power = new MageInt(6);§this.toughness = new MageInt(5);§this.addAbility(new AttacksEachTurnStaticAbility());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 0, Duration.EndOfTurn), new ManaCostsImpl("{1}{S}")));§}§public PhyrexianSnowcrusher(final PhyrexianSnowcrusher card) {§super(card);§}§@Override§public PhyrexianSnowcrusher copy() {§return new PhyrexianSnowcrusher(this);§}§}§
public class Sunscour extends CardImpl {§private static final FilterCard filter = new FilterCard("two white cards");§static {§filter.add(new ColorPredicate(ObjectColor.WHITE));§}§public Sunscour(UUID ownerId) {§super(ownerId, 19, "Sunscour", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{5}{W}{W}");§this.expansionSetCode = "CSP";§this.addAbility(new AlternativeCostSourceAbility(new ExileFromHandCost(new TargetCardInHand(2, filter))));§this.getSpellAbility().addEffect(new DestroyAllEffect(new FilterCreaturePermanent()));§}§public Sunscour(final Sunscour card) {§super(card);§}§@Override§public Sunscour copy() {§return new Sunscour(this);§}§}§
public class AnimarSoulOfElements extends CardImpl {§private static final FilterSpell filterSpell = new FilterSpell("a creature spell");§private static final FilterCard filter = new FilterCard("white and from black");§static {§filter.add(Predicates.or(§new ColorPredicate(ObjectColor.WHITE),§new ColorPredicate(ObjectColor.BLACK)));§filterSpell.add(new CardTypePredicate(CardType.CREATURE));§}§public AnimarSoulOfElements(UUID ownerId) {§super(ownerId, 181, "Animar, Soul of Elements", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{U}{R}{G}");§this.expansionSetCode = "CMD";§this.supertype.add("Legendary");§this.subtype.add("Elemental");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new ProtectionAbility(filter));§this.addAbility(new SpellCastControllerTriggeredAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance()), filterSpell, false));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new AnimarCostReductionEffect()));§}§public AnimarSoulOfElements(final AnimarSoulOfElements card) {§super(card);§}§@Override§public AnimarSoulOfElements copy() {§return new AnimarSoulOfElements(this);§}§}§class AnimarCostReductionEffect extends CostModificationEffectImpl {§AnimarCostReductionEffect() {§super(Duration.WhileOnBattlefield, Outcome.Benefit, CostModificationType.REDUCE_COST);§staticText = "Creature spells you cast cost {1} less to cast for each +1/+1 counter on Animar";§}§AnimarCostReductionEffect(AnimarCostReductionEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source, Ability abilityToModify) {§Ability spellAbility = (SpellAbility) abilityToModify;§Permanent sourcePermanent = game.getPermanent(source.getSourceId());§if (sourcePermanent != null && spellAbility != null) {§int amount = sourcePermanent.getCounters().getCount(CounterType.P1P1);§if (amount > 0) {§CardUtil.reduceCost(spellAbility, amount);§return true;§}§}§return false;§}§@Override§public boolean applies(Ability abilityToModify, Ability source, Game game) {§if (abilityToModify instanceof SpellAbility || abilityToModify instanceof FlashbackAbility) {§Card sourceCard = game.getCard(abilityToModify.getSourceId());§if (sourceCard != null && abilityToModify.getControllerId().equals(source.getControllerId()) && (sourceCard.getCardType().contains(CardType.CREATURE))) {§return true;§}§}§return false;§}§@Override§public AnimarCostReductionEffect copy() {§return new AnimarCostReductionEffect(this);§}§}§
public class DuergarHedgeMage extends CardImpl {§private static final FilterLandPermanent filter = new FilterLandPermanent("a Mountain");§private static final FilterLandPermanent filter2 = new FilterLandPermanent("a Plains");§private static final FilterPermanent filter3 = new FilterPermanent("enchantment");§static {§filter.add(new SubtypePredicate("Mountain"));§filter2.add(new SubtypePredicate("Plains"));§filter3.add(new CardTypePredicate(CardType.ENCHANTMENT));§}§private final String rule1 = "When {this} enters the battlefield, if you control two or more Mountains, you may destroy target artifact.";§private final String rule2 = "When {this} enters the battlefield, if you control two or more Plains, you may destroy target enchantment.";§public DuergarHedgeMage(UUID ownerId) {§super(ownerId, 195, "Duergar Hedge-Mage", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{R/W}");§this.expansionSetCode = "CMD";§this.subtype.add("Dwarf");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new ConditionalTriggeredAbility(new EntersBattlefieldTriggeredAbility(new DestroyTargetEffect(), true), new PermanentsOnTheBattlefieldCondition(filter, CountType.MORE_THAN, 1), rule1);§ability.addTarget(new TargetArtifactPermanent());§this.addAbility(ability);§Ability ability2 = new ConditionalTriggeredAbility(new EntersBattlefieldTriggeredAbility(new DestroyTargetEffect(), true), new PermanentsOnTheBattlefieldCondition(filter2, CountType.MORE_THAN, 1), rule2);§ability2.addTarget(new TargetPermanent(filter3));§this.addAbility(ability2);§}§public DuergarHedgeMage(final DuergarHedgeMage card) {§super(card);§}§@Override§public DuergarHedgeMage copy() {§return new DuergarHedgeMage(this);§}§}§
public class MindsAglow extends CardImpl {§public MindsAglow(UUID ownerId) {§super(ownerId, 51, "Minds Aglow", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{U}");§this.expansionSetCode = "CMD";§this.getSpellAbility().addEffect(new MindsAglowEffect());§}§public MindsAglow(final MindsAglow card) {§super(card);§}§@Override§public MindsAglow copy() {§return new MindsAglow(this);§}§}§class MindsAglowEffect extends OneShotEffect {§public MindsAglowEffect() {§super(Outcome.Detriment);§this.staticText = "<i>Join forces</i> - Starting with you, each player may pay any amount of mana. Each player draws X cards, where X is the total amount of mana paid this way";§}§public MindsAglowEffect(final MindsAglowEffect effect) {§super(effect);§}§@Override§public MindsAglowEffect copy() {§return new MindsAglowEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int xSum = 0;§xSum += playerPaysXGenericMana(controller, source, game);§for(UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§if (playerId != controller.getId()) {§Player player = game.getPlayer(playerId);§if (player != null) {§xSum += playerPaysXGenericMana(player, source, game);§}§}§}§if (xSum > 0) {§for(UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§player.drawCards(xSum, game);§}§}§}§controller.resetStoredBookmark(game);§return true;§}§return false;§}§protected static int playerPaysXGenericMana(Player player, Ability source, Game game) {§int xValue = 0;§boolean payed = false;§while (player.canRespond() && !payed) {§xValue = player.announceXMana(0, Integer.MAX_VALUE, "How much mana will you pay?", game, source);§if (xValue > 0) {§Cost cost = new GenericManaCost(xValue);§payed = cost.pay(source, game, source.getSourceId(), player.getId(), false, null);§} else {§payed = true;§}§}§game.informPlayers(new StringBuilder(player.getLogName()).append(" pays {").append(xValue).append("}.").toString());§return xValue;§}§}§
public class Spitebellows extends CardImpl {§public Spitebellows(UUID ownerId) {§super(ownerId, 135, "Spitebellows", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{5}{R}");§this.expansionSetCode = "CMD";§this.subtype.add("Elemental");§this.power = new MageInt(6);§this.toughness = new MageInt(1);§Ability ability = new LeavesBattlefieldTriggeredAbility(new DamageTargetEffect(6), false);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§this.addAbility(new EvokeAbility(this, "{1}{R}{R}"));§}§public Spitebellows(final Spitebellows card) {§super(card);§}§@Override§public Spitebellows copy() {§return new Spitebellows(this);§}§}§
public class VulturousZombie extends CardImpl {§public VulturousZombie(UUID ownerId) {§super(ownerId, 236, "Vulturous Zombie", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{B}{G}");§this.expansionSetCode = "CMD";§this.subtype.add("Plant");§this.subtype.add("Zombie");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new PutCardIntoGraveFromAnywhereAllTriggeredAbility(§new AddCountersSourceEffect(CounterType.P1P1.createInstance()), false, TargetController.OPPONENT));§}§public VulturousZombie(final VulturousZombie card) {§super(card);§}§@Override§public VulturousZombie copy() {§return new VulturousZombie(this);§}§}§
public class CurseOfInertia extends CardImpl {§public CurseOfInertia(UUID ownerId) {§super(ownerId, 36, "Curse of Inertia", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{U}");§this.expansionSetCode = "C13";§this.subtype.add("Aura");§this.subtype.add("Curse");§TargetPlayer auraTarget = new TargetPlayer();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));§this.addAbility(new EnchantAbility(auraTarget.getTargetName()));§this.addAbility(new CurseOfInertiaTriggeredAbility());§}§public CurseOfInertia(final CurseOfInertia card) {§super(card);§}§@Override§public CurseOfInertia copy() {§return new CurseOfInertia(this);§}§}§class CurseOfInertiaTriggeredAbility extends TriggeredAbilityImpl {§public CurseOfInertiaTriggeredAbility() {§super(Zone.BATTLEFIELD, new CurseOfInertiaTapOrUntapTargetEffect(), false);§}§public CurseOfInertiaTriggeredAbility(final CurseOfInertiaTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType().equals(EventType.DECLARED_ATTACKERS);§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent enchantment = game.getPermanent(this.getSourceId());§if (enchantment != null§&& enchantment.getAttachedTo() != null§&& game.getCombat().getPlayerDefenders(game).contains(enchantment.getAttachedTo())) {§TargetPermanent target = new TargetPermanent();§target.setTargetController(game.getCombat().getAttackerId());§addTarget(target);§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever a player attacks enchanted player with one or more creatures, that attacking player may tap or untap target permanent of his or her choice.";§}§@Override§public CurseOfInertiaTriggeredAbility copy() {§return new CurseOfInertiaTriggeredAbility(this);§}§}§class CurseOfInertiaTapOrUntapTargetEffect extends OneShotEffect {§public CurseOfInertiaTapOrUntapTargetEffect() {§super(Outcome.Tap);§staticText = "tap or untap target permanent of his or her choice";§}§public CurseOfInertiaTapOrUntapTargetEffect(final CurseOfInertiaTapOrUntapTargetEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getTargets().get(0).getTargetController());§if (player != null) {§Permanent targetPermanent = game.getPermanent(getTargetPointer().getFirst(game, source));§if (targetPermanent != null) {§if (targetPermanent.isTapped()) {§if (player.chooseUse(Outcome.Untap, "Untap that permanent?", source, game)) {§targetPermanent.untap(game);§}§} else {§if (player.chooseUse(Outcome.Tap, "Tap that permanent?", source, game)) {§targetPermanent.tap(game);§}§}§return true;§}§}§return false;§}§@Override§public CurseOfInertiaTapOrUntapTargetEffect copy() {§return new CurseOfInertiaTapOrUntapTargetEffect(this);§}§}§
public class GahijiHonoredOne extends CardImpl {§public GahijiHonoredOne(UUID ownerId) {§super(ownerId, 191, "Gahiji, Honored One", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{2}{R}{G}{W}");§this.expansionSetCode = "C13";§this.supertype.add("Legendary");§this.subtype.add("Beast");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new GahijiHonoredOneTriggeredAbility());§}§public GahijiHonoredOne(final GahijiHonoredOne card) {§super(card);§}§@Override§public GahijiHonoredOne copy() {§return new GahijiHonoredOne(this);§}§}§class GahijiHonoredOneTriggeredAbility extends TriggeredAbilityImpl {§public GahijiHonoredOneTriggeredAbility() {§super(Zone.BATTLEFIELD, new BoostTargetEffect(2,0, Duration.EndOfTurn), false);§}§public GahijiHonoredOneTriggeredAbility(Effect effect, boolean optional, String text) {§super(Zone.BATTLEFIELD, effect, optional);§}§public GahijiHonoredOneTriggeredAbility(final GahijiHonoredOneTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ATTACKER_DECLARED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Player defender = game.getPlayer(event.getTargetId());§if (defender == null) {§Permanent planeswalker = game.getPermanent(event.getTargetId());§if (planeswalker != null) {§defender = game.getPlayer(planeswalker.getControllerId());§}§}§if (defender != null) {§Set<UUID> opponents = game.getOpponents(this.getControllerId());§if (opponents != null && opponents.contains(defender.getId())) {§for (Effect effect: this.getEffects()) {§effect.setTargetPointer(new FixedTarget(event.getSourceId()));§}§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever a creature attacks one of your opponents or a planeswalker an opponent controls, that creature gets +2/+0 until end of turn.";§}§@Override§public GahijiHonoredOneTriggeredAbility copy() {§return new GahijiHonoredOneTriggeredAbility(this);§}§}§
public class MosswortBridge extends CardImpl {§public MosswortBridge(UUID ownerId) {§super(ownerId, 307, "Mosswort Bridge", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "C13";§this.addAbility(new HideawayAbility());§this.addAbility(new GreenManaAbility());§Ability ability = new ActivateIfConditionActivatedAbility(§Zone.BATTLEFIELD, new HideawayPlayEffect(), new ManaCostsImpl("{G}"), MosswortBridgeTotalPowerCondition.getInstance());§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public MosswortBridge(final MosswortBridge card) {§super(card);§}§@Override§public MosswortBridge copy() {§return new MosswortBridge(this);§}§}§class MosswortBridgeTotalPowerCondition implements Condition {§private static MosswortBridgeTotalPowerCondition fInstance = new MosswortBridgeTotalPowerCondition();§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent();§public static Condition getInstance() {§return fInstance;§}§@Override§public boolean apply(Game game, Ability source) {§int totalPower = 0;§for (Permanent permanent : game.getBattlefield().getAllActivePermanents(filter, source.getControllerId(), game)) {§totalPower += permanent.getPower().getValue();§if (totalPower >= 10) {§return true;§}§}§return false;§}§@Override§public String toString() {§return "creatures you control have total power 10 or greater";§}§}§
public class RubiniaSoulsinger extends CardImpl {§public RubiniaSoulsinger(UUID ownerId) {§super(ownerId, 207, "Rubinia Soulsinger", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{G}{W}{U}");§this.expansionSetCode = "C13";§this.supertype.add("Legendary");§this.subtype.add("Faerie");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(new SkipUntapOptionalAbility());§ConditionalContinuousEffect effect = new ConditionalContinuousEffect(§new GainControlTargetEffect(Duration.OneUse),§new RubiniaSoulsingerCondition(),§"Gain control of target creature for as long as you control Rubinia and Rubinia remains tapped");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public RubiniaSoulsinger(final RubiniaSoulsinger card) {§super(card);§}§@Override§public RubiniaSoulsinger copy() {§return new RubiniaSoulsinger(this);§}§}§class RubiniaSoulsingerCondition implements Condition {§private UUID controllerId;§@Override§public boolean apply(Game game, Ability source) {§if (controllerId == null) {§controllerId = source.getControllerId();§}§Permanent permanent = game.getBattlefield().getPermanent(source.getSourceId());§if (permanent != null) {§if (permanent.isTapped()) {§return controllerId.equals(source.getControllerId());§}§}§return false;§}§}§
public class TemptWithDiscovery extends CardImpl {§public TemptWithDiscovery(UUID ownerId) {§super(ownerId, 174, "Tempt with Discovery", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{G}");§this.expansionSetCode = "C13";§this.getSpellAbility().addEffect(new TemptWithDiscoveryEffect());§}§public TemptWithDiscovery(final TemptWithDiscovery card) {§super(card);§}§@Override§public TemptWithDiscovery copy() {§return new TemptWithDiscovery(this);§}§}§class TemptWithDiscoveryEffect extends OneShotEffect {§public TemptWithDiscoveryEffect() {§super(Outcome.PutLandInPlay);§this.staticText = "<i>Tempting offer</i> - Search your library for a land card and put it onto the battlefield. Each opponent may search his or her library for a land card and put it onto the battlefield. For each opponent who searches a library this way, search your library for a land card and put it onto the battlefield. Then each player who searched a library this way shuffles it";§}§public TemptWithDiscoveryEffect(final TemptWithDiscoveryEffect effect) {§super(effect);§}§@Override§public TemptWithDiscoveryEffect copy() {§return new TemptWithDiscoveryEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Set<UUID> playersShuffle = new LinkedHashSet<>();§playersShuffle.add(controller.getId());§TargetCardInLibrary target = new TargetCardInLibrary(new FilterLandCard());§if (controller.searchLibrary(target, game)) {§for (UUID cardId : target.getTargets()) {§Card card = game.getCard(cardId);§if (card != null) {§controller.moveCards(card, null, Zone.BATTLEFIELD, source, game);§}§}§}§int opponentsUsedSearch = 0;§for (UUID playerId : game.getOpponents(controller.getId())) {§Player opponent = game.getPlayer(playerId);§if (opponent != null) {§if (opponent.chooseUse(outcome, "Search your library for a land card and put it onto the battlefield?", source, game)) {§target.clearChosen();§opponentsUsedSearch++;§playersShuffle.add(playerId);§if (opponent.searchLibrary(target, game)) {§for (UUID cardId : target.getTargets()) {§Card card = game.getCard(cardId);§if (card != null) {§opponent.moveCards(card, null, Zone.BATTLEFIELD, source, game);§}§}§}§}§}§}§if (opponentsUsedSearch > 0) {§target = new TargetCardInLibrary(0, opponentsUsedSearch, new FilterLandCard());§if (controller.searchLibrary(target, game)) {§for (UUID cardId : target.getTargets()) {§Card card = game.getCard(cardId);§if (card != null) {§controller.moveCards(card, null, Zone.BATTLEFIELD, source, game);§}§}§}§}§for (UUID playerId : playersShuffle) {§Player player = game.getPlayer(playerId);§if (player != null) {§player.shuffleLibrary(game);§}§}§return true;§}§return false;§}§}§
public class AngelicFieldMarshal extends CardImpl {§public AngelicFieldMarshal(UUID ownerId) {§super(ownerId, 2, "Angelic Field Marshal", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{W}{W}");§this.expansionSetCode = "C14";§this.subtype.add("Angel");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§ContinuousEffect effect = new GainAbilityControlledEffect(VigilanceAbility.getInstance(), Duration.WhileOnBattlefield, new FilterControlledCreaturePermanent());§effect.setText("and creatures you control have vigilance");§this.addAbility(new LieutenantAbility(effect));§}§public AngelicFieldMarshal(final AngelicFieldMarshal card) {§super(card);§}§@Override§public AngelicFieldMarshal copy() {§return new AngelicFieldMarshal(this);§}§}§
public class DormantVolcano extends CardImpl {§private static final FilterControlledLandPermanent filter = new FilterControlledLandPermanent("an untapped Mountain");§static {§filter.add(new SubtypePredicate("Mountain"));§filter.add(Predicates.not(new TappedPredicate()));§}§public DormantVolcano(UUID ownerId) {§super(ownerId, 291, "Dormant Volcano", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "C14";§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new EntersBattlefieldTriggeredAbility(new SacrificeSourceUnlessPaysEffect(new ReturnToHandChosenControlledPermanentCost(new TargetControlledPermanent(filter)))));§this.addAbility(new SimpleManaAbility(Zone.BATTLEFIELD, new Mana(1, 0, 0, 0, 0, 0, 0, 1), new TapSourceCost()));§}§public DormantVolcano(final DormantVolcano card) {§super(card);§}§@Override§public DormantVolcano copy() {§return new DormantVolcano(this);§}§}§
public class Ixidron extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("face-down creatures on the battlefield");§private static final FilterCreaturePermanent filterTurnFaceDown = new FilterCreaturePermanent("other nontoken creatures");§static {§filter.add(new FaceDownPredicate());§filterTurnFaceDown.add(new AnotherPredicate());§filterTurnFaceDown.add(Predicates.not(new TokenPredicate()));§}§public Ixidron(UUID ownerId) {§super(ownerId, 116, "Ixidron", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{U}{U}");§this.expansionSetCode = "C14";§this.subtype.add("Illusion");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(new EntersBattlefieldAbility(new BecomesFaceDownCreatureAllEffect(filterTurnFaceDown)));§this.addAbility(new SimpleStaticAbility(Zone.ALL, new SetPowerToughnessSourceEffect(new PermanentsOnBattlefieldCount(filter), Duration.EndOfGame)));§}§public Ixidron(final Ixidron card) {§super(card);§}§@Override§public Ixidron copy() {§return new Ixidron(this);§}§}§
public class RiptideSurvivor extends CardImpl {§public RiptideSurvivor(UUID ownerId) {§super(ownerId, 121, "Riptide Survivor", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "C14";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new MorphAbility(this, new ManaCostsImpl("{1}{U}{U}")));§Ability ability = new TurnedFaceUpSourceTriggeredAbility(new DiscardControllerEffect(2));§Effect effect = new DrawCardSourceControllerEffect(3);§effect.setText("then draw three cards");§ability.addEffect(effect);§this.addAbility(ability);§}§public RiptideSurvivor(final RiptideSurvivor card) {§super(card);§}§@Override§public RiptideSurvivor copy() {§return new RiptideSurvivor(this);§}§}§
public class Whirlwind extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creatures with flying");§static {§filter.add(new AbilityPredicate(FlyingAbility.class));§}§public Whirlwind(UUID ownerId) {§super(ownerId, 224, "Whirlwind", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{2}{G}{G}");§this.expansionSetCode = "C14";§this.getSpellAbility().addEffect(new DestroyAllEffect(filter));§}§public Whirlwind(final Whirlwind card) {§super(card);§}§@Override§public Whirlwind copy() {§return new Whirlwind(this);§}§}§
public class CorpseAugur extends CardImpl {§public CorpseAugur(UUID ownerId) {§super(ownerId, 17, "Corpse Augur", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{B}");§this.expansionSetCode = "C15";§this.subtype.add("Zombie");§this.subtype.add("Wizard");§this.power = new MageInt(4);§this.toughness = new MageInt(2);§CardsInTargetPlayersGraveyardCount dynamicValue = new CardsInTargetPlayersGraveyardCount(new FilterCreatureCard("the number of creature cards"));§Effect effect = new DrawCardSourceControllerEffect(dynamicValue);§effect.setText("You draw X cards");§Ability ability = new DiesTriggeredAbility(effect, false);§effect = new LoseLifeSourceControllerEffect(dynamicValue);§effect.setText("and you lose X life, where X is the number of creature cards in target player's graveyard");§ability.addEffect(effect);§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public CorpseAugur(final CorpseAugur card) {§super(card);§}§@Override§public CorpseAugur copy() {§return new CorpseAugur(this);§}§}§
public class MagusOfTheWheel extends CardImpl {§public MagusOfTheWheel(UUID ownerId) {§super(ownerId, 27, "Magus of the Wheel", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "C15";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§Effect effect = new DrawCardAllEffect(7);§effect.setText(", then draws seven cards");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DiscardHandAllEffect(), new ManaCostsImpl("{1}{R}"));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§ability.addEffect(effect);§this.addAbility(ability);§}§public MagusOfTheWheel(final MagusOfTheWheel card) {§super(card);§}§@Override§public MagusOfTheWheel copy() {§return new MagusOfTheWheel(this);§}§}§
public class ThoughtVessel extends CardImpl {§public ThoughtVessel(UUID ownerId) {§super(ownerId, 55, "Thought Vessel", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "C15";§Effect effect = new MaximumHandSizeControllerEffect(Integer.MAX_VALUE, Duration.WhileOnBattlefield, MaximumHandSizeControllerEffect.HandSizeModification.SET);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§this.addAbility(new ColorlessManaAbility());§}§public ThoughtVessel(final ThoughtVessel card) {§super(card);§}§@Override§public ThoughtVessel copy() {§return new ThoughtVessel(this);§}§}§
public class CharnelhoardWurm extends CardImpl {§public CharnelhoardWurm(UUID ownerId) {§super(ownerId, 100, "Charnelhoard Wurm", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{B}{R}{G}");§this.expansionSetCode = "CON";§this.subtype.add("Wurm");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(TrampleAbility.getInstance());§Ability ability = new DealsDamageToOpponentTriggeredAbility(new ReturnFromGraveyardToHandTargetEffect(), true);§ability.addTarget(new TargetCardInYourGraveyard());§this.addAbility(ability);§}§public CharnelhoardWurm(final CharnelhoardWurm card) {§super(card);§}§@Override§public CharnelhoardWurm copy() {§return new CharnelhoardWurm(this);§}§}§
public class EtherswornAdjudicator extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("creature or enchantment");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.CREATURE),§new CardTypePredicate(CardType.ENCHANTMENT)));§}§public EtherswornAdjudicator(UUID ownerId) {§super(ownerId, 26, "Ethersworn Adjudicator", Rarity.MYTHIC, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{4}{U}");§this.expansionSetCode = "CON";§this.subtype.add("Vedalken");§this.subtype.add("Knight");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new ManaCostsImpl("{1}{W}{B}"));§ability.addCost(new TapSourceCost());§Target target = new TargetPermanent(filter);§ability.addTarget(target);§this.addAbility(ability);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new UntapSourceEffect(), new ManaCostsImpl("{2}{U}")));§}§public EtherswornAdjudicator(final EtherswornAdjudicator card) {§super(card);§}§@Override§public EtherswornAdjudicator copy() {§return new EtherswornAdjudicator(this);§}§}§
public class HellsparkElemental extends CardImpl {§public HellsparkElemental(UUID ownerId) {§super(ownerId, 65, "Hellspark Elemental", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "CON";§this.subtype.add("Elemental");§this.power = new MageInt(3);§this.toughness = new MageInt(1);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(HasteAbility.getInstance());§this.addAbility(new OnEventTriggeredAbility(EventType.END_TURN_STEP_PRE, "beginning of the end step", true, new SacrificeSourceEffect()));§this.addAbility(new UnearthAbility(new ManaCostsImpl("{1}{R}")));§}§public HellsparkElemental(final HellsparkElemental card) {§super(card);§}§@Override§public HellsparkElemental copy() {§return new HellsparkElemental(this);§}§}§
public class Meglonoth extends CardImpl {§public Meglonoth(UUID ownerId) {§super(ownerId, 118, "Meglonoth", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{R}{G}{W}");§this.expansionSetCode = "CON";§this.subtype.add("Beast");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new BlocksCreatureTriggeredAbility(new MeglonothEffect(), false, true));§}§public Meglonoth(final Meglonoth card) {§super(card);§}§@Override§public Meglonoth copy() {§return new Meglonoth(this);§}§}§class MeglonothEffect extends OneShotEffect {§public MeglonothEffect() {§super(Outcome.Damage);§this.staticText = "{this} deals damage to that creature's controller equal to {this}'s power";§}§public MeglonothEffect(final MeglonothEffect effect) {§super(effect);§}§@Override§public MeglonothEffect copy() {§return new MeglonothEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent meglonoth = game.getPermanent(source.getSourceId());§Permanent blocked = game.getPermanent(targetPointer.getFirst(game, source));§if (blocked != null && meglonoth != null) {§game.getPlayer(blocked.getControllerId()).damage(meglonoth.getPower().getValue(), id, game, false, true);§return true;§}§return false;§}§}§
public class RhoxBodyguard extends CardImpl {§public RhoxBodyguard(UUID ownerId) {§super(ownerId, 122, "Rhox Bodyguard", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{G}{W}");§this.expansionSetCode = "CON";§this.subtype.add("Rhino");§this.subtype.add("Monk");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(new ExaltedAbility());§this.addAbility(new EntersBattlefieldTriggeredAbility(new GainLifeEffect(3)));§}§public RhoxBodyguard(final RhoxBodyguard card) {§super(card);§}§@Override§public RhoxBodyguard copy() {§return new RhoxBodyguard(this);§}§}§
public class SporeBurst extends CardImpl {§public SporeBurst(UUID ownerId) {§super(ownerId, 93, "Spore Burst", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{3}{G}");§this.expansionSetCode = "CON";§this.getSpellAbility().addEffect(new CreateTokenEffect(new SaprolingToken(), new DomainValue()));§}§public SporeBurst(final SporeBurst card) {§super(card);§}§@Override§public SporeBurst copy() {§return new SporeBurst(this);§}§}§
public class WanderingGoblins extends CardImpl {§public WanderingGoblins(UUID ownerId) {§super(ownerId, 76, "Wandering Goblins", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "CON";§this.subtype.add("Goblin");§this.subtype.add("Warrior");§this.power = new MageInt(0);§this.toughness = new MageInt(3);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(new DomainValue(), new StaticValue(0), Duration.EndOfTurn), new GenericManaCost(3)));§}§public WanderingGoblins(final WanderingGoblins card) {§super(card);§}§@Override§public WanderingGoblins copy() {§return new WanderingGoblins(this);§}§}§
public class GrenzosCutthroat extends CardImpl {§public GrenzosCutthroat(UUID ownerId) {§super(ownerId, 32, "Grenzo's Cutthroat", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "CNS";§this.subtype.add("Goblin");§this.subtype.add("Rogue");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(FirstStrikeAbility.getInstance());§this.addAbility(new DethroneAbility());§}§public GrenzosCutthroat(final GrenzosCutthroat card) {§super(card);§}§@Override§public GrenzosCutthroat copy() {§return new GrenzosCutthroat(this);§}§}§
public class TyrantsChoice extends CardImpl {§public TyrantsChoice(UUID ownerId) {§super(ownerId, 30, "Tyrant's Choice", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{1}{B}");§this.expansionSetCode = "CNS";§this.getSpellAbility().addEffect(new TyrantsChoiceEffect());§}§public TyrantsChoice(final TyrantsChoice card) {§super(card);§}§@Override§public TyrantsChoice copy() {§return new TyrantsChoice(this);§}§}§class TyrantsChoiceEffect extends OneShotEffect {§TyrantsChoiceEffect() {§super(Outcome.Benefit);§this.staticText = "<i>Will of the council</i> - Starting with you, each player votes for death or torture. If death gets more votes, each opponent sacrifices a creature. If torture gets more votes or the vote is tied, each opponent loses 4 life";§}§TyrantsChoiceEffect(final TyrantsChoiceEffect effect) {§super(effect);§}§@Override§public TyrantsChoiceEffect copy() {§return new TyrantsChoiceEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int deathCount = 0;§int tortureCount = 0;§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§if (player.chooseUse(Outcome.Sacrifice, "Choose death?", source, game)) {§deathCount++;§game.informPlayers(player.getLogName() + " has chosen: death");§}§else {§tortureCount++;§game.informPlayers(player.getLogName() + " has chosen: torture");§}§}§}§if (deathCount > tortureCount) {§new SacrificeOpponentsEffect(new FilterControlledCreaturePermanent("a creature")).apply(game, source);§} else {§new TyrantsChoiceLoseLifeEffect().apply(game, source);§}§return true;§}§return false;§}§}§class TyrantsChoiceLoseLifeEffect extends OneShotEffect {§public TyrantsChoiceLoseLifeEffect() {§super(Outcome.Damage);§staticText = "Each opponent loses 2 life";§}§public TyrantsChoiceLoseLifeEffect(final TyrantsChoiceLoseLifeEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§for (UUID opponentId : game.getOpponents(source.getControllerId())) {§game.getPlayer(opponentId).loseLife(4, game);§}§return true;§}§@Override§public TyrantsChoiceLoseLifeEffect copy() {§return new TyrantsChoiceLoseLifeEffect(this);§}§}§
public class BurdenOfGuilt extends CardImpl {§public BurdenOfGuilt(UUID ownerId) {§super(ownerId, 4, "Burden of Guilt", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{W}");§this.expansionSetCode = "DKA";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new TapEnchantedEffect(), new GenericManaCost(1)));§}§public BurdenOfGuilt(final BurdenOfGuilt card) {§super(card);§}§@Override§public BurdenOfGuilt copy() {§return new BurdenOfGuilt(this);§}§}§
public class DiregrafCaptain extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Zombie");§static {§filter.add(new SubtypePredicate("Zombie"));§}§public DiregrafCaptain(UUID ownerId) {§super(ownerId, 135, "Diregraf Captain", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{U}{B}");§this.expansionSetCode = "DKA";§this.subtype.add("Zombie");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(DeathtouchAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostControlledEffect(1, 1, Duration.WhileOnBattlefield, filter, true)));§this.addAbility(new DiregrafCaptainTriggeredAbility());§}§public DiregrafCaptain(final DiregrafCaptain card) {§super(card);§}§@Override§public DiregrafCaptain copy() {§return new DiregrafCaptain(this);§}§}§class DiregrafCaptainTriggeredAbility extends TriggeredAbilityImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Zombie");§static {§filter.add(new SubtypePredicate("Zombie"));§}§public DiregrafCaptainTriggeredAbility() {§super(Zone.BATTLEFIELD, new LoseLifeTargetEffect(1), false);§this.addTarget(new TargetOpponent());§}§public DiregrafCaptainTriggeredAbility(final DiregrafCaptainTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ZONE_CHANGE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (!event.getTargetId().equals(this.getSourceId())) {§ZoneChangeEvent zEvent = (ZoneChangeEvent)event;§if (zEvent.getFromZone() == Zone.BATTLEFIELD && zEvent.getToZone() == Zone.GRAVEYARD) {§Permanent p = (Permanent) game.getLastKnownInformation(event.getTargetId(), Zone.BATTLEFIELD);§if (p != null && p.getControllerId().equals(this.controllerId) && filter.match(p, game)) {§return true;§}§}§}§return false;§}§@Override§public DiregrafCaptainTriggeredAbility copy() {§return new DiregrafCaptainTriggeredAbility(this);§}§@Override§public String getRule() {§return "Whenever another Zombie you control dies, target opponent loses 1 life.";§}§}§
public class GavonyIronwright extends CardImpl {§public GavonyIronwright(UUID ownerId) {§super(ownerId, 9, "Gavony Ironwright", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "DKA";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(1);§this.toughness = new MageInt(4);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(new BoostControlledEffect(1, 4, Duration.WhileOnBattlefield, false),§FatefulHourCondition.getInstance(), "As long as you have 5 or less life, other creatures you control get +1/+4")));§}§public GavonyIronwright(final GavonyIronwright card) {§super(card);§}§@Override§public GavonyIronwright copy() {§return new GavonyIronwright(this);§}§}§
public class Hellrider extends CardImpl {§public Hellrider(UUID ownerId) {§super(ownerId, 93, "Hellrider", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "DKA";§this.subtype.add("Devil");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(HasteAbility.getInstance());§this.addAbility(new HellriderTriggeredAbility());§}§public Hellrider(final Hellrider card) {§super(card);§}§@Override§public Hellrider copy() {§return new Hellrider(this);§}§}§class HellriderTriggeredAbility extends TriggeredAbilityImpl {§public HellriderTriggeredAbility() {§super(Zone.BATTLEFIELD, new DamageTargetEffect(1));§}§public HellriderTriggeredAbility(final HellriderTriggeredAbility ability) {§super(ability);§}§@Override§public HellriderTriggeredAbility copy() {§return new HellriderTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ATTACKER_DECLARED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent source = game.getPermanent(event.getSourceId());§if (source != null && source.getControllerId().equals(controllerId)) {§UUID defendingPlayerId = game.getCombat().getDefendingPlayerId(event.getSourceId(), game);§this.getEffects().get(0).setTargetPointer(new FixedTarget(defendingPlayerId));§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever a creature you control attacks, {this} deals 1 damage to defending player.";§}§}§
public class LostInTheWoods extends CardImpl {§public LostInTheWoods(UUID ownerId) {§super(ownerId, 123, "Lost in the Woods", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{3}{G}{G}");§this.expansionSetCode = "DKA";§this.addAbility(new AttacksAllTriggeredAbility(new LostInTheWoodsEffect(), true, new FilterCreaturePermanent(), SetTargetPointer.PERMANENT, true));§}§public LostInTheWoods(final LostInTheWoods card) {§super(card);§}§@Override§public LostInTheWoods copy() {§return new LostInTheWoods(this);§}§}§class LostInTheWoodsEffect extends OneShotEffect {§public LostInTheWoodsEffect() {§super(Outcome.PreventDamage);§staticText = "reveal the top card of your library. If it's a Forest card, remove that creature from combat. Then put the revealed card on the bottom of your library";§}§public LostInTheWoodsEffect(final LostInTheWoodsEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = game.getObject(source.getSourceId());§if (sourceObject == null || controller == null) {§return false;§}§if (controller.getLibrary().size() > 0) {§Card card = controller.getLibrary().getFromTop(game);§Cards cards = new CardsImpl();§cards.add(card);§controller.revealCards(sourceObject.getName(), cards, game);§if (card != null) {§if (card.getSubtype().contains("Forest")) {§Permanent permanent = game.getPermanent(targetPointer.getFirst(game, source));§if (permanent != null) {§permanent.removeFromCombat(game);§}§}§controller.moveCardToLibraryWithInfo(card, source.getSourceId(), game, Zone.LIBRARY, false, true);§}§}§return true;§}§@Override§public LostInTheWoodsEffect copy() {§return new LostInTheWoodsEffect(this);§}§}§
public class RayOfRevelation extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("enchantment");§static {§filter.add(new CardTypePredicate(CardType.ENCHANTMENT));§}§public RayOfRevelation(UUID ownerId) {§super(ownerId, 17, "Ray of Revelation", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{W}");§this.expansionSetCode = "DKA";§this.getSpellAbility().addTarget(new TargetPermanent(filter));§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.addAbility(new FlashbackAbility(new ManaCostsImpl("{G}"), TimingRule.INSTANT));§}§public RayOfRevelation(final RayOfRevelation card) {§super(card);§}§@Override§public RayOfRevelation copy() {§return new RayOfRevelation(this);§}§}§
public class SorinLordOfInnistrad extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("creature or planeswalker");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.CREATURE),§new CardTypePredicate(CardType.PLANESWALKER)));§}§public SorinLordOfInnistrad(UUID ownerId) {§super(ownerId, 142, "Sorin, Lord of Innistrad", Rarity.MYTHIC, new CardType[]{CardType.PLANESWALKER}, "{2}{W}{B}");§this.expansionSetCode = "DKA";§this.subtype.add("Sorin");§this.addAbility(new PlanswalkerEntersWithLoyalityCountersAbility(3));§this.addAbility(new LoyaltyAbility(new CreateTokenEffect(new VampireToken()), 1));§this.addAbility(new LoyaltyAbility(new GetEmblemEffect(new SorinEmblem()), -2));§LoyaltyAbility ability = new LoyaltyAbility(new SorinLordOfInnistradEffect(), -6);§ability.addTarget(new TargetPermanent(0, 3, filter, false));§this.addAbility(ability);§}§public SorinLordOfInnistrad(final SorinLordOfInnistrad card) {§super(card);§}§@Override§public SorinLordOfInnistrad copy() {§return new SorinLordOfInnistrad(this);§}§}§class VampireToken extends Token {§VampireToken() {§super("Vampire", "a 1/1 black Vampire creature token with lifelink");§cardType.add(CardType.CREATURE);§color.setBlack(true);§subtype.add("Vampire");§power = new MageInt(1);§toughness = new MageInt(1);§addAbility(LifelinkAbility.getInstance());§}§}§class SorinEmblem extends Emblem {§public SorinEmblem() {§this.setName("EMBLEM: Sorin, Lord of Innistrad");§BoostControlledEffect effect = new BoostControlledEffect(1, 0, Duration.EndOfGame);§Ability ability = new SimpleStaticAbility(Zone.COMMAND, effect);§this.getAbilities().add(ability);§}§}§class SorinLordOfInnistradEffect extends OneShotEffect {§public SorinLordOfInnistradEffect() {§super(Outcome.Sacrifice);§this.staticText = "Destroy up to three target creatures and/or other planeswalkers. Return each card put into a graveyard this way to the battlefield under your control";§}§public SorinLordOfInnistradEffect(final SorinLordOfInnistradEffect effect) {§super(effect);§}§@Override§public SorinLordOfInnistradEffect copy() {§return new SorinLordOfInnistradEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§for (UUID targetId : source.getTargets().get(0).getTargets()) {§Permanent perm = game.getPermanent(targetId);§if (perm != null) {§perm.destroy(source.getSourceId(), game, false);§}§}§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§for (UUID targetId : source.getTargets().get(0).getTargets()) {§if (game.getState().getZone(targetId) == Zone.GRAVEYARD) {§Card card = game.getCard(targetId);§if (card != null) {§card.putOntoBattlefield(game, Zone.GRAVEYARD, source.getSourceId(), player.getId());§}§}§}§}§return true;§}§}§
public class VaultOfTheArchangel extends CardImpl {§public VaultOfTheArchangel(UUID ownerId) {§super(ownerId, 158, "Vault of the Archangel", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "DKA";§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new GainAbilityControlledEffect(DeathtouchAbility.getInstance(), Duration.EndOfTurn, new FilterControlledCreaturePermanent("Creatures"), false),§new ManaCostsImpl("{2}{W}{B}"));§ability.addEffect(new GainAbilityControlledEffect(LifelinkAbility.getInstance(), Duration.EndOfTurn, new FilterControlledCreaturePermanent("Creatures"), false));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public VaultOfTheArchangel(final VaultOfTheArchangel card) {§super(card);§}§@Override§public VaultOfTheArchangel copy() {§return new VaultOfTheArchangel(this);§}§}§
public class ArcboundRavager extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("an artifact");§static {§filter.add(new CardTypePredicate(CardType.ARTIFACT));§}§public ArcboundRavager(UUID ownerId) {§super(ownerId, 100, "Arcbound Ravager", Rarity.RARE, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{2}");§this.expansionSetCode = "DST";§this.subtype.add("Beast");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.P1P1.createInstance()), new SacrificeTargetCost(new TargetControlledPermanent(filter))));§this.addAbility(new ModularAbility(this, 1));§}§public ArcboundRavager(final ArcboundRavager card) {§super(card);§}§@Override§public ArcboundRavager copy() {§return new ArcboundRavager(this);§}§}§
public class EaterOfDays extends CardImpl {§public EaterOfDays(UUID ownerId) {§super(ownerId, 120, "Eater of Days", Rarity.RARE, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{4}");§this.expansionSetCode = "DST";§this.subtype.add("Leviathan");§this.power = new MageInt(9);§this.toughness = new MageInt(8);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new SkipNextTurnSourceEffect(2)));§}§public EaterOfDays(final EaterOfDays card) {§super(card);§}§@Override§public EaterOfDays copy() {§return new EaterOfDays(this);§}§}§
public class LeoninBola extends CardImpl {§public LeoninBola(UUID ownerId) {§super(ownerId, 127, "Leonin Bola", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "DST";§this.subtype.add("Equipment");§Ability gainAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TapTargetEffect(), new TapSourceCost());§gainAbility.addCost(new UnattachCost(this.getId()));§gainAbility.addTarget(new TargetCreaturePermanent());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(gainAbility, AttachmentType.EQUIPMENT)));§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(1)));§}§public LeoninBola(final LeoninBola card) {§super(card);§}§@Override§public LeoninBola copy() {§return new LeoninBola(this);§}§}§class UnattachCost extends CostImpl {§private UUID attachmentid;§public UnattachCost(UUID attachmentid) {§this.text = "Unattach Leonin Bola";§this.attachmentid = attachmentid;§}§public UnattachCost(UnattachCost cost) {§super(cost);§this.attachmentid = cost.attachmentid;§}§@Override§public boolean pay(Ability ability, Game game, UUID sourceId, UUID controllerId, boolean noMana, Cost costToPay) {§Permanent permanent = game.getPermanent(sourceId);§if (permanent != null) {§Permanent attachment = game.getPermanent(attachmentid);§if (attachment != null) {§permanent.removeAttachment(attachmentid, game);§this.paid = true;§}§}§return paid;§}§@Override§public boolean canPay(Ability ability, UUID sourceId, UUID controllerId, Game game) {§Permanent permanent = game.getPermanent(sourceId);§if (permanent != null) {§Permanent attachment = game.getPermanent(attachmentid);§if (attachment != null && permanent.getAttachments().contains(attachmentid)) {§return true;§}§}§return false;§}§@Override§public UnattachCost copy() {§return new UnattachCost(this);§}§}§
public class PulseOfTheGrid extends CardImpl {§public PulseOfTheGrid(UUID ownerId) {§super(ownerId, 29, "Pulse of the Grid", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{1}{U}{U}");§this.expansionSetCode = "DST";§this.getSpellAbility().addEffect(new DrawDiscardControllerEffect(2, 1));§this.getSpellAbility().addEffect(new PulseOfTheGridReturnToHandEffect());§}§public PulseOfTheGrid(final PulseOfTheGrid card) {§super(card);§}§@Override§public PulseOfTheGrid copy() {§return new PulseOfTheGrid(this);§}§}§class PulseOfTheGridReturnToHandEffect extends OneShotEffect {§PulseOfTheGridReturnToHandEffect() {§super(Outcome.Benefit);§this.staticText = "Draw two cards, then discard a card. Then if an opponent has more cards in hand than you, return {this} to its owner's hand";§}§PulseOfTheGridReturnToHandEffect(final PulseOfTheGridReturnToHandEffect effect) {§super(effect);§}§@Override§public PulseOfTheGridReturnToHandEffect copy() {§return new PulseOfTheGridReturnToHandEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null && player.getHand().size() > controller.getHand().size()) {§Card card = game.getCard(source.getSourceId());§controller.moveCards(card, null, Zone.HAND, source, game);§return true;§}§}§}§return false;§}§}§
public class SwordOfFireAndIce extends CardImpl {§private static final FilterCard filter = new FilterCard("red and from blue");§static {§filter.add(Predicates.or(§new ColorPredicate(ObjectColor.RED),§new ColorPredicate(ObjectColor.BLUE)));§}§public SwordOfFireAndIce(UUID ownerId) {§super(ownerId, 148, "Sword of Fire and Ice", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "DST";§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(2, 2)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(new ProtectionAbility(filter), AttachmentType.EQUIPMENT)));§this.addAbility(new SwordOfFireAndIceAbility());§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(2)));§}§public SwordOfFireAndIce(final SwordOfFireAndIce card) {§super(card);§}§@Override§public SwordOfFireAndIce copy() {§return new SwordOfFireAndIce(this);§}§}§class SwordOfFireAndIceAbility extends TriggeredAbilityImpl {§public SwordOfFireAndIceAbility() {§super(Zone.BATTLEFIELD, new DamageTargetEffect(2));§this.addEffect(new DrawCardSourceControllerEffect(1));§this.addTarget(new TargetCreatureOrPlayer());§}§public SwordOfFireAndIceAbility(final SwordOfFireAndIceAbility ability) {§super(ability);§}§@Override§public SwordOfFireAndIceAbility copy() {§return new SwordOfFireAndIceAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_PLAYER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§DamagedPlayerEvent damageEvent = (DamagedPlayerEvent) event;§Permanent p = game.getPermanent(event.getSourceId());§return damageEvent.isCombatDamage() && p != null && p.getAttachments().contains(this.getSourceId());§}§@Override§public String getRule() {§return "Whenever equipped creature deals combat damage to a player, {this} deals 2 damage to target creature or player and you draw a card.";§}§}§
public class AvatarOfDiscord extends CardImpl {§public AvatarOfDiscord(UUID ownerId) {§super(ownerId, 140, "Avatar of Discord", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{B/R}{B/R}{B/R}");§this.expansionSetCode = "DIS";§this.subtype.add("Avatar");§this.power = new MageInt(5);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new SacrificeSourceUnlessPaysEffect(new DiscardTargetCost(new TargetCardInHand(2, new FilterCard("two cards"))))));§}§public AvatarOfDiscord(final AvatarOfDiscord card) {§super(card);§}§@Override§public AvatarOfDiscord copy() {§return new AvatarOfDiscord(this);§}§}§
public class Demonfire extends CardImpl {§public Demonfire(UUID ownerId) {§super(ownerId, 60, "Demonfire", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{X}{R}");§this.expansionSetCode = "DIS";§this.getSpellAbility().addEffect(new ConditionalOneShotEffect(§new DamageTargetEffect(new ManacostVariableValue()),§new InvertCondition(HellbentCondition.getInstance()),§"{this} deals X damage to target creature or player"));§this.getSpellAbility().addEffect(new DealtDamageToCreatureBySourceDies(this, Duration.EndOfTurn));§this.getSpellAbility().addWatcher(new DamagedByWatcher());§this.getSpellAbility().addEffect(new ConditionalOneShotEffect(§new DamageTargetEffect(new ManacostVariableValue(), false),§HellbentCondition.getInstance(),§"<br/><i>Hellbent</i> - If you have no cards in hand, {this} can't be countered by spells or abilities and the damage can't be prevented."));§Effect effect = new CantBeCounteredSourceEffect();§effect.setText("");§this.addAbility(new SimpleStaticAbility(Zone.STACK, new ConditionalContinuousRuleModifyingEffect(§(CantBeCounteredSourceEffect) effect,§HellbentCondition.getInstance())));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§}§public Demonfire(final Demonfire card) {§super(card);§}§@Override§public Demonfire copy() {§return new Demonfire(this);§}§}§
public class IndrikStomphowler extends CardImpl {§public IndrikStomphowler(UUID ownerId) {§super(ownerId, 86, "Indrik Stomphowler", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{G}");§this.expansionSetCode = "DIS";§this.subtype.add("Beast");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§Ability ability = new EntersBattlefieldTriggeredAbility(new DestroyTargetEffect(), false);§ability.addTarget(new TargetPermanent(new FilterArtifactOrEnchantmentPermanent()));§this.addAbility(ability);§}§public IndrikStomphowler(final IndrikStomphowler card) {§super(card);§}§@Override§public IndrikStomphowler copy() {§return new IndrikStomphowler(this);§}§}§
public class PlaxcasterFrogling extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("a creature with a +1/+1 counter on it");§static {§filter.add(new CounterPredicate(CounterType.P1P1));§}§public PlaxcasterFrogling(UUID ownerId) {§super(ownerId, 123, "Plaxcaster Frogling", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{G}{U}");§this.expansionSetCode = "DIS";§this.subtype.add("Frog");§this.subtype.add("Mutant");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(new GraftAbility(this, 3));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilityTargetEffect(ShroudAbility.getInstance(), Duration.EndOfTurn), new GenericManaCost(2));§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public PlaxcasterFrogling(final PlaxcasterFrogling card) {§super(card);§}§@Override§public PlaxcasterFrogling copy() {§return new PlaxcasterFrogling(this);§}§}§
public class SealOfDoom extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("nonblack creature");§static {§filter.add(Predicates.not(new ColorPredicate(ObjectColor.BLACK)));§}§public SealOfDoom(UUID ownerId) {§super(ownerId, 53, "Seal of Doom", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{B}");§this.expansionSetCode = "DIS";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(true), new SacrificeSourceCost());§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public SealOfDoom(final SealOfDoom card) {§super(card);§}§@Override§public SealOfDoom copy() {§return new SealOfDoom(this);§}§}§
public class Twinstrike extends CardImpl {§public Twinstrike(UUID ownerId) {§super(ownerId, 134, "Twinstrike", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{3}{B}{R}");§this.expansionSetCode = "DIS";§this.getSpellAbility().addEffect(new ConditionalOneShotEffect(§new DamageTargetEffect(2),§new InvertCondition(HellbentCondition.getInstance()),§"{this} deals 2 damage to each of two target creatures"));§this.getSpellAbility().addEffect(new ConditionalOneShotEffect(§new DestroyTargetEffect(),§HellbentCondition.getInstance(),§"<br/><br/><i>Hellbent</i> - Destroy those creatures instead if you have no cards in hand"));§this.getSpellAbility().addTarget(new TargetCreaturePermanent(2,2));§}§public Twinstrike(final Twinstrike card) {§super(card);§}§@Override§public Twinstrike copy() {§return new Twinstrike(this);§}§}§
public class ArmoredWolfRider extends CardImpl {§public ArmoredWolfRider (UUID ownerId) {§super(ownerId, 52, "Armored Wolf-Rider", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{G}{W}");§this.expansionSetCode = "DGM";§this.subtype.add("Elf");§this.subtype.add("Knight");§this.power = new MageInt(4);§this.toughness = new MageInt(6);§}§public ArmoredWolfRider (final ArmoredWolfRider card) {§super(card);§}§@Override§public ArmoredWolfRider copy() {§return new ArmoredWolfRider(this);§}§}§
public class DeadbridgeChant extends CardImpl {§public DeadbridgeChant(UUID ownerId) {§super(ownerId, 63, "Deadbridge Chant", Rarity.MYTHIC, new CardType[]{CardType.ENCHANTMENT}, "{4}{B}{G}");§this.expansionSetCode = "DGM";§this.addAbility(new EntersBattlefieldTriggeredAbility(new PutTopCardOfLibraryIntoGraveControllerEffect(10)));§this.addAbility(new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new DeadbridgeChantEffect(), TargetController.YOU, false));§}§public DeadbridgeChant(final DeadbridgeChant card) {§super(card);§}§@Override§public DeadbridgeChant copy() {§return new DeadbridgeChant(this);§}§}§class DeadbridgeChantEffect extends OneShotEffect {§public DeadbridgeChantEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "choose a card at random in your graveyard. If it's a creature card, put it onto the battlefield. Otherwise, put it into your hand";§}§public DeadbridgeChantEffect(final DeadbridgeChantEffect effect) {§super(effect);§}§@Override§public DeadbridgeChantEffect copy() {§return new DeadbridgeChantEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null && !player.getGraveyard().isEmpty()) {§Card card = player.getGraveyard().getRandom(game);§if (card != null) {§Zone targetZone = Zone.HAND;§String text = " put into hand of ";§if (card.getCardType().contains(CardType.CREATURE)) {§targetZone = Zone.BATTLEFIELD;§text = " put onto battlefield for ";§}§card.moveToZone(targetZone, source.getSourceId(), game, false);§game.informPlayers(new StringBuilder("Deadbridge Chant: ").append(card.getName()).append(text).append(player.getLogName()).toString());§return true;§}§}§return false;§}§}§
public class IzzetCluestone extends CardImpl {§public IzzetCluestone(UUID ownerId) {§super(ownerId, 141, "Izzet Cluestone", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "DGM";§this.addAbility(new BlueManaAbility());§this.addAbility(new RedManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1), new ManaCostsImpl("{U}{R}"));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public IzzetCluestone(final IzzetCluestone card) {§super(card);§}§@Override§public IzzetCluestone copy() {§return new IzzetCluestone(this);§}§}§
public class MorgueBurst extends CardImpl {§public MorgueBurst(UUID ownerId) {§super(ownerId, 86, "Morgue Burst", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{4}{B}{R}");§this.expansionSetCode = "DGM";§this.getSpellAbility().addEffect(new MorgueBurstEffect());§this.getSpellAbility().addTarget(new TargetCardInYourGraveyard(new FilterCreatureCard("creature card from your graveyard")));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§}§public MorgueBurst(final MorgueBurst card) {§super(card);§}§@Override§public MorgueBurst copy() {§return new MorgueBurst(this);§}§}§class MorgueBurstEffect extends OneShotEffect {§public MorgueBurstEffect() {§super(Outcome.ReturnToHand);§}§public MorgueBurstEffect(final MorgueBurstEffect effect) {§super(effect);§}§@Override§public MorgueBurstEffect copy() {§return new MorgueBurstEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Card card = game.getCard(source.getFirstTarget());§if (card != null) {§Player player = game.getPlayer(card.getOwnerId());§if (player != null) {§player.moveCards(card, null, Zone.HAND, source, game);§int damage = card.getPower().getValue();§Permanent creature = game.getPermanent(source.getTargets().get(1).getTargets().get(0));§if (creature != null) {§creature.damage(damage, source.getSourceId(), game, false, true);§return true;§}§Player targetPlayer = game.getPlayer(source.getTargets().get(1).getTargets().get(0));§if (targetPlayer != null) {§targetPlayer.damage(damage, source.getSourceId(), game, false, true);§return true;§}§}§}§return false;§}§@Override§public String getText(Mode mode) {§StringBuilder sb = new StringBuilder();§sb.append("Return target creature card from your graveyard to your hand. Morgue Burst deals damage to target creature or player equal to the power of the card returned this way");§return sb.toString();§}§}§
public class RenderSilent extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("multicolored permanent");§static {§filter.add(new MulticoloredPredicate());§}§public RenderSilent(UUID ownerId) {§super(ownerId, 96, "Render Silent", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{W}{U}{U}");§this.expansionSetCode = "DGM";§this.getSpellAbility().addEffect(new RenderSilentCounterEffect());§this.getSpellAbility().addTarget(new TargetSpell());§this.getSpellAbility().addEffect(new RenderSilentEffect());§}§public RenderSilent(final RenderSilent card) {§super(card);§}§@Override§public RenderSilent copy() {§return new RenderSilent(this);§}§}§class RenderSilentCounterEffect extends OneShotEffect {§public RenderSilentCounterEffect() {§super(Outcome.Detriment);§}§public RenderSilentCounterEffect(final RenderSilentCounterEffect effect) {§super(effect);§}§@Override§public RenderSilentCounterEffect copy() {§return new RenderSilentCounterEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Spell spell = game.getStack().getSpell(source.getFirstTarget());§if (spell != null) {§source.getEffects().get(1).setTargetPointer(new FixedTarget(spell.getControllerId()));§return game.getStack().counter(source.getFirstTarget(), source.getSourceId(), game);§}§return false;§}§@Override§public String getText(Mode mode) {§return "Counter target " + mode.getTargets().get(0).getTargetName();§}§}§class RenderSilentEffect extends ContinuousRuleModifyingEffectImpl {§public RenderSilentEffect() {§super(Duration.EndOfTurn, Outcome.Benefit);§staticText = "Its controller can't cast spells this turn";§}§public RenderSilentEffect(final RenderSilentEffect effect) {§super(effect);§}§@Override§public RenderSilentEffect copy() {§return new RenderSilentEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public String getInfoMessage(Ability source, GameEvent event, Game game) {§MageObject mageObject = game.getObject(source.getSourceId());§if (mageObject != null) {§return "You can't cast spells this turn (" + mageObject.getIdName() + ").";§}§return null;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.CAST_SPELL;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§Player player = game.getPlayer(getTargetPointer().getFirst(game, source));§if (player != null && player.getId().equals(event.getPlayerId())) {§return true;§}§return false;§}§}§
public class Skylasher extends CardImpl {§private static final FilterCard filter = new FilterCard("blue");§static {§filter.add(new ColorPredicate(ObjectColor.BLUE));§}§public Skylasher (UUID ownerId) {§super(ownerId, 49, "Skylasher", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "DGM";§this.subtype.add("Insect");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlashAbility.getInstance());§this.addAbility(new CantBeCounteredAbility());§this.addAbility(ReachAbility.getInstance());§this.addAbility(new ProtectionAbility(filter));§}§public Skylasher (final Skylasher card) {§super(card);§}§@Override§public Skylasher copy() {§return new Skylasher(this);§}§}§
public class WarpedPhysique extends CardImpl {§public WarpedPhysique(UUID ownerId) {§super(ownerId, 117, "Warped Physique", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{U}{B}");§this.expansionSetCode = "DGM";§DynamicValue xValue = new CardsInControllerHandCount();§this.getSpellAbility().addEffect(new BoostTargetEffect(xValue, new SignInversionDynamicValue(xValue), Duration.EndOfTurn, true));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public WarpedPhysique(final WarpedPhysique card) {§super(card);§}§@Override§public WarpedPhysique copy() {§return new WarpedPhysique(this);§}§}§
public class AtarkaMonument extends CardImpl {§public AtarkaMonument(UUID ownerId) {§super(ownerId, 235, "Atarka Monument", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "DTK";§this.addAbility(new RedManaAbility());§this.addAbility(new GreenManaAbility());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BecomesCreatureSourceEffect§(new AtarkaMonumentToken(), "", Duration.EndOfTurn), new ManaCostsImpl("{4}{R}{G}")));§}§public AtarkaMonument(final AtarkaMonument card) {§super(card);§}§@Override§public AtarkaMonument copy() {§return new AtarkaMonument(this);§}§private class AtarkaMonumentToken extends Token {§AtarkaMonumentToken() {§super("", "a 4/4 red and green Dragon artifact creature with flying");§cardType.add(CardType.ARTIFACT);§cardType.add(CardType.CREATURE);§color.setRed(true);§color.setGreen(true);§this.subtype.add("Dragon");§power = new MageInt(4);§toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§}§}§}§
public class CommuneWithLava extends CardImpl {§public CommuneWithLava(UUID ownerId) {§super(ownerId, 131, "Commune with Lava", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{X}{R}{R}");§this.expansionSetCode = "DTK";§this.getSpellAbility().addEffect(new CommuneWithLavaEffect());§}§public CommuneWithLava(final CommuneWithLava card) {§super(card);§}§@Override§public CommuneWithLava copy() {§return new CommuneWithLava(this);§}§}§class CommuneWithLavaEffect extends OneShotEffect {§public CommuneWithLavaEffect() {§super(Outcome.PlayForFree);§this.staticText = "Exile the top X cards of your library. Until the end of your next turn, you may play those cards";§}§public CommuneWithLavaEffect(final CommuneWithLavaEffect effect) {§super(effect);§}§@Override§public CommuneWithLavaEffect copy() {§return new CommuneWithLavaEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Card sourceCard = game.getCard(source.getSourceId());§if (controller != null) {§int amount = source.getManaCostsToPay().getX();§Set<Card> cards = controller.getLibrary().getTopCards(game, amount);§controller.moveCardsToExile(cards, source, game, true, CardUtil.getCardExileZoneId(game, source), sourceCard.getIdName());§for (Card card : cards) {§ContinuousEffect effect = new CommuneWithLavaMayPlayEffect();§effect.setTargetPointer(new FixedTarget(card.getId()));§game.addEffect(effect, source);§}§return true;§}§return false;§}§}§class CommuneWithLavaMayPlayEffect extends AsThoughEffectImpl {§int castOnTurn = 0;§public CommuneWithLavaMayPlayEffect() {§super(AsThoughEffectType.PLAY_FROM_NOT_OWN_HAND_ZONE, Duration.Custom, Outcome.Benefit);§this.staticText = "Until the end of your next turn, you may play that card.";§}§public CommuneWithLavaMayPlayEffect(final CommuneWithLavaMayPlayEffect effect) {§super(effect);§castOnTurn = effect.castOnTurn;§}§@Override§public CommuneWithLavaMayPlayEffect copy() {§return new CommuneWithLavaMayPlayEffect(this);§}§@Override§public void init(Ability source, Game game) {§super.init(source, game);§castOnTurn = game.getTurnNum();§}§@Override§public boolean isInactive(Ability source, Game game) {§if (castOnTurn != game.getTurnNum() && game.getPhase().getStep().getType() == PhaseStep.END_TURN) {§if (game.getActivePlayerId().equals(source.getControllerId())) {§return true;§}§}§return false;§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean applies(UUID sourceId, Ability source, UUID affectedControllerId, Game game) {§return source.getControllerId().equals(affectedControllerId)§&& getTargetPointer().getTargets(game, source).contains(sourceId);§}§}§
public class DragonlordAtarka extends CardImpl {§private static final FilterCreatureOrPlaneswalkerPermanent filter = new FilterCreatureOrPlaneswalkerPermanent("creatures and/or planeswalkers your opponents control");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public DragonlordAtarka(UUID ownerId) {§super(ownerId, 216, "Dragonlord Atarka", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{5}{R}{G}");§this.expansionSetCode = "DTK";§this.supertype.add("Legendary");§this.subtype.add("Elder");§this.subtype.add("Dragon");§this.power = new MageInt(8);§this.toughness = new MageInt(8);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(TrampleAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new DamageMultiEffect(5), false);§ability.addTarget(new TargetCreatureOrPlaneswalkerAmount(5, filter));§this.addAbility(ability);§}§public DragonlordAtarka(final DragonlordAtarka card) {§super(card);§}§@Override§public DragonlordAtarka copy() {§return new DragonlordAtarka(this);§}§}§
public class EncaseInIce extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("red or green creature");§static {§filter.add(Predicates.or(§new ColorPredicate(ObjectColor.RED),§new ColorPredicate(ObjectColor.GREEN)));§}§public EncaseInIce(UUID ownerId) {§super(ownerId, 54, "Encase in Ice", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{U}");§this.expansionSetCode = "DTK";§this.subtype.add("Aura");§this.addAbility(FlashAbility.getInstance());§TargetPermanent auraTarget = new TargetCreaturePermanent(filter);§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));§this.addAbility(new EnchantAbility(auraTarget.getTargetName()));§this.addAbility(new EntersBattlefieldTriggeredAbility(new TapEnchantedEffect()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new DontUntapInControllersUntapStepEnchantedEffect()));§}§public EncaseInIce(final EncaseInIce card) {§super(card);§}§@Override§public EncaseInIce copy() {§return new EncaseInIce(this);§}§}§
public class HandOfSilumgar extends CardImpl {§public HandOfSilumgar(UUID ownerId) {§super(ownerId, 105, "Hand of Silumgar", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "DTK";§this.subtype.add("Human");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(DeathtouchAbility.getInstance());§}§public HandOfSilumgar(final HandOfSilumgar card) {§super(card);§}§@Override§public HandOfSilumgar copy() {§return new HandOfSilumgar(this);§}§}§
public class LearnFromThePast extends CardImpl {§public LearnFromThePast(UUID ownerId) {§super(ownerId, 60, "Learn from the Past", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{3}{U}");§this.expansionSetCode = "DTK";§this.getSpellAbility().addEffect(new LearnFromThePastEffect());§this.getSpellAbility().addTarget(new TargetPlayer());§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));§}§public LearnFromThePast(final LearnFromThePast card) {§super(card);§}§@Override§public LearnFromThePast copy() {§return new LearnFromThePast(this);§}§}§class LearnFromThePastEffect extends OneShotEffect {§LearnFromThePastEffect() {§super(Outcome.Neutral);§this.staticText = "Target player shuffles his or her graveyard into his or her library";§}§LearnFromThePastEffect(final LearnFromThePastEffect effect) {§super(effect);§}§@Override§public LearnFromThePastEffect copy() {§return new LearnFromThePastEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(this.getTargetPointer().getFirst(game, source));§if (player != null) {§for (Card card: player.getGraveyard().getCards(game)) {§player.moveCardToLibraryWithInfo(card, source.getSourceId(), game, Zone.GRAVEYARD, true, true);§}§player.shuffleLibrary(game);§return true;§}§return false;§}§}§
public class OjutaiMonument extends CardImpl {§public OjutaiMonument(UUID ownerId) {§super(ownerId, 242, "Ojutai Monument", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "DTK";§this.addAbility(new WhiteManaAbility());§this.addAbility(new BlueManaAbility());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BecomesCreatureSourceEffect§(new OjutaiMonumentToken(), "", Duration.EndOfTurn), new ManaCostsImpl("{4}{W}{U}")));§}§public OjutaiMonument(final OjutaiMonument card) {§super(card);§}§@Override§public OjutaiMonument copy() {§return new OjutaiMonument(this);§}§private class OjutaiMonumentToken extends Token {§OjutaiMonumentToken() {§super("", "a 4/4 white and blue Dragon artifact creature with flying");§cardType.add(CardType.ARTIFACT);§cardType.add(CardType.CREATURE);§color.setWhite(true);§color.setBlue(true);§this.subtype.add("Dragon");§power = new MageInt(4);§toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§}§}§}§
public class Resupply extends CardImpl {§public Resupply(UUID ownerId) {§super(ownerId, 32, "Resupply", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{5}{W}");§this.expansionSetCode = "DTK";§this.getSpellAbility().addEffect(new GainLifeEffect(6));§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));§}§public Resupply(final Resupply card) {§super(card);§}§@Override§public Resupply copy() {§return new Resupply(this);§}§}§
public class SeismicRupture extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature without flying");§static {§filter.add(Predicates.not(new AbilityPredicate(FlyingAbility.class)));§}§public SeismicRupture(UUID ownerId) {§super(ownerId, 156, "Seismic Rupture", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{2}{R}");§this.expansionSetCode = "DTK";§this.getSpellAbility().addEffect(new DamageAllEffect(2, filter));§}§public SeismicRupture(final SeismicRupture card) {§super(card);§}§@Override§public SeismicRupture copy() {§return new SeismicRupture(this);§}§}§
public class SilumgarSpellEater extends CardImpl {§public SilumgarSpellEater(UUID ownerId) {§super(ownerId, 77, "Silumgar Spell-Eater", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "DTK";§this.subtype.add("Naga");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(new MorphAbility(this, new ManaCostsImpl("{4}{U}"), true));§Ability ability = new TurnedFaceUpSourceTriggeredAbility(new CounterUnlessPaysEffect(new GenericManaCost(3)), false, false);§ability.addTarget(new TargetSpell());§this.addAbility(ability);§}§public SilumgarSpellEater(final SilumgarSpellEater card) {§super(card);§}§@Override§public SilumgarSpellEater copy() {§return new SilumgarSpellEater(this);§}§}§
public class TreadUpon extends CardImpl {§public TreadUpon(UUID ownerId) {§super(ownerId, 211, "Tread Upon", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{G}");§this.expansionSetCode = "DTK";§Effect effect = new BoostTargetEffect(2, 2, Duration.EndOfTurn);§effect.setText("Target creature gets +2/+2");§this.getSpellAbility().addEffect(effect);§effect = new GainAbilityTargetEffect(TrampleAbility.getInstance(), Duration.EndOfTurn);§effect.setText("and gains trample until end of turn");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public TreadUpon(final TreadUpon card) {§super(card);§}§@Override§public TreadUpon copy() {§return new TreadUpon(this);§}§}§
public class DistortingLens extends CardImpl {§public DistortingLens(UUID ownerId) {§super(ownerId, 299, "Distorting Lens", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "8ED";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ChangeColorEffect(), new TapSourceCost());§ability.addTarget(new TargetPermanent());§this.addAbility(ability);§}§public DistortingLens(final DistortingLens card) {§super(card);§}§@Override§public DistortingLens copy() {§return new DistortingLens(this);§}§}§class ChangeColorEffect extends OneShotEffect {§public ChangeColorEffect() {§super(Outcome.Neutral);§staticText = "Target permanent becomes the color of your choice until end of turn";§}§public ChangeColorEffect(final ChangeColorEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§Permanent permanent = game.getPermanent(source.getSourceId());§Permanent chosen = game.getPermanent(targetPointer.getFirst(game, source));§if (player != null && permanent != null) {§ContinuousEffect effect = new BecomesColorTargetEffect(null, Duration.EndOfTurn);§effect.setTargetPointer(new FixedTarget(chosen.getId()));§game.addEffect(effect, source);§return true;§}§return false;§}§@Override§public ChangeColorEffect copy() {§return new ChangeColorEffect(this);§}§}§
public class BlindingBeam extends CardImpl {§public BlindingBeam(UUID ownerId) {§super(ownerId, 28, "Blinding Beam", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{W}");§this.expansionSetCode = "DDF";§this.getSpellAbility().getModes().setMinModes(1);§this.getSpellAbility().getModes().setMaxModes(1);§this.getSpellAbility().addEffect(new TapTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent(2,2));§Mode mode = new Mode();§mode.getEffects().add(new BlindingBeamEffect());§mode.getTargets().add(new TargetPlayer());§this.getSpellAbility().getModes().addMode(mode);§this.addAbility(new EntwineAbility("{1}"));§}§public BlindingBeam(final BlindingBeam card) {§super(card);§}§@Override§public BlindingBeam copy() {§return new BlindingBeam(this);§}§}§class BlindingBeamEffect extends OneShotEffect {§public BlindingBeamEffect() {§super(Outcome.Tap);§staticText = "creatures don't untap during target player's next untap step";§}§public BlindingBeamEffect(final BlindingBeamEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(getTargetPointer().getFirst(game, source));§if (player != null) {§game.addEffect(new BlindingBeamEffect2(player.getId()), source);§return true;§}§return false;§}§@Override§public BlindingBeamEffect copy() {§return new BlindingBeamEffect(this);§}§}§class BlindingBeamEffect2 extends ContinuousRuleModifyingEffectImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent();§private final UUID targetPlayerId;§public BlindingBeamEffect2(UUID targetPlayerId) {§super(Duration.Custom, Outcome.Detriment);§this.targetPlayerId = targetPlayerId;§}§public BlindingBeamEffect2(final BlindingBeamEffect2 effect) {§super(effect);§this.targetPlayerId = effect.targetPlayerId;§}§@Override§public BlindingBeamEffect2 copy() {§return new BlindingBeamEffect2(this);§}§@Override§public boolean apply(Game game, Ability source) {§return false;§}§@Override§public boolean isInactive(Ability source, Game game) {§if (game.getPhase().getStep().getType() == PhaseStep.UNTAP && game.getStep().getStepPart() == Step.StepPart.PRE) {§if (game.getActivePlayerId().equals(targetPlayerId) || game.getPlayer(source.getControllerId()).hasReachedNextTurnAfterLeaving()) {§return true;§}§}§return false;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType().equals(EventType.UNTAP);§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (game.getTurn().getStepType().equals(PhaseStep.UNTAP)) {§Permanent permanent = game.getPermanent(event.getTargetId());§if (permanent != null && permanent.getControllerId().equals(targetPlayerId) && filter.match(permanent, game)) {§return true;§}§}§return false;§}§}§
public class SwellOfCourage extends CardImpl {§public SwellOfCourage(UUID ownerId) {§super(ownerId, 31, "Swell of Courage", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{3}{W}{W}");§this.expansionSetCode = "DDF";§this.getSpellAbility().addEffect(new BoostControlledEffect(2,2, Duration.EndOfTurn));§this.addAbility(new ReinforceAbility(new ManacostVariableValue(), new ManaCostsImpl("{X}{W}{W}")));§}§public SwellOfCourage(final SwellOfCourage card) {§super(card);§}§@Override§public SwellOfCourage copy() {§return new SwellOfCourage(this);§}§}§
public class AshlingTheExtinguisher extends CardImpl {§public AshlingTheExtinguisher(UUID ownerId) {§super(ownerId, 33, "Ashling, the Extinguisher", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{B}{B}");§this.expansionSetCode = "EVE";§this.supertype.add("Legendary");§this.subtype.add("Elemental");§this.subtype.add("Shaman");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new AshlingTheExtinguisherTriggeredAbility());§}§public AshlingTheExtinguisher(final AshlingTheExtinguisher card) {§super(card);§}§@Override§public AshlingTheExtinguisher copy() {§return new AshlingTheExtinguisher(this);§}§}§class AshlingTheExtinguisherTriggeredAbility extends TriggeredAbilityImpl {§public AshlingTheExtinguisherTriggeredAbility() {§super(Zone.BATTLEFIELD, new SacrificeTargetEffect());§this.addTarget(new TargetCreaturePermanent());§}§public AshlingTheExtinguisherTriggeredAbility(final AshlingTheExtinguisherTriggeredAbility ability) {§super(ability);§}§@Override§public AshlingTheExtinguisherTriggeredAbility copy() {§return new AshlingTheExtinguisherTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_PLAYER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§DamagedPlayerEvent damageEvent = (DamagedPlayerEvent) event;§if (damageEvent.isCombatDamage() && event.getSourceId().equals(this.getSourceId())) {§Player opponent = game.getPlayer(event.getPlayerId());§if (opponent != null) {§FilterCreaturePermanent filter = new FilterCreaturePermanent("creature " + opponent.getLogName() + " controls");§filter.add(new ControllerIdPredicate(opponent.getId()));§this.getTargets().clear();§this.addTarget(new TargetCreaturePermanent(filter));§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever {this} deals combat damage to a player, choose target creature that player controls. He or she sacrifices that creature.";§}§}§
public class Crackleburr extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("two untapped red creatures you control");§private static final FilterControlledCreaturePermanent filter2 = new FilterControlledCreaturePermanent("two tapped blue creatures you control");§static {§filter.add(new ColorPredicate(ObjectColor.RED));§filter.add(Predicates.not(new TappedPredicate()));§filter2.add(new ColorPredicate(ObjectColor.BLUE));§filter2.add(new TappedPredicate());§}§public Crackleburr(UUID ownerId) {§super(ownerId, 100, "Crackleburr", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{U/R}{U/R}");§this.expansionSetCode = "EVE";§this.subtype.add("Elemental");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(3), new ManaCostsImpl("{U/R}{U/R}"));§ability.addCost(new TapSourceCost());§ability.addCost(new TapTargetCost(new TargetControlledCreaturePermanent(2, 2, filter, true)));§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§Ability ability2 = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ReturnToHandTargetEffect(), new ManaCostsImpl("{U/R}{U/R}"));§ability2.addCost(new UntapSourceCost());§ability2.addCost(new UntapTargetCost(new TargetControlledCreaturePermanent(2, 2, filter2, true)));§ability2.addTarget(new TargetCreaturePermanent());§this.addAbility(ability2);§}§public Crackleburr(final Crackleburr card) {§super(card);§}§@Override§public Crackleburr copy() {§return new Crackleburr(this);§}§}§
public class Evershrike extends CardImpl {§public Evershrike(UUID ownerId) {§super(ownerId, 88, "Evershrike", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{W/B}{W/B}");§this.expansionSetCode = "EVE";§this.subtype.add("Elemental");§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§AuraAttachedCount amount = new AuraAttachedCount(2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostSourceEffect(amount, amount, Duration.WhileOnBattlefield)));§this.addAbility(new SimpleActivatedAbility(Zone.GRAVEYARD, new EvershrikeEffect(), new ManaCostsImpl("{X}{W/B}{W/B}")));§}§public Evershrike(final Evershrike card) {§super(card);§}§@Override§public Evershrike copy() {§return new Evershrike(this);§}§}§class EvershrikeEffect extends OneShotEffect {§public EvershrikeEffect() {§super(Outcome.Benefit);§staticText = "Return {this} from your graveyard to the battlefield. You may put an Aura card with converted mana cost X or less from your hand onto the battlefield attached to it. If you don't, exile {this}";§}§public EvershrikeEffect(final EvershrikeEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§boolean exiled = true;§Card evershrikeCard = game.getCard(source.getSourceId());§Player controller = game.getPlayer(source.getControllerId());§int xAmount = source.getManaCostsToPay().getX() + 1;§if (evershrikeCard != null) {§if (evershrikeCard.moveToZone(Zone.BATTLEFIELD, source.getSourceId(), game, false)) {§Permanent evershrikePermanent = game.getPermanent(source.getSourceId());§if (evershrikePermanent == null) {§return false;§}§FilterCard filterAuraCard = new FilterCard("Aura card with converted mana cost X or less from your hand");§filterAuraCard.add(new CardTypePredicate(CardType.ENCHANTMENT));§filterAuraCard.add(new SubtypePredicate("Aura"));§filterAuraCard.add(new AuraCardCanAttachToPermanentId(evershrikePermanent.getId()));§filterAuraCard.add(new ConvertedManaCostPredicate(ComparisonType.LessThan, xAmount));§int count = controller.getHand().count(filterAuraCard, game);§while (controller.canRespond() && count > 0 && controller.chooseUse(Outcome.Benefit, "Do you wish to put an Aura card from your hand onto Evershrike", source, game)) {§TargetCard targetAura = new TargetCard(Zone.HAND, filterAuraCard);§if (controller.choose(Outcome.Benefit, controller.getHand(), targetAura, game)) {§Card aura = game.getCard(targetAura.getFirstTarget());§if (aura != null) {§game.getState().setValue("attachTo:" + aura.getId(), evershrikePermanent);§aura.putOntoBattlefield(game, Zone.HAND, source.getSourceId(), controller.getId());§evershrikePermanent.addAttachment(aura.getId(), game);§exiled = false;§count = controller.getHand().count(filterAuraCard, game);§}§}§}§if (exiled) {§return evershrikePermanent.moveToExile(source.getSourceId(), "Evershrike Exile", source.getSourceId(), game);§}§return true;§}§}§return false;§}§@Override§public EvershrikeEffect copy() {§return new EvershrikeEffect(this);§}§}§
public class Hateflayer extends CardImpl {§public Hateflayer(UUID ownerId) {§super(ownerId, 55, "Hateflayer", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{R}{R}");§this.expansionSetCode = "EVE";§this.subtype.add("Elemental");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(WitherAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(new SourcePermanentPowerCount()), new ManaCostsImpl("{2}{R}"));§ability.addCost(new UntapSourceCost());§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public Hateflayer(final Hateflayer card) {§super(card);§}§@Override§public Hateflayer copy() {§return new Hateflayer(this);§}§}§
public class MarshdrinkerGiant extends CardImpl {§private static final FilterLandPermanent filter = new FilterLandPermanent("Island or Swamp an opponent controls");§static {§filter.add(Predicates.or(§new SubtypePredicate("Island"),§new SubtypePredicate("Swamp")));§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public MarshdrinkerGiant(UUID ownerId) {§super(ownerId, 69, "Marshdrinker Giant", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{G}{G}");§this.expansionSetCode = "EVE";§this.subtype.add("Giant");§this.subtype.add("Warrior");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§Ability ability = new EntersBattlefieldTriggeredAbility(new DestroyTargetEffect(), false);§ability.addTarget(new TargetLandPermanent(filter));§this.addAbility(ability);§}§public MarshdrinkerGiant(final MarshdrinkerGiant card) {§super(card);§}§@Override§public MarshdrinkerGiant copy() {§return new MarshdrinkerGiant(this);§}§}§
public class OonasGrace extends CardImpl {§public OonasGrace(UUID ownerId) {§super(ownerId, 27, "Oona's Grace", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{U}");§this.expansionSetCode = "EVE";§this.getSpellAbility().addEffect(new DrawCardTargetEffect(1));§this.getSpellAbility().addTarget(new TargetPlayer());§this.addAbility(new RetraceAbility(this));§}§public OonasGrace(final OonasGrace card) {§super(card);§}§@Override§public OonasGrace copy() {§return new OonasGrace(this);§}§}§
public class SaplingOfColfenor extends CardImpl {§public SaplingOfColfenor(UUID ownerId) {§super(ownerId, 128, "Sapling of Colfenor", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{B/G}{B/G}");§this.expansionSetCode = "EVE";§this.supertype.add("Legendary");§this.subtype.add("Treefolk");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(5);§this.addAbility(IndestructibleAbility.getInstance());§this.addAbility(new AttacksTriggeredAbility(new SaplingOfColfenorEffect(), false));§}§public SaplingOfColfenor(final SaplingOfColfenor card) {§super(card);§}§@Override§public SaplingOfColfenor copy() {§return new SaplingOfColfenor(this);§}§}§class SaplingOfColfenorEffect extends OneShotEffect {§public SaplingOfColfenorEffect() {§super(Outcome.Benefit);§this.staticText = "reveal the top card of your library. If it's a creature card, you gain life equal to that card's toughness, lose life equal to its power, then put it into your hand";§}§public SaplingOfColfenorEffect(final SaplingOfColfenorEffect effect) {§super(effect);§}§@Override§public SaplingOfColfenorEffect copy() {§return new SaplingOfColfenorEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = source.getSourceObject(game);§if (controller != null && sourceObject != null) {§if (controller.getLibrary().size() > 0) {§Card card = controller.getLibrary().getFromTop(game);§Cards cards = new CardsImpl(card);§controller.revealCards(sourceObject.getIdName(), cards, game);§if (card.getCardType().contains(CardType.CREATURE)) {§controller.gainLife(card.getToughness().getValue(), game);§controller.loseLife(card.getPower().getValue(), game);§return controller.moveCards(cards.getCards(game), Zone.HAND, source, game);§}§}§return true;§}§return false;§}§}§
public class StillmoonCavalier extends CardImpl {§private static final FilterCard filter = new FilterCard("white and from black");§static {§filter.add(Predicates.or(§new ColorPredicate(ObjectColor.WHITE),§new ColorPredicate(ObjectColor.BLACK)));§}§public StillmoonCavalier(UUID ownerId) {§super(ownerId, 95, "Stillmoon Cavalier", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{W/B}{W/B}");§this.expansionSetCode = "EVE";§this.subtype.add("Zombie");§this.subtype.add("Knight");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new ProtectionAbility(filter));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(FlyingAbility.getInstance(), Duration.EndOfTurn), new ManaCostsImpl("{W/B}")));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn), new ManaCostsImpl("{W/B}")));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1,0, Duration.EndOfTurn), new ManaCostsImpl("{W/B}{W/B}")));§}§public StillmoonCavalier(final StillmoonCavalier card) {§super(card);§}§@Override§public StillmoonCavalier copy() {§return new StillmoonCavalier(this);§}§}§
public class WardOfBones extends CardImpl {§public WardOfBones(UUID ownerId) {§super(ownerId, 174, "Ward of Bones", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{6}");§this.expansionSetCode = "EVE";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new WardOfBonesEffect()));§}§public WardOfBones(final WardOfBones card) {§super(card);§}§@Override§public WardOfBones copy() {§return new WardOfBones(this);§}§}§class WardOfBonesEffect extends ContinuousRuleModifyingEffectImpl {§public WardOfBonesEffect() {§super(Duration.WhileOnBattlefield, Outcome.Benefit);§staticText = "Each opponent who controls more creatures than you can't play creature cards. The same is true for artifacts, enchantments, and lands";§}§public WardOfBonesEffect(final WardOfBonesEffect effect) {§super(effect);§}§@Override§public WardOfBonesEffect copy() {§return new WardOfBonesEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public String getInfoMessage(Ability source, GameEvent event, Game game) {§MageObject mageObject = game.getObject(source.getSourceId());§if (mageObject != null) {§return "You can't play the land or cast the spell (" + mageObject.getLogName() + " in play).";§}§return null;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.PLAY_LAND || event.getType() == GameEvent.EventType.CAST_SPELL;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (game.getOpponents(source.getControllerId()).contains(event.getPlayerId())) {§final Card card = game.getCard(event.getSourceId());§final Player opponent = game.getPlayer(event.getPlayerId());§if (card == null || opponent == null) {§return false;§}§if (card.getCardType().contains(CardType.CREATURE)§&& game.getBattlefield().countAll(new FilterCreaturePermanent(), opponent.getId(), game)§> game.getBattlefield().countAll(new FilterCreaturePermanent(), source.getControllerId(), game)) {§return true;§}§if (card.getCardType().contains(CardType.ARTIFACT)§&& game.getBattlefield().countAll(new FilterArtifactPermanent(), opponent.getId(), game)§> game.getBattlefield().countAll(new FilterArtifactPermanent(), source.getControllerId(), game)) {§return true;§}§if (card.getCardType().contains(CardType.ENCHANTMENT)§&& game.getBattlefield().countAll(new FilterEnchantmentPermanent(), opponent.getId(), game)§> game.getBattlefield().countAll(new FilterEnchantmentPermanent(), source.getControllerId(), game)) {§return true;§}§final int yourLands = game.getBattlefield().countAll(new FilterLandPermanent(), source.getControllerId(), game);§if (card.getCardType().contains(CardType.LAND)§&& game.getBattlefield().countAll(new FilterLandPermanent(), opponent.getId(), game) > yourLands) {§return true;§}§}§return false;§}§}§
public class Equilibrium extends CardImpl {§private static final FilterSpell filter = new FilterSpell("a creature spell");§static {§filter.add(new CardTypePredicate(CardType.CREATURE));§}§public Equilibrium(UUID ownerId) {§super(ownerId, 32, "Equilibrium", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{1}{U}{U}");§this.expansionSetCode = "EXO";§Ability ability = new SpellCastControllerTriggeredAbility(new DoIfCostPaid(new ReturnToHandTargetEffect(), new GenericManaCost(1)), filter, false);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public Equilibrium(final Equilibrium card) {§super(card);§}§@Override§public Equilibrium copy() {§return new Equilibrium(this);§}§}§
public class Onslaught extends CardImpl {§private static final FilterSpell filter = new FilterSpell("a creature spell");§static {§filter.add(new CardTypePredicate(CardType.CREATURE));§}§public Onslaught(UUID ownerId) {§super(ownerId, 92, "Onslaught", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{R}");§this.expansionSetCode = "EXO";§Ability ability = new SpellCastControllerTriggeredAbility(new TapTargetEffect(), filter, false);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public Onslaught(final Onslaught card) {§super(card);§}§@Override§public Onslaught copy() {§return new Onslaught(this);§}§}§
public class SphereOfResistance extends CardImpl {§public SphereOfResistance(UUID ownerId) {§super(ownerId, 139, "Sphere of Resistance", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "EXO";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new SpellsCostIncreasementAllEffect(1)));§}§public SphereOfResistance(final SphereOfResistance card) {§super(card);§}§@Override§public SphereOfResistance copy() {§return new SphereOfResistance(this);§}§}§
public class DwarvenLieutenant extends CardImpl {§static FilterCreaturePermanent filter = new FilterCreaturePermanent("Dwarf creature");§static {§filter.add(new SubtypePredicate("Dwarf"));§}§public DwarvenLieutenant(UUID ownerId) {§super(ownerId, 106, "Dwarven Lieutenant", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{R}{R}");§this.expansionSetCode = "FEM";§this.subtype.add("Dwarf");§this.subtype.add("Soldier");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(1, 0, Duration.EndOfTurn), new ManaCostsImpl("{1}{R}"));§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public DwarvenLieutenant(final DwarvenLieutenant card) {§super(card);§}§@Override§public DwarvenLieutenant copy() {§return new DwarvenLieutenant(this);§}§}§
public class IcatianLieutenant extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Soldier creature");§static {§filter.add(new SubtypePredicate("Soldier"));§}§public IcatianLieutenant(UUID ownerId) {§super(ownerId, 151, "Icatian Lieutenant", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{W}{W}");§this.expansionSetCode = "FEM";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(1, 0, Duration.EndOfTurn), new ManaCostsImpl("{1}{W}"));§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public IcatianLieutenant(final IcatianLieutenant card) {§super(card);§}§@Override§public IcatianLieutenant copy() {§return new IcatianLieutenant(this);§}§}§
public class AbzanAdvantage extends CardImpl {§public AbzanAdvantage(UUID ownerId) {§super(ownerId, 2, "Abzan Advantage", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{W}");§this.expansionSetCode = "FRF";§this.getSpellAbility().addEffect(new SacrificeEffect(new FilterEnchantmentPermanent(), 1, "Target player"));§this.getSpellAbility().addEffect(new BolsterEffect(1));§this.getSpellAbility().addTarget(new TargetPlayer());§}§public AbzanAdvantage(final AbzanAdvantage card) {§super(card);§}§@Override§public AbzanAdvantage copy() {§return new AbzanAdvantage(this);§}§}§
public class BattlefrontKrushok extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("creature you control with a +1/+1 counter on it");§static {§filter.add(new CounterPredicate(CounterType.P1P1));§}§public BattlefrontKrushok(UUID ownerId) {§super(ownerId, 125, "Battlefront Krushok", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{G}");§this.expansionSetCode = "FRF";§this.subtype.add("Beast");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CantBeBlockedByMoreThanOneSourceEffect()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CantBeBlockedByMoreThanOneAllEffect(filter)));§}§public BattlefrontKrushok(final BattlefrontKrushok card) {§super(card);§}§@Override§public BattlefrontKrushok copy() {§return new BattlefrontKrushok(this);§}§}§
public class DromokaTheEternal extends CardImpl {§public DromokaTheEternal(UUID ownerId) {§super(ownerId, 151, "Dromoka, the Eternal", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{G}{W}");§this.expansionSetCode = "FRF";§this.supertype.add("Legendary");§this.subtype.add("Dragon");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new AttacksCreatureYouControlTriggeredAbility(§new BolsterEffect(2), false, new FilterControlledCreaturePermanent("Dragon", "Dragon you control")));§}§public DromokaTheEternal(final DromokaTheEternal card) {§super(card);§}§@Override§public DromokaTheEternal copy() {§return new DromokaTheEternal(this);§}§}§
public class GraveStrength extends CardImpl {§public GraveStrength(UUID ownerId) {§super(ownerId, 71, "Grave Strength", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{1}{B}");§this.expansionSetCode = "FRF";§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§Effect effect = new PutTopCardOfLibraryIntoGraveControllerEffect(3);§effect.setText("Choose target creature. Put the top three cards of your library into your graveyard");§this.getSpellAbility().addEffect(effect);§effect = new AddCountersTargetEffect(CounterType.P1P1.createInstance(0), new CardsInControllerGraveyardCount(new FilterCreatureCard()));§effect.setText(", then put a +1/+1 counter on that creature for each creature card in your graveyard");§this.getSpellAbility().addEffect(effect);§}§public GraveStrength(final GraveStrength card) {§super(card);§}§@Override§public GraveStrength copy() {§return new GraveStrength(this);§}§}§
public class MapTheWastes extends CardImpl {§public MapTheWastes(UUID ownerId) {§super(ownerId, 134, "Map the Wastes", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{G}");§this.expansionSetCode = "FRF";§TargetCardInLibrary target = new TargetCardInLibrary(new FilterBasicLandCard());§this.getSpellAbility().addEffect(new SearchLibraryPutInPlayEffect(target, true));§this.getSpellAbility().addEffect(new BolsterEffect(1));§}§public MapTheWastes(final MapTheWastes card) {§super(card);§}§@Override§public MapTheWastes copy() {§return new MapTheWastes(this);§}§}§
public class PilgrimOfTheFires extends CardImpl {§public PilgrimOfTheFires(UUID ownerId) {§super(ownerId, 162, "Pilgrim of the Fires", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{7}");§this.expansionSetCode = "FRF";§this.subtype.add("Golem");§this.power = new MageInt(6);§this.toughness = new MageInt(4);§this.addAbility(FirstStrikeAbility.getInstance());§this.addAbility(TrampleAbility.getInstance());§}§public PilgrimOfTheFires(final PilgrimOfTheFires card) {§super(card);§}§@Override§public PilgrimOfTheFires copy() {§return new PilgrimOfTheFires(this);§}§}§
public class ShamanOfTheGreatHunt extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("creature you control with power 4 or greater");§static {§filter.add(new PowerPredicate(Filter.ComparisonType.GreaterThan, 3));§}§public ShamanOfTheGreatHunt(UUID ownerId) {§super(ownerId, 113, "Shaman of the Great Hunt", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "FRF";§this.subtype.add("Orc");§this.subtype.add("Shaman");§this.power = new MageInt(4);§this.toughness = new MageInt(2);§this.addAbility(HasteAbility.getInstance());§Effect effect = new AddCountersTargetEffect(CounterType.P1P1.createInstance());§effect.setText("put a +1/+1 counter on that creature");§this.addAbility(new DealsDamageToAPlayerAllTriggeredAbility(§effect,§new FilterControlledCreaturePermanent("a creature you control"), false, SetTargetPointer.PERMANENT, true§));§DynamicValue amount = new PermanentsOnBattlefieldCount(filter);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(amount), new ManaCostsImpl("{2}{G/U}{G/U}"));§ability.setAbilityWord(AbilityWord.FEROCIOUS);§this.addAbility(ability);§}§public ShamanOfTheGreatHunt(final ShamanOfTheGreatHunt card) {§super(card);§}§@Override§public ShamanOfTheGreatHunt copy() {§return new ShamanOfTheGreatHunt(this);§}§}§
public class TemurRunemark extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("as long as you control a blue or red permanent");§static {§filter.add(Predicates.or(new ColorPredicate(ObjectColor.RED), new ColorPredicate(ObjectColor.BLUE)));§}§public TemurRunemark(UUID ownerId) {§super(ownerId, 140, "Temur Runemark", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{G}");§this.expansionSetCode = "FRF";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(2, 2, Duration.WhileOnBattlefield)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD,§new ConditionalContinuousEffect(new GainAbilityAttachedEffect(TrampleAbility.getInstance(), AttachmentType.AURA),§new PermanentsOnTheBattlefieldCondition(filter), "{this} has trample as long as you control a blue or red permanent")));§}§public TemurRunemark(final TemurRunemark card) {§super(card);§}§@Override§public TemurRunemark copy() {§return new TemurRunemark(this);§}§}§
public class YasovaDragonclaw extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature an opponent controls with power less than Yasova Dragonclaw's power");§static {§filter.add(new YasovaDragonclawPowerLessThanSourcePredicate());§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public YasovaDragonclaw(UUID ownerId) {§super(ownerId, 148, "Yasova Dragonclaw", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "FRF";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Warrior");§this.power = new MageInt(4);§this.toughness = new MageInt(2);§this.addAbility(TrampleAbility.getInstance());§DoIfCostPaid effect = new DoIfCostPaid(new GainControlTargetEffect(Duration.EndOfTurn, true), new ManaCostsImpl("{1}{U/R}{U/R}"));§Effect effect2 = new UntapTargetEffect();§effect2.setText(", untap that creature");§effect.addEffect(effect2);§effect.addEffect(new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.EndOfTurn, ", and it gains haste until end of turn"));§Ability ability = new BeginningOfCombatTriggeredAbility(effect, TargetController.YOU, false);§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public YasovaDragonclaw(final YasovaDragonclaw card) {§super(card);§}§@Override§public YasovaDragonclaw copy() {§return new YasovaDragonclaw(this);§}§}§class YasovaDragonclawPowerLessThanSourcePredicate implements ObjectSourcePlayerPredicate<ObjectSourcePlayer<Permanent>> {§@Override§public boolean apply(ObjectSourcePlayer<Permanent> input, Game game) {§Permanent sourcePermanent = game.getPermanent(input.getSourceId());§return sourcePermanent != null && input.getObject().getPower().getValue() < sourcePermanent.getPower().getValue();§}§@Override§public String toString() {§return "power less than Yasova Dragonclaw's power";§}§}§
public class BringerOfTheGreenDawn extends CardImpl {§public BringerOfTheGreenDawn(UUID ownerId) {§super(ownerId, 83, "Bringer of the Green Dawn", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{7}{G}{G}");§this.expansionSetCode = "5DN";§this.subtype.add("Bringer");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(new AlternativeCostSourceAbility(new ManaCostsImpl("{W}{U}{B}{R}{G}")));§this.addAbility(TrampleAbility.getInstance());§Ability ability = new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new CreateTokenEffect(new BeastToken()), TargetController.YOU, true);§this.addAbility(ability);§}§public BringerOfTheGreenDawn(final BringerOfTheGreenDawn card) {§super(card);§}§@Override§public BringerOfTheGreenDawn copy() {§return new BringerOfTheGreenDawn(this);§}§}§
public class EternalWitness extends CardImpl {§public EternalWitness(UUID ownerId) {§super(ownerId, 86, "Eternal Witness", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{G}{G}");§this.expansionSetCode = "5DN";§this.subtype.add("Human");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Ability ability = new EntersBattlefieldTriggeredAbility(new ReturnFromGraveyardToHandTargetEffect(), true);§ability.addTarget(new TargetCardInYourGraveyard());§this.addAbility(ability);§}§public EternalWitness(final EternalWitness card) {§super(card);§}§@Override§public EternalWitness copy() {§return new EternalWitness(this);§}§}§
public class HornedHelm extends CardImpl {§public HornedHelm(UUID ownerId) {§super(ownerId, 132, "Horned Helm", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "5DN";§this.subtype.add("Equipment");§Effect effect = new BoostEquippedEffect(1, 1);§effect.setText("Equipped creature gets +1/+1");§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, effect);§effect = new GainAbilityAttachedEffect(TrampleAbility.getInstance(), AttachmentType.EQUIPMENT);§effect.setText("and has trample");§ability.addEffect(effect);§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AttachEffect(Outcome.BoostCreature, "Attach {this} to target creature you control"), new ManaCostsImpl("{G}{G}"));§ability.addTarget(new TargetControlledCreaturePermanent());§this.addAbility(ability);§this.addAbility(new EquipAbility(Outcome.BoostCreature, new GenericManaCost(1)));§}§public HornedHelm(final HornedHelm card) {§super(card);§}§@Override§public HornedHelm copy() {§return new HornedHelm(this);§}§}§
public class MyrQuadropod extends CardImpl {§public MyrQuadropod(UUID ownerId) {§super(ownerId, 138, "Myr Quadropod", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{4}");§this.expansionSetCode = "5DN";§this.subtype.add("Myr");§this.power = new MageInt(1);§this.toughness = new MageInt(4);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new SwitchPowerToughnessSourceEffect(Duration.EndOfTurn), new ManaCostsImpl("{3}")));§}§public MyrQuadropod(final MyrQuadropod card) {§super(card);§}§@Override§public MyrQuadropod copy() {§return new MyrQuadropod(this);§}§}§
public class SerumVisions extends CardImpl {§public SerumVisions(UUID ownerId) {§super(ownerId, 36, "Serum Visions", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{U}");§this.expansionSetCode = "5DN";§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));§this.getSpellAbility().addEffect(new ScryEffect(2));§}§public SerumVisions(final SerumVisions card) {§super(card);§}§@Override§public SerumVisions copy() {§return new SerumVisions(this);§}§}§
public class Tyrranax extends CardImpl {§public Tyrranax(UUID ownerId) {§super(ownerId, 98, "Tyrranax", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{G}{G}");§this.expansionSetCode = "5DN";§this.subtype.add("Beast");§this.power = new MageInt(5);§this.toughness = new MageInt(4);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(-1, 1, Duration.EndOfTurn), new ManaCostsImpl("{1}{G}")));§}§public Tyrranax(final Tyrranax card) {§super(card);§}§@Override§public Tyrranax copy() {§return new Tyrranax(this);§}§}§
public class Blight extends CardImpl {§public Blight(UUID ownerId) {§super(ownerId, 6, "Blight", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{B}{B}");§this.expansionSetCode = "5ED";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetLandPermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new BecomesTappedAttachedTriggeredAbility(new DestroyAttachedEffect("it"), "enchanted land"));§}§public Blight(final Blight card) {§super(card);§}§@Override§public Blight copy() {§return new Blight(this);§}§}§
public class FerozsBan extends CardImpl {§public FerozsBan(UUID ownerId) {§super(ownerId, 370, "Feroz's Ban", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{6}");§this.expansionSetCode = "5ED";§Effect effect = new SpellsCostIncreasementAllEffect(new FilterCreatureCard(), 2);§effect.setText("Creature spells cost {2} more to cast.");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§}§public FerozsBan(final FerozsBan card) {§super(card);§}§@Override§public FerozsBan copy() {§return new FerozsBan(this);§}§}§
public class LivingArtifact extends CardImpl {§public LivingArtifact(UUID ownerId) {§super(ownerId, 173, "Living Artifact", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{G}");§this.expansionSetCode = "5ED";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetArtifactPermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Benefit));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new LivingArtifactTriggeredAbility());§this.addAbility(new ConditionalTriggeredAbility(new BeginningOfUpkeepTriggeredAbility(new DoIfCostPaid(new GainLifeEffect(1),§new RemoveCountersSourceCost(CounterType.VITALITY.createInstance(1))), TargetController.YOU, false),§new SourceHasCounterCondition(CounterType.VITALITY, 1), "At the beginning of your upkeep, you may remove a vitality counter from {this}. If you do, you gain 1 life"));§}§public LivingArtifact(final LivingArtifact card) {§super(card);§}§@Override§public LivingArtifact copy() {§return new LivingArtifact(this);§}§}§class LivingArtifactTriggeredAbility extends TriggeredAbilityImpl {§public LivingArtifactTriggeredAbility() {§super(Zone.BATTLEFIELD, new LivingArtifactEffect(), false);§}§public LivingArtifactTriggeredAbility(final LivingArtifactTriggeredAbility ability) {§super(ability);§}§@Override§public LivingArtifactTriggeredAbility copy() {§return new LivingArtifactTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_PLAYER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getTargetId().equals(this.getControllerId())) {§this.getEffects().get(0).setValue("damageAmount", event.getAmount());§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever you're dealt damage, put that many charge counters on {this}.";§}§}§class LivingArtifactEffect extends OneShotEffect {§public LivingArtifactEffect() {§super(Outcome.Benefit);§}§public LivingArtifactEffect(final LivingArtifactEffect effect) {§super(effect);§}§@Override§public LivingArtifactEffect copy() {§return new LivingArtifactEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return new AddCountersSourceEffect(CounterType.VITALITY.createInstance((Integer) this.getValue("damageAmount"))).apply(game, source);§}§}§
public class RepentantBlacksmith extends CardImpl {§private static final FilterCard protectionFilter = new FilterCard("red");§static {§protectionFilter.add(new ColorPredicate(ObjectColor.RED));§}§public RepentantBlacksmith(UUID ownerId) {§super(ownerId, 330, "Repentant Blacksmith", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "5ED";§this.subtype.add("Human");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(new ProtectionAbility(protectionFilter));§}§public RepentantBlacksmith(final RepentantBlacksmith card) {§super(card);§}§@Override§public RepentantBlacksmith copy() {§return new RepentantBlacksmith(this);§}§}§
public class WarMammoth extends CardImpl {§public WarMammoth(UUID ownerId) {§super(ownerId, 202, "War Mammoth", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "5ED";§this.subtype.add("Elephant");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(TrampleAbility.getInstance());§}§public WarMammoth(final WarMammoth card) {§super(card);§}§@Override§public WarMammoth copy() {§return new WarMammoth(this);§}§}§
public class Immolation extends CardImpl {§public Immolation(UUID ownerId) {§super(ownerId, 222, "Immolation", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{R}");§this.expansionSetCode = "4ED";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(2, -2)));§}§public Immolation(final Immolation card) {§super(card);§}§@Override§public Immolation copy() {§return new Immolation(this);§}§}§
public class ArcanumWings extends CardImpl {§public ArcanumWings(UUID ownerId) {§super(ownerId, 48, "Arcanum Wings", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{U}");§this.expansionSetCode = "FUT";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(FlyingAbility.getInstance(), AttachmentType.AURA)));§this.addAbility(new AuraSwapAbility(new ManaCostsImpl("{2}{U}")));§}§public ArcanumWings(final ArcanumWings card) {§super(card);§}§@Override§public ArcanumWings copy() {§return new ArcanumWings(this);§}§}§
public class CyclicalEvolution extends CardImpl {§public CyclicalEvolution(UUID ownerId) {§super(ownerId, 125, "Cyclical Evolution", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{3}{G}{G}");§this.expansionSetCode = "FUT";§getSpellAbility().addEffect(new BoostTargetEffect(3, 3, Duration.EndOfTurn));§getSpellAbility().addTarget(new TargetCreaturePermanent());§getSpellAbility().addEffect(ExileSpellEffect.getInstance());§Effect effect = new AddCountersSourceEffect(CounterType.TIME.createInstance(), new StaticValue(3), true, true);§effect.setText("with 3 time counters on it");§getSpellAbility().addEffect(effect);§this.addAbility(new SuspendAbility(3, new ManaCostsImpl<>("{2}{G}"), this));§}§public CyclicalEvolution(final CyclicalEvolution card) {§super(card);§}§@Override§public CyclicalEvolution copy() {§return new CyclicalEvolution(this);§}§}§
public class HenchfiendOfUkor extends CardImpl {§public HenchfiendOfUkor(UUID ownerId) {§super(ownerId, 117, "Henchfiend of Ukor", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "FUT";§this.subtype.add("Ogre");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(HasteAbility.getInstance());§this.addAbility(new EchoAbility("{1}{B}"));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 0, Duration.EndOfTurn), new ManaCostsImpl("{B/R}")));§}§public HenchfiendOfUkor(final HenchfiendOfUkor card) {§super(card);§}§@Override§public HenchfiendOfUkor copy() {§return new HenchfiendOfUkor(this);§}§}§
public class MagusOfTheMoat extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Creatures without flying");§static {§filter.add(Predicates.not(new AbilityPredicate(FlyingAbility.class)));§}§public MagusOfTheMoat(UUID ownerId) {§super(ownerId, 12, "Magus of the Moat", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{W}{W}");§this.expansionSetCode = "FUT";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(0);§this.toughness = new MageInt(3);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CantAttackAnyPlayerAllEffect(Duration.WhileOnBattlefield, filter)));§}§public MagusOfTheMoat(final MagusOfTheMoat card) {§super(card);§}§@Override§public MagusOfTheMoat copy() {§return new MagusOfTheMoat(this);§}§}§
public class Saltskitter extends CardImpl {§private static final FilterPermanent filter = new FilterCreaturePermanent("another creature");§static {§filter.add(new AnotherPredicate());§}§public Saltskitter(UUID ownerId) {§super(ownerId, 14, "Saltskitter", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "FUT";§this.subtype.add("Wurm");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§this.addAbility(new EntersBattlefieldAllTriggeredAbility(new ExileReturnBattlefieldOwnerNextEndStepSourceEffect(true), filter));§}§public Saltskitter(final Saltskitter card) {§super(card);§}§@Override§public Saltskitter copy() {§return new Saltskitter(this);§}§}§
public class ThornwealdArcher extends CardImpl {§public ThornwealdArcher(UUID ownerId) {§super(ownerId, 154, "Thornweald Archer", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "FUT";§this.subtype.add("Elf");§this.subtype.add("Archer");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(ReachAbility.getInstance());§this.addAbility(DeathtouchAbility.getInstance());§}§public ThornwealdArcher(final ThornwealdArcher card) {§super(card);§}§@Override§public ThornwealdArcher copy() {§return new ThornwealdArcher(this);§}§}§
public class AngelicEdict extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("creature or enchantment");§static {§filter.add(Predicates.or(new CardTypePredicate(CardType.CREATURE), new CardTypePredicate(CardType.ENCHANTMENT)));§}§public AngelicEdict(UUID ownerId) {§super(ownerId, 2, "Angelic Edict", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{4}{W}");§this.expansionSetCode = "GTC";§getSpellAbility().addEffect(new ExileTargetEffect());§getSpellAbility().addTarget(new TargetPermanent(filter));§}§public AngelicEdict(final AngelicEdict card) {§super(card);§}§@Override§public AngelicEdict copy() {§return new AngelicEdict(this);§}§}§
public class BorosKeyrune extends CardImpl {§public BorosKeyrune(UUID ownerId) {§super(ownerId, 227, "Boros Keyrune", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "GTC";§this.addAbility(new RedManaAbility());§this.addAbility(new WhiteManaAbility());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BecomesCreatureSourceEffect(new BorosKeyruneToken(), "", Duration.EndOfTurn), new ManaCostsImpl("{R}{W}")));§}§public BorosKeyrune(final BorosKeyrune card) {§super(card);§}§@Override§public BorosKeyrune copy() {§return new BorosKeyrune(this);§}§private class BorosKeyruneToken extends Token {§BorosKeyruneToken() {§super("Soldier", "1/1 red and white Soldier artifact creature with double strike");§cardType.add(CardType.ARTIFACT);§cardType.add(CardType.CREATURE);§color.setRed(true);§color.setWhite(true);§subtype.add("Soldier");§power = new MageInt(1);§toughness = new MageInt(1);§this.addAbility(DoubleStrikeAbility.getInstance());§}§}§}§
public class DeathpactAngel extends CardImpl {§public DeathpactAngel(UUID ownerId) {§super(ownerId, 153, "Deathpact Angel", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{3}{W}{B}{B}");§this.expansionSetCode = "GTC";§this.subtype.add("Angel");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new DiesTriggeredAbility(new CreateTokenEffect(new DeathpactAngelToken())));§}§public DeathpactAngel(final DeathpactAngel card) {§super(card);§}§@Override§public DeathpactAngel copy() {§return new DeathpactAngel(this);§}§}§class DeathpactAngelToken extends Token {§private static final FilterCreatureCard filter = new FilterCreatureCard("card named Deathpact Angel from your graveyard");§static {§filter.add(new NamePredicate("Deathpact Angel"));§}§public DeathpactAngelToken() {§super("Cleric", "1/1 white and black Cleric creature token onto the battlefield. It has \"{3}{W}{B}{B}, {T}, Sacrifice this creature: Return a card named Deathpact Angel from your graveyard to the battlefield.\"");§cardType.add(CardType.CREATURE);§color.setWhite(true);§color.setBlack(true);§subtype.add("Cleric");§power = new MageInt(1);§toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ReturnFromGraveyardToBattlefieldTargetEffect(), new ManaCostsImpl("{3}{W}{B}{B}"));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetCardInYourGraveyard(filter));§this.addAbility(ability);§}§}§
public class ExperimentOne extends CardImpl {§public ExperimentOne(UUID ownerId) {§super(ownerId, 119, "Experiment One", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "GTC";§this.subtype.add("Human");§this.subtype.add("Ooze");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new EvolveAbility());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new RemoveCountersSourceCost(CounterType.P1P1.createInstance(2))));§}§public ExperimentOne(final ExperimentOne card) {§super(card);§}§@Override§public ExperimentOne copy() {§return new ExperimentOne(this);§}§}§
public class GrislySpectacle extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("nonartifact creature");§static {§filter.add(Predicates.not(new CardTypePredicate(CardType.ARTIFACT)));§}§public GrislySpectacle(UUID ownerId) {§super(ownerId, 66, "Grisly Spectacle", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{B}{B}");§this.expansionSetCode = "GTC";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addEffect(new GrislySpectacleEffect());§this.getSpellAbility().addTarget(new TargetPermanent(filter));§}§public GrislySpectacle(final GrislySpectacle card) {§super(card);§}§@Override§public GrislySpectacle copy() {§return new GrislySpectacle(this);§}§}§class GrislySpectacleEffect extends OneShotEffect {§public GrislySpectacleEffect() {§super(Outcome.DestroyPermanent);§this.staticText = "Its controller puts a number of cards equal to that creature's power from the top of his or her library into his or her graveyard";§}§public GrislySpectacleEffect(final GrislySpectacleEffect effect) {§super(effect);§}§@Override§public GrislySpectacleEffect copy() {§return new GrislySpectacleEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent creature = game.getPermanentOrLKIBattlefield(this.getTargetPointer().getFirst(game, source));§if (creature != null) {§Player controller = game.getPlayer(creature.getControllerId());§if (controller != null) {§int power = creature.getPower().getValue();§Effect effect = new PutLibraryIntoGraveTargetEffect(power);§effect.setTargetPointer(new FixedTarget(controller.getId()));§return effect.apply(game, source);§}§}§return false;§}§}§
public class IllnessInTheRanks extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Creature tokens");§static {§filter.add(new TokenPredicate());§}§public IllnessInTheRanks(UUID ownerId) {§super(ownerId, 69, "Illness in the Ranks", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{B}");§this.expansionSetCode = "GTC";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostAllEffect(-1,-1, Duration.WhileOnBattlefield, filter, false)));§}§public IllnessInTheRanks(final IllnessInTheRanks card) {§super(card);§}§@Override§public IllnessInTheRanks copy() {§return new IllnessInTheRanks(this);§}§}§
public class MasterBiomancer extends CardImpl {§public MasterBiomancer(UUID ownerId) {§super(ownerId, 176, "Master Biomancer", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{2}{G}{U}");§this.expansionSetCode = "GTC";§this.subtype.add("Elf");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(4);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new MasterBiomancerEntersBattlefieldEffect()));§}§public MasterBiomancer(final MasterBiomancer card) {§super(card);§}§@Override§public MasterBiomancer copy() {§return new MasterBiomancer(this);§}§}§class MasterBiomancerEntersBattlefieldEffect extends ReplacementEffectImpl {§public MasterBiomancerEntersBattlefieldEffect() {§super(Duration.WhileOnBattlefield, Outcome.BoostCreature);§staticText = "Each other creature you control enters the battlefield with a number of additional +1/+1 counters on it equal to Master Biomancer's power and as a Mutant in addition to its other types";§}§public MasterBiomancerEntersBattlefieldEffect(MasterBiomancerEntersBattlefieldEffect effect) {§super(effect);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == EventType.ENTERS_THE_BATTLEFIELD;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§Permanent creature = ((EntersTheBattlefieldEvent) event).getTarget();§return creature != null && creature.getControllerId().equals(source.getControllerId())§&& creature.getCardType().contains(CardType.CREATURE)§&& !event.getTargetId().equals(source.getSourceId());§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§Permanent sourceCreature = game.getPermanent(source.getSourceId());§Permanent creature = ((EntersTheBattlefieldEvent) event).getTarget();§if (sourceCreature != null && creature != null) {§int power = sourceCreature.getPower().getValue();§if (power > 0) {§creature.addCounters(CounterType.P1P1.createInstance(power), game);§}§ContinuousEffect effect = new AddCardSubTypeTargetEffect("Mutant", Duration.Custom);§effect.setTargetPointer(new FixedTarget(creature.getId(), creature.getZoneChangeCounter(game) + 1));§game.addEffect(effect, source);§}§return false;§}§@Override§public MasterBiomancerEntersBattlefieldEffect copy() {§return new MasterBiomancerEntersBattlefieldEffect(this);§}§}§
public class OneThousandLashes extends CardImpl {§public OneThousandLashes(UUID ownerId) {§super(ownerId, 183, "One Thousand Lashes", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{W}{B}");§this.expansionSetCode = "GTC";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CantBlockAttackActivateAttachedEffect()));§this.addAbility(new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new LoseLifeTargetEffect(1), TargetController.CONTROLLER_ATTACHED_TO, false, true));§}§public OneThousandLashes(final OneThousandLashes card) {§super(card);§}§@Override§public OneThousandLashes copy() {§return new OneThousandLashes(this);§}§}§
public class Rubblehulk extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledLandPermanent("lands you control");§public Rubblehulk(UUID ownerId) {§super(ownerId, 191, "Rubblehulk", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{R}{G}");§this.expansionSetCode = "GTC";§this.subtype.add("Elemental");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§DynamicValue controlledLands = new PermanentsOnBattlefieldCount(filter);§this.addAbility(new SimpleStaticAbility(Zone.ALL, new SetPowerToughnessSourceEffect(controlledLands, Duration.EndOfGame)));§this.addAbility(new BloodrushAbility("{1}{R}{G}", new BoostTargetEffect(controlledLands,controlledLands, Duration.EndOfTurn)));§}§public Rubblehulk(final Rubblehulk card) {§super(card);§}§@Override§public Rubblehulk copy() {§return new Rubblehulk(this);§}§}§
public class SimicManipulator extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature with power less than or equal to the number of +1/+1 counters removed this way");§public SimicManipulator(UUID ownerId) {§super(ownerId, 50, "Simic Manipulator", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{U}{U}");§this.expansionSetCode = "GTC";§this.subtype.add("Mutant");§this.subtype.add("Wizard");§this.power = new MageInt(0);§this.toughness = new MageInt(1);§this.addAbility(new EvolveAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new SimicManipulatorGainControlTargetEffect(Duration.Custom), new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent(filter));§ability.addCost(new RemoveVariableCountersSourceCost(CounterType.P1P1.createInstance(), 1, "Remove one or more +1/+1 counters from {this}"));§this.addAbility(ability);§}§public SimicManipulator(final SimicManipulator card) {§super(card);§}§@Override§public SimicManipulator copy() {§return new SimicManipulator(this);§}§}§class SimicManipulatorGainControlTargetEffect extends ContinuousEffectImpl {§private boolean valid;§public SimicManipulatorGainControlTargetEffect(Duration duration) {§super(duration, Layer.ControlChangingEffects_2, SubLayer.NA, Outcome.GainControl);§}§public SimicManipulatorGainControlTargetEffect(final SimicManipulatorGainControlTargetEffect effect) {§super(effect);§this.valid = effect.valid;§}§@Override§public void init(Ability source, Game game) {§Permanent permanent = game.getPermanent(source.getFirstTarget());§if (permanent != null) {§int maxPower = 0;§for (Cost cost : source.getCosts()) {§if (cost instanceof RemoveVariableCountersSourceCost) {§maxPower = ((RemoveVariableCountersSourceCost) cost).getAmount();§break;§}§}§if (permanent.getPower().getValue() <= maxPower) {§valid = true;§}§}§}§@Override§public SimicManipulatorGainControlTargetEffect copy() {§return new SimicManipulatorGainControlTargetEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(source.getFirstTarget());§if (permanent != null && valid) {§return permanent.changeControllerId(source.getControllerId(), game);§}§return false;§}§@Override§public String getText(Mode mode) {§return "Gain control of target " + mode.getTargets().get(0).getTargetName() + " " + duration.toString();§}§}§
public class ThespiansStage extends CardImpl {§public ThespiansStage(UUID ownerId) {§super(ownerId, 248, "Thespian's Stage", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "GTC";§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ThespiansStageCopyEffect(), new GenericManaCost(2));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetLandPermanent());§this.addAbility(ability);§}§public ThespiansStage(final ThespiansStage card) {§super(card);§}§@Override§public ThespiansStage copy() {§return new ThespiansStage(this);§}§}§class ThespiansStageCopyEffect extends OneShotEffect {§public ThespiansStageCopyEffect() {§super(Outcome.Benefit);§this.staticText = "{this} becomes a copy of target land and gains this ability";§}§public ThespiansStageCopyEffect(final ThespiansStageCopyEffect effect) {§super(effect);§}§@Override§public ThespiansStageCopyEffect copy() {§return new ThespiansStageCopyEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent sourcePermanent = game.getPermanent(source.getSourceId());§Permanent copyFromPermanent = game.getPermanent(getTargetPointer().getFirst(game, source));§if (sourcePermanent != null && copyFromPermanent != null) {§Permanent newPermanent = game.copyPermanent(copyFromPermanent, sourcePermanent.getId(), source, new EmptyApplyToPermanent());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ThespiansStageCopyEffect(), new GenericManaCost(2));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetLandPermanent());§newPermanent.addAbility(ability, source.getSourceId(), game);§return true;§}§return false;§}§}§
public class WayOfTheThief extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("Gate");§static {§filter.add(new SubtypePredicate("Gate"));§}§private final String rule = "Enchanted creature can't be blocked as long as you control a Gate";§public WayOfTheThief(UUID ownerId) {§super(ownerId, 56, "Way of the Thief", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{3}{U}");§this.expansionSetCode = "GTC";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(2, 2, Duration.WhileOnBattlefield)));§Effect effect = new ConditionalRestrictionEffect(new CantBeBlockedAttachedEffect(AttachmentType.AURA), new PermanentsOnTheBattlefieldCondition(filter));§effect.setText(rule);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§}§public WayOfTheThief(final WayOfTheThief card) {§super(card);§}§@Override§public WayOfTheThief copy() {§return new WayOfTheThief(this);§}§}§
public class Cremate extends CardImpl {§public Cremate(UUID ownerId) {§super(ownerId, 45, "Cremate", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{B}");§this.expansionSetCode = "GPT";§this.getSpellAbility().addEffect(new ExileTargetEffect());§this.getSpellAbility().addTarget(new TargetCardInGraveyard());§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));§}§public Cremate(final Cremate card) {§super(card);§}§@Override§public Cremate copy() {§return new Cremate(this);§}§}§
public class Gigadrowse extends CardImpl {§public Gigadrowse(UUID ownerId) {§super(ownerId, 26, "Gigadrowse", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{U}");§this.expansionSetCode = "GPT";§this.addAbility(new ReplicateAbility(this, "{U}"));§this.getSpellAbility().addEffect(new TapTargetEffect());§this.getSpellAbility().addTarget(new TargetPermanent());§}§public Gigadrowse(final Gigadrowse card) {§super(card);§}§@Override§public Gigadrowse copy() {§return new Gigadrowse(this);§}§}§
public class LeylineOfLifeforce extends CardImpl {§public LeylineOfLifeforce(UUID ownerId) {§super(ownerId, 90, "Leyline of Lifeforce", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{2}{G}{G}");§this.expansionSetCode = "GPT";§this.addAbility(LeylineAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new LeylineOfLifeforceEffect()));§}§public LeylineOfLifeforce(final LeylineOfLifeforce card) {§super(card);§}§@Override§public LeylineOfLifeforce copy() {§return new LeylineOfLifeforce(this);§}§}§class LeylineOfLifeforceEffect extends ContinuousRuleModifyingEffectImpl {§LeylineOfLifeforceEffect() {§super(Duration.WhileOnBattlefield, Outcome.Benefit);§staticText = "Creature spells can't be countered";§}§LeylineOfLifeforceEffect(final LeylineOfLifeforceEffect effect) {§super(effect);§}§@Override§public LeylineOfLifeforceEffect copy() {§return new LeylineOfLifeforceEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == EventType.COUNTER;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§Spell spell = game.getStack().getSpell(event.getTargetId());§if (spell != null && spell.getCardType().contains(CardType.CREATURE)) {§return true;§}§return false;§}§}§
public class PoisonbellyOgre extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("another creature");§static {§filter.add(new AnotherPredicate());§}§private final static String RULE = "Whenever another creature enters the battlefield, its controller loses 1 life.";§public PoisonbellyOgre(UUID ownerId) {§super(ownerId, 57, "Poisonbelly Ogre", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{B}");§this.expansionSetCode = "GPT";§this.subtype.add("Ogre");§this.subtype.add("Warrior");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new EntersBattlefieldAllTriggeredAbility(Zone.BATTLEFIELD, new LoseLifeTargetEffect(1), filter, false, SetTargetPointer.PLAYER, RULE, false));§}§public PoisonbellyOgre(final PoisonbellyOgre card) {§super(card);§}§@Override§public PoisonbellyOgre copy() {§return new PoisonbellyOgre(this);§}§}§
public class SkyriderTrainee extends CardImpl {§public SkyriderTrainee(UUID ownerId) {§super(ownerId, 17, "Skyrider Trainee", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{W}");§this.expansionSetCode = "GPT";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD,§new ConditionalContinuousEffect(§new GainAbilitySourceEffect(FlyingAbility.getInstance(), Duration.WhileOnBattlefield),§new EnchantedCondition(),§"{this} has flying as long as it's enchanted")));§}§public SkyriderTrainee(final SkyriderTrainee card) {§super(card);§}§@Override§public SkyriderTrainee copy() {§return new SkyriderTrainee(this);§}§}§
public class VedalkenPlotter extends CardImpl {§private static final String rule = "exchange control of target land you control and target land an opponent controls";§private static final FilterLandPermanent filter = new FilterLandPermanent("land an opponent controls");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public VedalkenPlotter(UUID ownerId) {§super(ownerId, 41, "Vedalken Plotter", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "GPT";§this.subtype.add("Vedalken");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Effect effect = new ExchangeControlTargetEffect(Duration.EndOfGame, rule, false, true);§effect.setText("exchange control of target land you control and target land an opponent controls");§Ability ability = new EntersBattlefieldTriggeredAbility(effect, false, true);§ability.addTarget(new TargetControlledPermanent(new FilterControlledLandPermanent()));§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§}§public VedalkenPlotter(final VedalkenPlotter card) {§super(card);§}§@Override§public VedalkenPlotter copy() {§return new VedalkenPlotter(this);§}§}§
public class AlibansTower1 extends CardImpl {§public AlibansTower1(UUID ownerId) {§super(ownerId, 76, "Aliban's Tower", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{R}");§this.expansionSetCode = "HML";§this.getSpellAbility().addEffect(new BoostTargetEffect(3, 1, Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent(new FilterBlockingCreature()));§}§public AlibansTower1(final AlibansTower1 card) {§super(card);§}§@Override§public AlibansTower1 copy() {§return new AlibansTower1(this);§}§}§
public class EronTheRelentless extends CardImpl {§public EronTheRelentless(UUID ownerId) {§super(ownerId, 93, "Eron the Relentless", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{R}{R}");§this.expansionSetCode = "HML";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Rogue");§this.power = new MageInt(5);§this.toughness = new MageInt(2);§this.addAbility(HasteAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new ManaCostsImpl("{R}{R}{R}"));§this.addAbility(ability);§}§public EronTheRelentless(final EronTheRelentless card) {§super(card);§}§@Override§public EronTheRelentless copy() {§return new EronTheRelentless(this);§}§}§
public class RootSpider extends CardImpl {§public RootSpider(UUID ownerId) {§super(ownerId, 67, "Root Spider", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "HML";§this.subtype.add("Spider");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Effect effect = new BoostSourceEffect(1, 0, Duration.EndOfTurn);§effect.setText("it gets +1/+0");§Effect effect2 = new GainAbilitySourceEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn);§effect2.setText("and gains first strike until end of turn");§Ability ability = new BlocksTriggeredAbility(effect, false);§ability.addEffect(effect2);§this.addAbility(ability);§}§public RootSpider(final RootSpider card) {§super(card);§}§@Override§public RootSpider copy() {§return new RootSpider(this);§}§}§
public class BalduvianBears extends CardImpl {§public BalduvianBears(UUID ownerId) {§super(ownerId, 114, "Balduvian Bears", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "ICE";§this.subtype.add("Bear");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§}§public BalduvianBears(final BalduvianBears card) {§super(card);§}§@Override§public BalduvianBears copy() {§return new BalduvianBears(this);§}§}§
public class ElderDruid extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("artifact, creature, or land");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.ARTIFACT),§new CardTypePredicate(CardType.CREATURE),§new CardTypePredicate(CardType.LAND)));§}§public ElderDruid(UUID ownerId) {§super(ownerId, 120, "Elder Druid", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "ICE";§this.subtype.add("Elf");§this.subtype.add("Cleric");§this.subtype.add("Druid");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new MayTapOrUntapTargetEffect(), new ManaCostsImpl("{3}{G}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§}§public ElderDruid(final ElderDruid card) {§super(card);§}§@Override§public ElderDruid copy() {§return new ElderDruid(this);§}§}§
public class Hecatomb extends CardImpl {§private static final FilterControlledLandPermanent filter = new FilterControlledLandPermanent("an untapped Swamp you control");§static {§filter.add(new SubtypePredicate("Swamp"));§filter.add(Predicates.not(new TappedPredicate()));§}§public Hecatomb(UUID ownerId) {§super(ownerId, 18, "Hecatomb", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{1}{B}{B}");§this.expansionSetCode = "ICE";§this.addAbility(new EntersBattlefieldTriggeredAbility(new SacrificeSourceUnlessPaysEffect(new SacrificeTargetCost(new TargetControlledCreaturePermanent(4))), false));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new TapTargetCost(new TargetControlledPermanent(1, 1, filter, true)));§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public Hecatomb(final Hecatomb card) {§super(card);§}§@Override§public Hecatomb copy() {§return new Hecatomb(this);§}§}§
public class Lhurgoyf extends CardImpl {§public Lhurgoyf(UUID ownerId) {§super(ownerId, 140, "Lhurgoyf", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{G}{G}");§this.expansionSetCode = "ICE";§this.subtype.add("Lhurgoyf");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new LhurgoyfEffect()));§}§public Lhurgoyf(final Lhurgoyf card) {§super(card);§}§@Override§public Lhurgoyf copy() {§return new Lhurgoyf(this);§}§}§class LhurgoyfEffect extends ContinuousEffectImpl {§public LhurgoyfEffect() {§super(Duration.WhileOnBattlefield, Layer.PTChangingEffects_7, SubLayer.CharacteristicDefining_7a, Outcome.BoostCreature);§staticText = "{this}'s power is equal to the number of creature cards in all graveyards and its toughness is equal to that number plus 1";§}§public LhurgoyfEffect(final LhurgoyfEffect effect) {§super(effect);§}§@Override§public LhurgoyfEffect copy() {§return new LhurgoyfEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§MageObject mageObject = game.getObject(source.getSourceId());§if (mageObject != null) {§int number = 0;§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§number += player.getGraveyard().count(new FilterCreatureCard(), game);§}§}§mageObject.getPower().setValue(number);§mageObject.getToughness().setValue(number + 1);§return true;§}§}§return false;§}§}§
public class Pyknite extends CardImpl {§public Pyknite(UUID ownerId) {§super(ownerId, 146, "Pyknite", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "ICE";§this.subtype.add("Ouphe");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new EntersBattlefieldTriggeredAbility(new CreateDelayedTriggeredAbilityEffect(§new AtTheBeginOfNextUpkeepDelayedTriggeredAbility(new DrawCardSourceControllerEffect(1), Duration.OneUse)), false));§}§public Pyknite(final Pyknite card) {§super(card);§}§@Override§public Pyknite copy() {§return new Pyknite(this);§}§}§
public class SongsOfTheDamned extends CardImpl {§public SongsOfTheDamned(UUID ownerId) {§super(ownerId, 48, "Songs of the Damned", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{B}");§this.expansionSetCode = "ICE";§DynamicManaEffect effect = new DynamicManaEffect(Mana.BlackMana(1), new CardsInControllerGraveyardCount(new FilterCreatureCard()));§this.getSpellAbility().addEffect(effect);§}§public SongsOfTheDamned(final SongsOfTheDamned card) {§super(card);§}§@Override§public SongsOfTheDamned copy() {§return new SongsOfTheDamned(this);§}§}§
public class Whiteout extends CardImpl {§private static final FilterControlledLandPermanent filter = new FilterControlledLandPermanent("a snow land");§static {§filter.add(new SupertypePredicate("Snow"));§}§public Whiteout(UUID ownerId) {§super(ownerId, 163, "Whiteout", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{G}");§this.expansionSetCode = "ICE";§this.getSpellAbility().addEffect(new LoseAbilityAllEffect(new FilterCreaturePermanent(), FlyingAbility.getInstance(), Duration.EndOfTurn));§this.addAbility(new SimpleActivatedAbility(Zone.GRAVEYARD, new ReturnToHandSourceEffect(), new SacrificeTargetCost(new TargetControlledPermanent(filter))));§}§public Whiteout(final Whiteout card) {§super(card);§}§@Override§public Whiteout copy() {§return new Whiteout(this);§}§}§
public class AshmouthHound extends CardImpl {§public AshmouthHound(UUID ownerId) {§super(ownerId, 128, "Ashmouth Hound", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "ISD";§this.subtype.add("Elemental");§this.subtype.add("Hound");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new BlocksOrBecomesBlockedByCreatureTriggeredAbility(new DamageTargetEffect(1, true, "that creature"), false));§}§public AshmouthHound(final AshmouthHound card) {§super(card);§}§@Override§public AshmouthHound copy() {§return new AshmouthHound(this);§}§}§
public class CacklingCounterpart extends CardImpl {§public CacklingCounterpart(UUID ownerId) {§super(ownerId, 46, "Cackling Counterpart", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{1}{U}{U}");§this.expansionSetCode = "ISD";§this.getSpellAbility().addEffect(new PutTokenOntoBattlefieldCopyTargetEffect());§this.getSpellAbility().addTarget(new TargetControlledCreaturePermanent());§this.addAbility(new FlashbackAbility(new ManaCostsImpl("{5}{U}{U}"), TimingRule.INSTANT));§}§public CacklingCounterpart(final CacklingCounterpart card) {§super(card);§}§@Override§public CacklingCounterpart copy() {§return new CacklingCounterpart(this);§}§}§
public class CurseOfTheNightlyHunt extends CardImpl {§public CurseOfTheNightlyHunt(UUID ownerId) {§super(ownerId, 137, "Curse of the Nightly Hunt", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{R}");§this.expansionSetCode = "ISD";§this.subtype.add("Aura");§this.subtype.add("Curse");§TargetPlayer auraTarget = new TargetPlayer();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));§this.addAbility(new EnchantAbility(auraTarget.getTargetName()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CurseOfTheNightlyHuntEffect()));§}§public CurseOfTheNightlyHunt(final CurseOfTheNightlyHunt card) {§super(card);§}§@Override§public CurseOfTheNightlyHunt copy() {§return new CurseOfTheNightlyHunt(this);§}§}§class CurseOfTheNightlyHuntEffect extends RequirementEffect {§public CurseOfTheNightlyHuntEffect() {§super(Duration.WhileOnBattlefield);§staticText = "Creatures enchanted player controls attack each turn if able";§}§public CurseOfTheNightlyHuntEffect(final CurseOfTheNightlyHuntEffect effect) {§super(effect);§}§@Override§public CurseOfTheNightlyHuntEffect copy() {§return new CurseOfTheNightlyHuntEffect(this);§}§@Override§public boolean applies(Permanent permanent, Ability source, Game game) {§Permanent enchantment = game.getPermanent(source.getSourceId());§if (enchantment != null && enchantment.getAttachedTo() != null) {§if (permanent.getControllerId().equals(enchantment.getAttachedTo())) {§return true;§}§}§return false;§}§@Override§public boolean mustAttack(Game game) {§return true;§}§@Override§public boolean mustBlock(Game game) {§return false;§}§}§
public class EndlessRanksOfTheDead extends CardImpl {§public EndlessRanksOfTheDead(UUID ownerId) {§super(ownerId, 99, "Endless Ranks of the Dead", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{2}{B}{B}");§this.expansionSetCode = "ISD";§this.addAbility(new OnEventTriggeredAbility(EventType.UPKEEP_STEP_PRE, "beginning of your upkeep",§new CreateTokenEffect(new ZombieToken(), new HalfZombiesCount())));§}§public EndlessRanksOfTheDead(final EndlessRanksOfTheDead card) {§super(card);§}§@Override§public EndlessRanksOfTheDead copy() {§return new EndlessRanksOfTheDead(this);§}§}§class HalfZombiesCount implements DynamicValue {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent();§static {§filter.add(new SubtypePredicate("Zombie"));§}§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§int amount = game.getBattlefield().countAll(filter, sourceAbility.getControllerId(), game) / 2;§return amount;§}§@Override§public DynamicValue copy() {§return new HalfZombiesCount();§}§@Override§public String toString() {§return "X";§}§@Override§public String getMessage() {§return "half the number of Zombies you control, rounded down";§}§}§
public class GavonyTownship extends CardImpl {§public GavonyTownship(UUID ownerId) {§super(ownerId, 239, "Gavony Township", Rarity.RARE, new CardType[]{CardType.LAND}, null);§this.expansionSetCode = "ISD";§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersAllEffect(CounterType.P1P1.createInstance(), new FilterControlledCreaturePermanent("creature you control")), new ManaCostsImpl("{2}{G}{W}"));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public GavonyTownship(final GavonyTownship card) {§super(card);§}§@Override§public GavonyTownship copy() {§return new GavonyTownship(this);§}§}§
public class HanweirWatchkeep extends CardImpl {§public HanweirWatchkeep(UUID ownerId) {§super(ownerId, 145, "Hanweir Watchkeep", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "ISD";§this.subtype.add("Human");§this.subtype.add("Warrior");§this.subtype.add("Werewolf");§this.canTransform = true;§this.secondSideCard = new BaneOfHanweir(ownerId);§this.power = new MageInt(1);§this.toughness = new MageInt(5);§this.addAbility(DefenderAbility.getInstance());§this.addAbility(new TransformAbility());§TriggeredAbility ability = new BeginningOfUpkeepTriggeredAbility(new TransformSourceEffect(true), TargetController.ANY, false);§this.addAbility(new ConditionalTriggeredAbility(ability, NoSpellsWereCastLastTurnCondition.getInstance(), TransformAbility.NO_SPELLS_TRANSFORM_RULE));§}§public HanweirWatchkeep(final HanweirWatchkeep card) {§super(card);§}§@Override§public HanweirWatchkeep copy() {§return new HanweirWatchkeep(this);§}§}§
public class KessigWolf extends CardImpl {§public KessigWolf(UUID ownerId) {§super(ownerId, 151, "Kessig Wolf", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "ISD";§this.subtype.add("Wolf");§this.power = new MageInt(3);§this.toughness = new MageInt(1);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD,§new GainAbilitySourceEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn),§new ManaCostsImpl("{1}{R}")));§}§public KessigWolf(final KessigWolf card) {§super(card);§}§@Override§public KessigWolf copy() {§return new KessigWolf(this);§}§}§
public class MawOfTheMire extends CardImpl {§public MawOfTheMire(UUID ownerId) {§super(ownerId, 108, "Maw of the Mire", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{4}{B}");§this.expansionSetCode = "ISD";§this.getSpellAbility().addTarget(new TargetLandPermanent());§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addEffect(new GainLifeEffect(4));§}§public MawOfTheMire(final MawOfTheMire card) {§super(card);§}§@Override§public MawOfTheMire copy() {§return new MawOfTheMire(this);§}§}§
public class NightbirdsClutches extends CardImpl {§public NightbirdsClutches(UUID ownerId) {§super(ownerId, 154, "Nightbird's Clutches", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{1}{R}");§this.expansionSetCode = "ISD";§this.getSpellAbility().addEffect(new CantBlockTargetEffect(Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent(0, 2));§this.addAbility(new FlashbackAbility(new ManaCostsImpl("{3}{R}"), TimingRule.SORCERY));§}§public NightbirdsClutches(final NightbirdsClutches card) {§super(card);§}§@Override§public NightbirdsClutches copy() {§return new NightbirdsClutches(this);§}§}§
public class RecklessWaif extends CardImpl {§public RecklessWaif(UUID ownerId) {§super(ownerId, 159, "Reckless Waif", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "ISD";§this.subtype.add("Human");§this.subtype.add("Rogue");§this.subtype.add("Werewolf");§this.canTransform = true;§this.secondSideCard = new MercilessPredator(ownerId);§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new TransformAbility());§TriggeredAbility ability = new BeginningOfUpkeepTriggeredAbility(new TransformSourceEffect(true), TargetController.ANY, false);§this.addAbility(new ConditionalTriggeredAbility(ability, NoSpellsWereCastLastTurnCondition.getInstance(), TransformAbility.NO_SPELLS_TRANSFORM_RULE));§}§public RecklessWaif(final RecklessWaif card) {§super(card);§}§@Override§public RecklessWaif copy() {§return new RecklessWaif(this);§}§}§
public class SkirsdagCultist extends CardImpl {§public SkirsdagCultist(UUID ownerId) {§super(ownerId, 163, "Skirsdag Cultist", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "ISD";§this.subtype.add("Human");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(2), new ManaCostsImpl("{R}"));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent()));§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public SkirsdagCultist(final SkirsdagCultist card) {§super(card);§}§@Override§public SkirsdagCultist copy() {§return new SkirsdagCultist(this);§}§}§
public class SulfurFalls extends CardImpl {§private static final FilterLandPermanent filter = new FilterLandPermanent();§static {§filter.add(Predicates.or(new SubtypePredicate("Island"), new SubtypePredicate("Mountain")));§}§public SulfurFalls(UUID ownerId) {§super(ownerId, 248, "Sulfur Falls", Rarity.RARE, new CardType[]{CardType.LAND}, null);§this.expansionSetCode = "ISD";§Condition controls = new InvertCondition(new PermanentsOnTheBattlefieldCondition(filter, PermanentsOnTheBattlefieldCondition.CountType.MORE_THAN, 0));§String abilityText = "tap it unless you control a Island or a Mountain";§this.addAbility(new EntersBattlefieldAbility(new ConditionalOneShotEffect(new TapSourceEffect(), controls, abilityText), abilityText));§this.addAbility(new BlueManaAbility());§this.addAbility(new RedManaAbility());§}§public SulfurFalls(final SulfurFalls card) {§super(card);§}§@Override§public SulfurFalls copy() {§return new SulfurFalls(this);§}§}§
public class UnrulyMob extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("another creature you control");§static {§filter.add(new AnotherPredicate());§filter.add(new ControllerPredicate(TargetController.YOU));§}§public UnrulyMob(UUID ownerId) {§super(ownerId, 39, "Unruly Mob", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "ISD";§this.subtype.add("Human");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new DiesCreatureTriggeredAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance()), false, filter));§}§public UnrulyMob(final UnrulyMob card) {§super(card);§}§@Override§public UnrulyMob copy() {§return new UnrulyMob(this);§}§}§
public class AlloyGolem extends CardImpl {§public AlloyGolem(UUID ownerId) {§super(ownerId, 297, "Alloy Golem", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{6}");§this.expansionSetCode = "INV";§this.subtype.add("Golem");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new EntersBattlefieldAbility(new BecomesColorSourceEffect(Duration.WhileOnBattlefield),§null, "As {this} enters the battlefield, choose a color.\n{this} is the chosen color.", ""));§}§public AlloyGolem(final AlloyGolem card) {§super(card);§}§@Override§public AlloyGolem copy() {§return new AlloyGolem(this);§}§}§
public class BlurredMongoose extends CardImpl {§public BlurredMongoose(UUID ownerId) {§super(ownerId, 183, "Blurred Mongoose", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "INV";§this.subtype.add("Mongoose");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new CantBeCounteredAbility());§this.addAbility(ShroudAbility.getInstance());§}§public BlurredMongoose(final BlurredMongoose card) {§super(card);§}§@Override§public BlurredMongoose copy() {§return new BlurredMongoose(this);§}§}§
public class DevouringStrossus extends CardImpl {§public DevouringStrossus(UUID ownerId) {§super(ownerId, 101, "Devouring Strossus", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{B}{B}{B}");§this.expansionSetCode = "INV";§this.subtype.add("Horror");§this.power = new MageInt(9);§this.toughness = new MageInt(9);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(TrampleAbility.getInstance());§Ability ability = new BeginningOfUpkeepTriggeredAbility(new SacrificeEffect(new FilterControlledCreaturePermanent("creature"), 1, null),§TargetController.YOU, false);§this.addAbility(ability);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(),§new SacrificeTargetCost(new TargetControlledCreaturePermanent(1, 1, new FilterControlledCreaturePermanent("a creature"), true))));§}§public DevouringStrossus(final DevouringStrossus card) {§super(card);§}§@Override§public DevouringStrossus copy() {§return new DevouringStrossus(this);§}§}§
public class GeothermalCrevice extends CardImpl {§public GeothermalCrevice(UUID ownerId) {§super(ownerId, 323, "Geothermal Crevice", Rarity.COMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "INV";§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new RedManaAbility());§Ability ability = new SimpleManaAbility(Zone.BATTLEFIELD, new BasicManaEffect(new Mana(0, 1, 0, 0, 1, 0, 0, 0)), new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public GeothermalCrevice(final GeothermalCrevice card) {§super(card);§}§@Override§public GeothermalCrevice copy() {§return new GeothermalCrevice(this);§}§}§
public class KavuTitan extends CardImpl {§public KavuTitan(UUID ownerId) {§super(ownerId, 194, "Kavu Titan", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "INV";§this.subtype.add("Kavu");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new KickerAbility("{2}{G}"));§Ability ability = new EntersBattlefieldAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance(3)),§KickedCondition.getInstance(),§"If Kavu Titan was kicked, it enters the battlefield with three +1/+1 counters on it and with trample.", "");§ability.addEffect(new GainAbilitySourceEffect(TrampleAbility.getInstance(), Duration.WhileOnBattlefield));§this.addAbility(ability);§}§public KavuTitan(final KavuTitan card) {§super(card);§}§@Override§public KavuTitan copy() {§return new KavuTitan(this);§}§}§
public class Opt extends CardImpl {§public Opt(UUID ownerId) {§super(ownerId, 64, "Opt", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{U}");§this.expansionSetCode = "INV";§this.getSpellAbility().addEffect(new ScryEffect(1));§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));§}§public Opt(final Opt card) {§super(card);§}§@Override§public Opt copy() {§return new Opt(this);§}§}§
public class RagingKavu extends CardImpl {§public RagingKavu(UUID ownerId) {§super(ownerId, 262, "Raging Kavu", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{R}{G}");§this.expansionSetCode = "INV";§this.subtype.add("Kavu");§this.power = new MageInt(3);§this.toughness = new MageInt(1);§this.addAbility(FlashAbility.getInstance());§this.addAbility(HasteAbility.getInstance());§}§public RagingKavu(final RagingKavu card) {§super(card);§}§@Override§public RagingKavu copy() {§return new RagingKavu(this);§}§}§
public class SavageOffensive extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creatures you control");§static {§filter.add(new ControllerPredicate(TargetController.YOU));§}§public SavageOffensive(UUID ownerId) {§super(ownerId, 162, "Savage Offensive", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{1}{R}");§this.expansionSetCode = "INV";§this.addAbility(new KickerAbility("{G}"));§this.getSpellAbility().addEffect(new GainAbilityAllEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn, filter));§this.getSpellAbility().addEffect(new ConditionalOneShotEffect(§new AddContinuousEffectToGame(new BoostControlledEffect(1, 1, Duration.EndOfTurn)),§KickedCondition.getInstance(),§"If {this} was kicked, they get +1/+1 until end of turn."));§}§public SavageOffensive(final SavageOffensive card) {§super(card);§}§@Override§public SavageOffensive copy() {§return new SavageOffensive(this);§}§}§
public class SpiritOfResistance extends CardImpl {§public SpiritOfResistance(UUID ownerId) {§super(ownerId, 38, "Spirit of Resistance", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{2}{W}");§this.expansionSetCode = "INV";§Effect effect = new ConditionalReplacementEffect(§new PreventAllDamageToControllerEffect(Duration.WhileOnBattlefield),§SpiritOfResistanceCondition.getInstance());§effect.setText("As long as you control a permanent of each color, prevent all damage that would be dealt to you.");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§}§public SpiritOfResistance(final SpiritOfResistance card) {§super(card);§}§@Override§public SpiritOfResistance copy() {§return new SpiritOfResistance(this);§}§}§class SpiritOfResistanceCondition implements Condition {§private static final SpiritOfResistanceCondition fInstance = new SpiritOfResistanceCondition();§public static SpiritOfResistanceCondition getInstance() {§return fInstance;§};§private SpiritOfResistanceCondition() {}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§HashSet<ObjectColor> colors = new HashSet<>();§for (Permanent permanent : game.getBattlefield().getAllActivePermanents(controller.getId())) {§if (permanent.getColor(game).isBlack()) {§colors.add(ObjectColor.BLACK);§}§if (permanent.getColor(game).isBlue()) {§colors.add(ObjectColor.BLUE);§}§if (permanent.getColor(game).isRed()) {§colors.add(ObjectColor.RED);§}§if (permanent.getColor(game).isGreen()) {§colors.add(ObjectColor.GREEN);§}§if (permanent.getColor(game).isWhite()) {§colors.add(ObjectColor.WHITE);§}§}§return colors.size() >= 5;§}§return false;§}§@Override§public String toString() {§return "you control a permanent of each color";§}§}§
public class TidalVisionary extends CardImpl {§public TidalVisionary(UUID ownerId) {§super(ownerId, 80, "Tidal Visionary", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{U}");§this.expansionSetCode = "INV";§this.subtype.add("Merfolk");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BecomesColorTargetEffect(Duration.EndOfTurn),§new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public TidalVisionary(final TidalVisionary card) {§super(card);§}§@Override§public TidalVisionary copy() {§return new TidalVisionary(this);§}§}§
public class UrborgSkeleton extends CardImpl {§private static final String staticText = "If Urborg Skeleton was kicked, it enters the battlefield with a +1/+1 counter on it";§public UrborgSkeleton(UUID ownerId) {§super(ownerId, 134, "Urborg Skeleton", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{B}");§this.expansionSetCode = "INV";§this.subtype.add("Skeleton");§this.power = new MageInt(0);§this.toughness = new MageInt(1);§this.addAbility(new KickerAbility("{3}"));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new ManaCostsImpl("{B}")));§Ability ability = new EntersBattlefieldAbility(§new AddCountersSourceEffect(CounterType.P1P1.createInstance(1)),§KickedCondition.getInstance(), staticText,"");§this.addAbility(ability);§}§public UrborgSkeleton(final UrborgSkeleton card) {§super(card);§}§@Override§public UrborgSkeleton copy() {§return new UrborgSkeleton(this);§}§}§
public class Winnow extends CardImpl {§public Winnow(UUID ownerId) {§super(ownerId, 45, "Winnow", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{1}{W}");§this.expansionSetCode = "INV";§this.getSpellAbility().addEffect(new WinnowEffect());§this.getSpellAbility().addTarget(new TargetNonlandPermanent());§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));§}§public Winnow(final Winnow card) {§super(card);§}§@Override§public Winnow copy() {§return new Winnow(this);§}§}§class WinnowEffect extends DestroyTargetEffect {§public WinnowEffect() {§super();§staticText = "Destroy target nonland permanent if another permanent with the same name is on the battlefield.";§}§public WinnowEffect(final WinnowEffect effect) {§super(effect);§}§@Override§public WinnowEffect copy() {§return new WinnowEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent target = game.getPermanent(source.getFirstTarget());§if(target != null) {§FilterPermanent filter = new FilterPermanent();§filter.add(new NamePredicate(target.getName()));§if(new PermanentsOnBattlefieldCount(filter).calculate(game, source, this) > 1) {§super.apply(game, source);§}§return true;§}§return false;§}§}§
public class BodyDouble extends CardImpl {§public BodyDouble(UUID ownerId) {§super(ownerId, 15, "Body Double", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{U}");§this.expansionSetCode = "DDM";§this.subtype.add("Shapeshifter");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(new EntersBattlefieldAbility(new BodyDoubleCopyEffect(), true));§}§public BodyDouble(final BodyDouble card) {§super(card);§}§@Override§public BodyDouble copy() {§return new BodyDouble(this);§}§}§class BodyDoubleCopyEffect extends OneShotEffect {§public BodyDoubleCopyEffect() {§super(Outcome.Copy);§this.staticText = "as a copy of any creature card in a graveyard";§}§public BodyDoubleCopyEffect(final BodyDoubleCopyEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§Target target = new TargetCardInGraveyard(new FilterCreatureCard("creature card in a graveyard"));§target.setNotTarget(true);§if (target.canChoose(source.getControllerId(), game)) {§player.choose(outcome, target, source.getSourceId(), game);§Card copyFromCard = game.getCard(target.getFirstTarget());§if (copyFromCard != null) {§CopyEffect copyEffect = new CopyEffect(Duration.Custom, copyFromCard, source.getSourceId());§game.addEffect(copyEffect, source);§}§}§return true;§}§return false;§}§@Override§public BodyDoubleCopyEffect copy() {§return new BodyDoubleCopyEffect(this);§}§}§
public class BearerOfTheHeavens extends CardImpl {§public BearerOfTheHeavens(UUID ownerId) {§super(ownerId, 89, "Bearer of the Heavens", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{7}{R}");§this.expansionSetCode = "JOU";§this.subtype.add("Giant");§this.power = new MageInt(10);§this.toughness = new MageInt(10);§DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(new DestroyAllEffect(new FilterPermanent("permanents")));§Effect effect = new CreateDelayedTriggeredAbilityEffect(delayedAbility);§effect.setText("destroy all permanents at the beginning of the next end step");§this.addAbility(new DiesTriggeredAbility(effect, false));§}§public BearerOfTheHeavens(final BearerOfTheHeavens card) {§super(card);§}§@Override§public BearerOfTheHeavens copy() {§return new BearerOfTheHeavens(this);§}§}§
public class DictateOfErebos extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature you control");§static {§filter.add(new ControllerPredicate(TargetController.YOU));§}§public DictateOfErebos(UUID ownerId) {§super(ownerId, 65, "Dictate of Erebos", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{3}{B}{B}");§this.expansionSetCode = "JOU";§this.addAbility(FlashAbility.getInstance());§this.addAbility(new DiesCreatureTriggeredAbility(new SacrificeOpponentsEffect(new FilterControlledCreaturePermanent("a creature")), false, filter));§}§public DictateOfErebos(final DictateOfErebos card) {§super(card);§}§@Override§public DictateOfErebos copy() {§return new DictateOfErebos(this);§}§}§
public class FontOfIre extends CardImpl {§public FontOfIre(UUID ownerId) {§super(ownerId, 97, "Font of Ire", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{R}");§this.expansionSetCode = "JOU";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(5), new ManaCostsImpl("{3}{R}"));§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public FontOfIre(final FontOfIre card) {§super(card);§}§@Override§public FontOfIre copy() {§return new FontOfIre(this);§}§}§
public class HypnoticSiren extends CardImpl {§public HypnoticSiren(UUID ownerId) {§super(ownerId, 42, "Hypnotic Siren", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT, CardType.CREATURE}, "{U}");§this.expansionSetCode = "JOU";§this.subtype.add("Siren");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new BestowAbility(this, "{5}{U}{U}"));§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ControlEnchantedEffect()));§Effect effect = new BoostEnchantedEffect(1,1,Duration.WhileOnBattlefield);§effect.setText("Enchanted creature gets +1/+1");§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, effect);§effect = new GainAbilityAttachedEffect(FlyingAbility.getInstance(), AttachmentType.AURA);§effect.setText("and has flying");§ability.addEffect(effect);§this.addAbility(ability);§}§public HypnoticSiren(final HypnoticSiren card) {§super(card);§}§@Override§public HypnoticSiren copy() {§return new HypnoticSiren(this);§}§}§
public class NightmarishEnd extends CardImpl {§public NightmarishEnd(UUID ownerId) {§super(ownerId, 76, "Nightmarish End", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{2}{B}");§this.expansionSetCode = "JOU";§DynamicValue xValue = new SignInversionDynamicValue(new CardsInControllerHandCount());§Effect effect = new BoostTargetEffect(xValue, xValue, Duration.EndOfTurn, true);§effect.setText("Target creature gets -X/-X until end of turn, where X is the number of cards in your hand");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public NightmarishEnd(final NightmarishEnd card) {§super(card);§}§@Override§public NightmarishEnd copy() {§return new NightmarishEnd(this);§}§}§
public class ReturnedReveler extends CardImpl {§public ReturnedReveler(UUID ownerId) {§super(ownerId, 79, "Returned Reveler", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "JOU";§this.subtype.add("Zombie");§this.subtype.add("Satyr");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§this.addAbility(new DiesTriggeredAbility(new PutTopCardOfLibraryIntoGraveEachPlayerEffect(3, TargetController.ANY)));§}§public ReturnedReveler(final ReturnedReveler card) {§super(card);§}§@Override§public ReturnedReveler copy() {§return new ReturnedReveler(this);§}§}§
public class SkyspearCavalry extends CardImpl {§public SkyspearCavalry(UUID ownerId) {§super(ownerId, 26, "Skyspear Cavalry", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{W}{W}");§this.expansionSetCode = "JOU";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(DoubleStrikeAbility.getInstance());§}§public SkyspearCavalry(final SkyspearCavalry card) {§super(card);§}§@Override§public SkyspearCavalry copy() {§return new SkyspearCavalry(this);§}§}§
public class TritonCavalry extends CardImpl {§public TritonCavalry(UUID ownerId) {§super(ownerId, 55, "Triton Cavalry", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "JOU";§this.subtype.add("Merfolk");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(4);§Ability ability = new HeroicAbility(new ReturnToHandTargetEffect(), true);§ability.addTarget(new TargetEnchantmentPermanent());§this.addAbility(ability);§}§public TritonCavalry(final TritonCavalry card) {§super(card);§}§@Override§public TritonCavalry copy() {§return new TritonCavalry(this);§}§}§
public class Browbeat extends CardImpl {§public Browbeat(UUID ownerId) {§super(ownerId, 82, "Browbeat", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{2}{R}");§this.expansionSetCode = "JUD";§this.getSpellAbility().addEffect(new BrowbeatDrawEffect());§this.getSpellAbility().addTarget(new TargetPlayer());§}§public Browbeat(final Browbeat card) {§super(card);§}§@Override§public Browbeat copy() {§return new Browbeat(this);§}§}§class BrowbeatDrawEffect extends OneShotEffect {§public BrowbeatDrawEffect() {§super(Outcome.DrawCard);§staticText = "Any player may have {source} deal 5 damage to him or her. If no one does, target player draws three cards.";§}§public BrowbeatDrawEffect(final BrowbeatDrawEffect effect) {§super(effect);§}§@Override§public BrowbeatDrawEffect copy() {§return new BrowbeatDrawEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller == null) {§return false;§}§StackObject spell = null;§for(StackObject object : game.getStack()){§if(object instanceof Spell && object.getSourceId().equals(source.getSourceId())){§spell = object;§}§}§if(spell != null){§boolean drawCards = true;§for(UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)){§Player player = game.getPlayer(playerId);§if (player != null && player.chooseUse(Outcome.Detriment, "Have " + spell.getLogName() + " deal 5 damage to you?", source, game)){§drawCards = false;§player.damage(5, source.getSourceId(), game, false, true);§game.informPlayers(player.getLogName() + " has " + spell.getLogName() + " deal 5 to him or her");§}§}§if (drawCards) {§UUID targetPlayer = getTargetPointer().getFirst(game, source);§if (targetPlayer != null) {§Player player = game.getPlayer(targetPlayer);§player.drawCards(3, game);§}§}§return drawCards;§}§return false;§}§}§
public class FlashOfInsight extends CardImpl {§public FlashOfInsight(UUID ownerId) {§super(ownerId, 40, "Flash of Insight", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{X}{1}{U}");§this.expansionSetCode = "JUD";§this.getSpellAbility().addEffect(new FlashOfInsightEffect());§Ability ability = new FlashbackAbility(new ManaCostsImpl("{1}{U}"), TimingRule.INSTANT);§FilterCard filter = new FilterCard("blue cards from your graveyard");§filter.add(new ColorPredicate(ObjectColor.BLUE));§filter.add(Predicates.not(new CardIdPredicate(getId())));§ability.addCost(new ExileXFromYourGraveCost(filter));§this.addAbility(ability);§}§public FlashOfInsight(final FlashOfInsight card) {§super(card);§}§@Override§public FlashOfInsight copy() {§return new FlashOfInsight(this);§}§}§class FlashOfInsightEffect extends OneShotEffect {§public FlashOfInsightEffect() {§super(Outcome.DrawCard);§this.staticText = "Look at the top X cards of your library. Put one of them into your hand and the rest on the bottom of your library in any order";§}§public FlashOfInsightEffect(final FlashOfInsightEffect effect) {§super(effect);§}§@Override§public FlashOfInsightEffect copy() {§return new FlashOfInsightEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = game.getObject(source.getSourceId());§if (controller == null || sourceObject == null) {§return false;§}§int xValue = source.getManaCostsToPay().getX();§for (Cost cost : source.getCosts()) {§if (cost instanceof ExileFromGraveCost) {§xValue = ((ExileFromGraveCost) cost).getExiledCards().size();§}§}§Cards cards = new CardsImpl();§cards.addAll(controller.getLibrary().getTopCards(game, xValue));§controller.lookAtCards(sourceObject.getIdName(), cards, game);§TargetCard target = new TargetCard(Zone.LIBRARY, new FilterCard("card to put into your hand"));§target.setNotTarget(true);§if (controller.chooseTarget(Outcome.DrawCard, cards, target, source, game)) {§Card card = cards.get(target.getFirstTarget(), game);§if (card != null) {§controller.moveCards(card, Zone.HAND, source, game);§cards.remove(card);§}§}§controller.putCardsOnBottomOfLibrary(cards, game, source, true);§return true;§}§}§
public class LivingWish extends CardImpl {§public LivingWish(UUID ownerId) {§super(ownerId, 124, "Living Wish", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{1}{G}");§this.expansionSetCode = "JUD";§this.getSpellAbility().addEffect(new LivingWishEffect());§}§public LivingWish(final LivingWish card) {§super(card);§}§@Override§public LivingWish copy() {§return new LivingWish(this);§}§}§class LivingWishEffect extends OneShotEffect {§private static final String choiceText = "Choose a creature or land card you own from outside the game, and put it into your hand";§private static final FilterCard filter = new FilterCard("creature or land card");§static{§filter.add(Predicates.or(§new CardTypePredicate(CardType.CREATURE),§new CardTypePredicate(CardType.LAND)));§}§public LivingWishEffect() {§super(Outcome.Benefit);§this.staticText = "You may choose a creature or land card you own from outside the game, reveal that card, and put it into your hand. Exile Living Wish";§}§public LivingWishEffect(final LivingWishEffect effect) {§super(effect);§}§@Override§public LivingWishEffect copy() {§return new LivingWishEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§while (player.chooseUse(Outcome.Benefit, choiceText, source, game)) {§Cards cards = player.getSideboard();§if(cards.isEmpty()) {§game.informPlayer(player, "You have no cards outside the game.");§break;§}§Set<Card> filtered = cards.getCards(filter, game);§if (filtered.isEmpty()) {§game.informPlayer(player, "You have no " + filter.getMessage() + " outside the game.");§break;§}§Cards filteredCards = new CardsImpl();§for (Card card : filtered) {§filteredCards.add(card.getId());§}§TargetCard target = new TargetCard(Zone.OUTSIDE, filter);§if (player.choose(Outcome.Benefit, filteredCards, target, game)) {§Card card = player.getSideboard().get(target.getFirstTarget(), game);§if (card != null) {§card.moveToZone(Zone.HAND, source.getSourceId(), game, false);§Cards revealCard = new CardsImpl();§revealCard.add(card);§player.revealCards("Living Wish", revealCard, game);§break;§}§}§}§Card cardToExile = game.getCard(source.getSourceId());§if(cardToExile != null)§{§cardToExile.moveToExile(null, "", source.getSourceId(), game);§}§}§return true;§}§}§
public class Swelter extends CardImpl {§public Swelter(UUID ownerId) {§super(ownerId, 101, "Swelter", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{3}{R}");§this.expansionSetCode = "JUD";§this.getSpellAbility().addEffect(new DamageTargetEffect(2, true, "each of two target creatures"));§this.getSpellAbility().addTarget(new TargetCreaturePermanent(2, 2));§}§public Swelter(final Swelter card) {§super(card);§}§@Override§public Swelter copy() {§return new Swelter(this);§}§}§
public class AinokBondKin extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent();§static {§filter.add(new CardTypePredicate(CardType.CREATURE));§filter.add(new ControllerPredicate(TargetController.YOU));§filter.add(new CounterPredicate(CounterType.P1P1));§}§final String rule = "Each creature you control with a +1/+1 counter on it has first strike";§public AinokBondKin(UUID ownerId) {§super(ownerId, 3, "Ainok Bond-Kin", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "KTK";§this.subtype.add("Hound");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new OutlastAbility(new ManaCostsImpl("{1}{W}")));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAllEffect(FirstStrikeAbility.getInstance(), Duration.WhileOnBattlefield, filter, rule)));§}§public AinokBondKin(final AinokBondKin card) {§super(card);§}§@Override§public AinokBondKin copy() {§return new AinokBondKin(this);§}§}§
public class BloodfireExpert extends CardImpl {§public BloodfireExpert(UUID ownerId) {§super(ownerId, 101, "Bloodfire Expert", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "KTK";§this.subtype.add("Efreet");§this.subtype.add("Monk");§this.power = new MageInt(3);§this.toughness = new MageInt(1);§this.addAbility(new ProwessAbility());§}§public BloodfireExpert(final BloodfireExpert card) {§super(card);§}§@Override§public BloodfireExpert copy() {§return new BloodfireExpert(this);§}§}§
public class DefiantStrike extends CardImpl {§public DefiantStrike(UUID ownerId) {§super(ownerId, 7, "Defiant Strike", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{W}");§this.expansionSetCode = "KTK";§this.getSpellAbility().addEffect(new BoostTargetEffect(1, 0, Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§Effect effect = new DrawCardSourceControllerEffect(1);§effect.setText("<br><br>Draw a card");§this.getSpellAbility().addEffect(effect);§}§public DefiantStrike(final DefiantStrike card) {§super(card);§}§@Override§public DefiantStrike copy() {§return new DefiantStrike(this);§}§}§
public class FlyingCraneTechnique extends CardImpl {§public FlyingCraneTechnique(UUID ownerId) {§super(ownerId, 176, "Flying Crane Technique", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{3}{U}{R}{W}");§this.expansionSetCode = "KTK";§FilterCreaturePermanent filter = new FilterCreaturePermanent("creatures");§this.getSpellAbility().addEffect(new UntapAllControllerEffect(filter));§Effect effect = new GainAbilityControlledEffect(FlyingAbility.getInstance(), Duration.EndOfTurn, filter);§effect.setText("They gain flying");§this.getSpellAbility().addEffect(effect);§effect = new GainAbilityControlledEffect(DoubleStrikeAbility.getInstance(), Duration.EndOfTurn, filter);§effect.setText("and double strike until end of turn");§this.getSpellAbility().addEffect(effect);§}§public FlyingCraneTechnique(final FlyingCraneTechnique card) {§super(card);§}§@Override§public FlyingCraneTechnique copy() {§return new FlyingCraneTechnique(this);§}§}§
public class IcefeatherAven extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("another target creature");§static {§filter.add(new AnotherPredicate());§}§public IcefeatherAven(UUID ownerId) {§super(ownerId, 178, "Icefeather Aven", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{G}{U}");§this.expansionSetCode = "KTK";§this.subtype.add("Bird");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new MorphAbility(this, new ManaCostsImpl("{1}{G}{U}")));§Ability ability = new TurnedFaceUpSourceTriggeredAbility(new ReturnToHandTargetEffect(), false, true);§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public IcefeatherAven(final IcefeatherAven card) {§super(card);§}§@Override§public IcefeatherAven copy() {§return new IcefeatherAven(this);§}§}§
public class LensOfClarity extends CardImpl {§public LensOfClarity(UUID ownerId) {§super(ownerId, 223, "Lens of Clarity", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "KTK";§this.addAbility(new LensOfClarityLookLibraryAbility());§this.addAbility(new LensOfClarityLookFaceDownAbility());§}§public LensOfClarity(final LensOfClarity card) {§super(card);§}§@Override§public LensOfClarity copy() {§return new LensOfClarity(this);§}§}§class LensOfClarityLookLibraryAbility extends ActivatedAbilityImpl {§public LensOfClarityLookLibraryAbility() {§super(Zone.BATTLEFIELD, new LensOfClarityLookLibraryEffect(), new GenericManaCost(0));§this.usesStack = false;§}§public LensOfClarityLookLibraryAbility(LensOfClarityLookLibraryAbility ability) {§super(ability);§}§@Override§public LensOfClarityLookLibraryAbility copy() {§return new LensOfClarityLookLibraryAbility(this);§}§}§class LensOfClarityLookLibraryEffect extends OneShotEffect {§public LensOfClarityLookLibraryEffect() {§super(Outcome.Neutral);§this.staticText = "You may look at the top card of your library";§}§public LensOfClarityLookLibraryEffect(final LensOfClarityLookLibraryEffect effect) {§super(effect);§}§@Override§public LensOfClarityLookLibraryEffect copy() {§return new LensOfClarityLookLibraryEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject mageObject = game.getObject(source.getSourceId());§if (controller == null || mageObject == null) {§return false;§}§Card card = controller.getLibrary().getFromTop(game);§if (card != null) {§Cards cards = new CardsImpl();§cards.add(card);§controller.lookAtCards("top card of library - " + controller.getName(), cards, game);§game.informPlayers(controller.getLogName() + " looks at the top card of his or her library");§} else {§return false;§}§return true;§}§}§class LensOfClarityLookFaceDownAbility extends ActivatedAbilityImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("face down creature you don't control");§static {§filter.add(new FaceDownPredicate());§filter.add(new ControllerPredicate(TargetController.NOT_YOU));§}§public LensOfClarityLookFaceDownAbility() {§super(Zone.BATTLEFIELD, new LensOfClarityLookFaceDownEffect(), new GenericManaCost(0));§this.usesStack = false;§this.addTarget(new TargetCreaturePermanent(filter));§}§public LensOfClarityLookFaceDownAbility(LensOfClarityLookFaceDownAbility ability) {§super(ability);§}§@Override§public LensOfClarityLookFaceDownAbility copy() {§return new LensOfClarityLookFaceDownAbility(this);§}§}§class LensOfClarityLookFaceDownEffect extends OneShotEffect {§public LensOfClarityLookFaceDownEffect() {§super(Outcome.Benefit);§this.staticText = "You may look at face-down creatures you don't control";§}§public LensOfClarityLookFaceDownEffect(final LensOfClarityLookFaceDownEffect effect) {§super(effect);§}§@Override§public LensOfClarityLookFaceDownEffect copy() {§return new LensOfClarityLookFaceDownEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller= game.getPlayer(source.getControllerId());§MageObject mageObject = game.getObject(source.getSourceId());§if (controller == null || mageObject == null) {§return false;§}§Permanent faceDownCreature = game.getPermanent(getTargetPointer().getFirst(game, source));§if (faceDownCreature != null) {§Permanent copyFaceDown = faceDownCreature.copy();§copyFaceDown.setFaceDown(false, game);§Cards cards = new CardsImpl();§cards.add(copyFaceDown);§Player player = game.getPlayer(faceDownCreature.getControllerId());§controller.lookAtCards("face down card - " + mageObject.getName(), cards, game);§if (player != null) {§game.informPlayers(controller.getLogName() + " looks at a face down creature of " + player.getLogName());§}§} else {§return false;§}§return true;§}§}§
public class MonasteryFlock extends CardImpl {§public MonasteryFlock(UUID ownerId) {§super(ownerId, 47, "Monastery Flock", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "KTK";§this.subtype.add("Bird");§this.power = new MageInt(0);§this.toughness = new MageInt(5);§this.addAbility(DefenderAbility.getInstance());§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new MorphAbility(this, new ManaCostsImpl("{U}")));§}§public MonasteryFlock(final MonasteryFlock card) {§super(card);§}§@Override§public MonasteryFlock copy() {§return new MonasteryFlock(this);§}§}§
public class RiteOfTheSerpent extends CardImpl {§public RiteOfTheSerpent(UUID ownerId) {§super(ownerId, 86, "Rite of the Serpent", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{4}{B}{B}");§this.expansionSetCode = "KTK";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new RiteOfTheSerpentEffect());§}§public RiteOfTheSerpent(final RiteOfTheSerpent card) {§super(card);§}§@Override§public RiteOfTheSerpent copy() {§return new RiteOfTheSerpent(this);§}§}§class RiteOfTheSerpentEffect extends OneShotEffect {§public RiteOfTheSerpentEffect() {§super(Outcome.Benefit);§this.staticText = "If that creature had a +1/+1 counter on it, put a 1/1 green Snake creature token onto the battlefield";§}§public RiteOfTheSerpentEffect(final RiteOfTheSerpentEffect effect) {§super(effect);§}§@Override§public RiteOfTheSerpentEffect copy() {§return new RiteOfTheSerpentEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent targetCreature = game.getPermanentOrLKIBattlefield(getTargetPointer().getFirst(game, source));§if (targetCreature != null) {§if (targetCreature.getCounters().containsKey(CounterType.P1P1)) {§new CreateTokenEffect(new SnakeToken("KTK")).apply(game, source);§}§return true;§}§return false;§}§}§
public class SecretPlans extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Face-down creatures you control");§static {§filter.add(new FaceDownPredicate());§}§public SecretPlans(UUID ownerId) {§super(ownerId, 198, "Secret Plans", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{G}{U}");§this.expansionSetCode = "KTK";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostControlledEffect(0,1, Duration.WhileOnBattlefield, filter)));§this.addAbility(new TurnedFaceUpAllTriggeredAbility(new DrawCardSourceControllerEffect(1), new FilterControlledPermanent()));§}§public SecretPlans(final SecretPlans card) {§super(card);§}§@Override§public SecretPlans copy() {§return new SecretPlans(this);§}§}§
public class SummitProwler extends CardImpl {§public SummitProwler(UUID ownerId) {§super(ownerId, 121, "Summit Prowler", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "KTK";§this.subtype.add("Yeti");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§}§public SummitProwler(final SummitProwler card) {§super(card);§}§@Override§public SummitProwler copy() {§return new SummitProwler(this);§}§}§
public class TrapEssence extends CardImpl {§private static final FilterSpell filter = new FilterSpell("creature spell");§static {§filter.add(new CardTypePredicate(CardType.CREATURE));§}§public TrapEssence(UUID ownerId) {§super(ownerId, 209, "Trap Essence", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{G}{U}{R}");§this.expansionSetCode = "KTK";§this.getSpellAbility().addEffect(new CounterTargetEffect());§this.getSpellAbility().addTarget(new TargetSpell(filter));§Effect effect = new AddCountersTargetEffect(CounterType.P1P1.createInstance(2));§effect.setText("Put two +1/+1 counters on up to one target creature");§effect.setTargetPointer(new SecondTargetPointer());§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCreaturePermanent(0,1));§}§public TrapEssence(final TrapEssence card) {§super(card);§}§@Override§public TrapEssence copy() {§return new TrapEssence(this);§}§}§
public class Winterflame extends CardImpl {§public Winterflame(UUID ownerId) {§super(ownerId, 213, "Winterflame", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{U}{R}");§this.expansionSetCode = "KTK";§this.getSpellAbility().getModes().setMinModes(1);§this.getSpellAbility().getModes().setMaxModes(2);§this.getSpellAbility().addEffect(new TapTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§Mode mode = new Mode();§mode.getEffects().add(new DamageTargetEffect(2));§mode.getTargets().add(new TargetCreaturePermanent());§this.getSpellAbility().addMode(mode);§}§public Winterflame(final Winterflame card) {§super(card);§}§@Override§public Winterflame copy() {§return new Winterflame(this);§}§}§
public class AmrouKithkin extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creatures with power 3 or greater");§static {§filter.add(new PowerPredicate(Filter.ComparisonType.GreaterThan, 2));§}§public AmrouKithkin(UUID ownerId) {§super(ownerId, 172, "Amrou Kithkin", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{W}{W}");§this.expansionSetCode = "LEG";§this.subtype.add("Kithkin");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SimpleEvasionAbility(new CantBeBlockedByCreaturesSourceEffect(filter, Duration.WhileOnBattlefield)));§}§public AmrouKithkin(final AmrouKithkin card) {§super(card);§}§@Override§public AmrouKithkin copy() {§return new AmrouKithkin(this);§}§}§
public class FlashFlood extends CardImpl {§private static final FilterPermanent filter1 = new FilterPermanent("red permanent");§private static final FilterPermanent filter2 = new FilterPermanent("Mountain");§static {§filter1.add(new ColorPredicate(ObjectColor.RED));§filter2.add(new SubtypePredicate("Mountain"));§}§public FlashFlood(UUID ownerId) {§super(ownerId, 57, "Flash Flood", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{U}");§this.expansionSetCode = "LEG";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addTarget(new TargetPermanent(filter1));§Mode mode = new Mode();§mode.getEffects().add(new ReturnToHandTargetEffect());§mode.getTargets().add(new TargetPermanent(filter2));§this.getSpellAbility().addMode(mode);§}§public FlashFlood(final FlashFlood card) {§super(card);§}§@Override§public FlashFlood copy() {§return new FlashFlood(this);§}§}§
public class KoboldsOfKherKeep extends CardImpl {§public KoboldsOfKherKeep(UUID ownerId) {§super(ownerId, 226, "Kobolds of Kher Keep", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{0}");§this.expansionSetCode = "LEG";§this.color.setRed(true);§this.subtype.add("Kobold");§this.power = new MageInt(0);§this.toughness = new MageInt(1);§}§public KoboldsOfKherKeep(final KoboldsOfKherKeep card) {§super(card);§}§@Override§public KoboldsOfKherKeep copy() {§return new KoboldsOfKherKeep(this);§}§}§
public class RelicBarrier extends CardImpl {§public RelicBarrier(UUID ownerId) {§super(ownerId, 237, "Relic Barrier", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "LEG";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TapTargetEffect(), new TapSourceCost());§ability.addTarget(new TargetArtifactPermanent());§this.addAbility(ability);§}§public RelicBarrier(final RelicBarrier card) {§super(card);§}§@Override§public RelicBarrier copy() {§return new RelicBarrier(this);§}§}§
public class Transmutation extends CardImpl {§public Transmutation(UUID ownerId) {§super(ownerId, 37, "Transmutation", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{B}");§this.expansionSetCode = "LEG";§this.getSpellAbility().addEffect(new SwitchPowerToughnessTargetEffect(Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public Transmutation(final Transmutation card) {§super(card);§}§@Override§public Transmutation copy() {§return new Transmutation(this);§}§}§
public class CanopyCrawler extends CardImpl {§public CanopyCrawler(UUID ownerId) {§super(ownerId, 122, "Canopy Crawler", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "LGN";§this.subtype.add("Beast");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new AmplifyAbility(AmplifyEffect.AmplifyFactor.Amplify1));§CountersCount count = new CountersCount(CounterType.P1P1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(count, count, Duration.EndOfTurn), new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public CanopyCrawler(final CanopyCrawler card) {§super(card);§}§@Override§public CanopyCrawler copy() {§return new CanopyCrawler(this);§}§}§
public class Glowrider extends CardImpl {§public Glowrider(UUID ownerId) {§super(ownerId, 15, "Glowrider", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "LGN";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GlowriderCostReductionEffect()));§}§public Glowrider(final Glowrider card) {§super(card);§}§@Override§public Glowrider copy() {§return new Glowrider(this);§}§}§class GlowriderCostReductionEffect extends CostModificationEffectImpl {§GlowriderCostReductionEffect ( ) {§super(Duration.WhileOnBattlefield, Outcome.Benefit, CostModificationType.INCREASE_COST);§staticText = "Noncreature spells cost {1} more to cast";§}§GlowriderCostReductionEffect(GlowriderCostReductionEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source, Ability abilityToModify) {§CardUtil.increaseCost(abilityToModify, 1);§return true;§}§@Override§public boolean applies(Ability abilityToModify, Ability source, Game game) {§if (abilityToModify instanceof SpellAbility || abilityToModify instanceof FlashbackAbility) {§Card card = game.getCard(abilityToModify.getSourceId());§if (card != null && !card.getCardType().contains(CardType.CREATURE)) {§return true;§}§}§return false;§}§@Override§public GlowriderCostReductionEffect copy() {§return new GlowriderCostReductionEffect(this);§}§}§
public class NantukoVigilante extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("artifact or enchantment");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.ARTIFACT),§new CardTypePredicate(CardType.ENCHANTMENT)));§}§public NantukoVigilante(UUID ownerId) {§super(ownerId, 132, "Nantuko Vigilante", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "LGN";§this.subtype.add("Insect");§this.subtype.add("Druid");§this.subtype.add("Mutant");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(new MorphAbility(this,new ManaCostsImpl("{1}{G}")));§Ability ability = new TurnedFaceUpSourceTriggeredAbility(new DestroyTargetEffect());§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§}§public NantukoVigilante(final NantukoVigilante card) {§super(card);§}§@Override§public NantukoVigilante copy() {§return new NantukoVigilante(this);§}§}§
public class SwoopingTalon extends CardImpl {§public SwoopingTalon(UUID ownerId) {§super(ownerId, 23, "Swooping Talon", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{W}{W}");§this.expansionSetCode = "LGN";§this.subtype.add("Bird");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(6);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new LoseAbilitySourceEffect(§FlyingAbility.getInstance(), Duration.EndOfTurn), new ManaCostsImpl("{1}")));§this.addAbility(new ProvokeAbility());§}§public SwoopingTalon(final SwoopingTalon card) {§super(card);§}§@Override§public SwoopingTalon copy() {§return new SwoopingTalon(this);§}§}§
public class Berserk extends CardImpl {§public Berserk(UUID ownerId) {§super(ownerId, 94, "Berserk", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{G}");§this.expansionSetCode = "LEA";§this.addAbility(new SimpleStaticAbility(Zone.ALL, new BerserkReplacementEffect()), new CombatDamageStepStartedWatcher());§Effect effect = new GainAbilityTargetEffect(TrampleAbility.getInstance(), Duration.EndOfTurn);§effect.setText("Target creature gains trample");§this.getSpellAbility().addEffect(effect);§effect = new BoostTargetEffect(new TargetPermanentPowerCount(), new StaticValue(0), Duration.EndOfTurn);§effect.setText("and gets +X/+0 until end of turn, where X is its power");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addEffect(new BerserkDestroyEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addWatcher(new AttackedThisTurnWatcher());§}§public Berserk(final Berserk card) {§super(card);§}§@Override§public Berserk copy() {§return new Berserk(this);§}§}§class BerserkReplacementEffect extends ContinuousRuleModifyingEffectImpl {§BerserkReplacementEffect() {§super(Duration.EndOfGame, Outcome.Detriment);§staticText = "Cast {this} only before the combat damage step";§}§BerserkReplacementEffect(final BerserkReplacementEffect effect) {§super(effect);§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (event.getType().equals(GameEvent.EventType.CAST_SPELL) && event.getSourceId().equals(source.getSourceId())) {§CombatDamageStepStartedWatcher watcher = (CombatDamageStepStartedWatcher) game.getState().getWatchers().get("CombatDamageStepStarted");§return watcher == null || watcher.conditionMet();§}§return false;§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public BerserkReplacementEffect copy() {§return new BerserkReplacementEffect(this);§}§}§class CombatDamageStepStartedWatcher extends Watcher {§public CombatDamageStepStartedWatcher() {§super("CombatDamageStepStarted", WatcherScope.GAME);§}§public CombatDamageStepStartedWatcher(final CombatDamageStepStartedWatcher watcher) {§super(watcher);§}§@Override§public void watch(GameEvent event, Game game) {§if (event.getType() == GameEvent.EventType.COMBAT_DAMAGE_STEP_PRE || event.getType() == GameEvent.EventType.END_COMBAT_STEP_PRE) {§condition = true;§}§}§@Override§public CombatDamageStepStartedWatcher copy() {§return new CombatDamageStepStartedWatcher(this);§}§}§class BerserkDestroyEffect extends OneShotEffect {§public BerserkDestroyEffect() {§super(Outcome.Benefit);§this.staticText = "At the beginning of the next end step, destroy that creature if it attacked this turn";§}§public BerserkDestroyEffect(final BerserkDestroyEffect effect) {§super(effect);§}§@Override§public BerserkDestroyEffect copy() {§return new BerserkDestroyEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Effect effect = new BerserkDelayedDestroyEffect();§effect.setTargetPointer(new FixedTarget(this.getTargetPointer().getFirst(game, source)));§AtTheBeginOfNextEndStepDelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(effect);§game.addDelayedTriggeredAbility(delayedAbility, source);§return true;§}§return false;§}§}§class BerserkDelayedDestroyEffect extends OneShotEffect {§public BerserkDelayedDestroyEffect() {§super(Outcome.Benefit);§this.staticText = "destroy that creature if it attacked this turn";§}§public BerserkDelayedDestroyEffect(final BerserkDelayedDestroyEffect effect) {§super(effect);§}§@Override§public BerserkDelayedDestroyEffect copy() {§return new BerserkDelayedDestroyEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Permanent permanent = game.getPermanent(this.getTargetPointer().getFirst(game, source));§if (permanent != null) {§Watcher watcher = game.getState().getWatchers().get("AttackedThisTurn");§if (watcher != null && watcher instanceof AttackedThisTurnWatcher) {§if (((AttackedThisTurnWatcher) watcher).getAttackedThisTurnCreatures().contains(permanent.getId())) {§return permanent.destroy(source.getSourceId(), game, false);§}§}§}§}§return false;§}§}§
public class DrainLife extends CardImpl {§public static final FilterMana filterBlack = new FilterMana();§static {§filterBlack.setBlack(true);§}§public DrainLife(UUID ownerId) {§super(ownerId, 14, "Drain Life", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{X}{1}{B}");§this.expansionSetCode = "LEA";§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§this.getSpellAbility().addEffect(new DrainLifeEffect());§VariableCost variableCost = this.getSpellAbility().getManaCostsToPay().getVariableCosts().get(0);§if (variableCost instanceof VariableManaCost) {§((VariableManaCost) variableCost).setFilter(filterBlack);§}§}§public DrainLife(final DrainLife card) {§super(card);§}§@Override§public DrainLife copy() {§return new DrainLife(this);§}§}§class DrainLifeEffect extends OneShotEffect {§public DrainLifeEffect() {§super(Outcome.Damage);§staticText = "Drain Life deals X damage to target creature or player. You gain life equal to the damage dealt, but not more life than the player's life total before Drain Life dealt damage or the creature's toughness.";§}§public DrainLifeEffect(final DrainLifeEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§int amount = source.getManaCostsToPay().getX();§int lifetogain = amount;§if (amount > 0) {§Permanent permanent = game.getPermanent(getTargetPointer().getFirst(game, source));§if (permanent != null ) {§if (permanent.getToughness().getValue() < amount) {§lifetogain = permanent.getToughness().getValue();§}§permanent.damage(amount, source.getSourceId(), game, false, true);§} else {§Player player = game.getPlayer(getTargetPointer().getFirst(game, source));§if (player != null) {§if (player.getLife() < amount) {§lifetogain = player.getLife();§}§player.damage(amount, source.getSourceId(), game, false, true);§} else {§return false;§}§}§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§controller.gainLife(lifetogain, game);§} else {§return false;§}§}§return true;§}§@Override§public DrainLifeEffect copy() {§return new DrainLifeEffect(this);§}§}§
public class LivingLands extends CardImpl {§private static final FilterLandPermanent filter = new FilterLandPermanent("All Forests");§static {§filter.add(new SubtypePredicate("Forest"));§}§public LivingLands(UUID ownerId) {§super(ownerId, 118, "Living Lands", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{3}{G}");§this.expansionSetCode = "LEA";§ContinuousEffect effect = new BecomesCreatureAllEffect(new LivingLandsToken(), "lands", filter, Duration.WhileOnBattlefield);§effect.getDependencyTypes().add(DependencyType.BecomeForest);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§}§public LivingLands(final LivingLands card) {§super(card);§}§@Override§public LivingLands copy() {§return new LivingLands(this);§}§}§class LivingLandsToken extends Token {§public LivingLandsToken() {§super("", "1/1 creature");§cardType.add(CardType.CREATURE);§power = new MageInt(1);§toughness = new MageInt(1);§}§}§
public class RedElementalBlast extends CardImpl {§private static final FilterPermanent filterPermanent = new FilterPermanent("blue permanent");§private static final FilterSpell filterSpell = new FilterSpell("blue spell");§static{§filterPermanent.add(new ColorPredicate(ObjectColor.BLUE));§filterSpell.add(new ColorPredicate(ObjectColor.BLUE));§}§public RedElementalBlast(UUID ownerId) {§super(ownerId, 170, "Red Elemental Blast", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{R}");§this.expansionSetCode = "LEA";§this.getSpellAbility().addEffect(new CounterTargetEffect());§this.getSpellAbility().addTarget(new TargetSpell(filterSpell));§Mode mode = new Mode();§mode.getEffects().add(new DestroyTargetEffect());§mode.getTargets().add(new TargetPermanent(filterPermanent));§this.getSpellAbility().addMode(mode);§}§public RedElementalBlast(final RedElementalBlast card) {§super(card);§}§@Override§public RedElementalBlast copy() {§return new RedElementalBlast(this);§}§}§
public class Tundra extends CardImpl {§public Tundra(UUID ownerId) {§super(ownerId, 294, "Tundra", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "LEA";§this.subtype.add("Plains");§this.subtype.add("Island");§this.addAbility(new WhiteManaAbility());§this.addAbility(new BlueManaAbility());§}§public Tundra(final Tundra card) {§super(card);§}§@Override§public Tundra copy() {§return new Tundra(this);§}§}§
public class AncientAmphitheater extends CardImpl {§private static final FilterCard filter = new FilterCard("a Giant from your hand");§static {§filter.add(new SubtypePredicate("Giant"));§}§public AncientAmphitheater(UUID ownerId) {§super(ownerId, 266, "Ancient Amphitheater", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "LRW";§this.addAbility(new AsEntersBattlefieldAbility(new TapSourceUnlessPaysEffect(new RevealTargetFromHandCost(new TargetCardInHand(filter))), "you may reveal a Giant card from your hand. If you don't, {this} enters the battlefield tapped"));§this.addAbility(new RedManaAbility());§this.addAbility(new WhiteManaAbility());§}§public AncientAmphitheater(final AncientAmphitheater card) {§super(card);§}§@Override§public AncientAmphitheater copy() {§return new AncientAmphitheater(this);§}§}§
public class BrigidHeroOfKinsbaile extends CardImpl {§public BrigidHeroOfKinsbaile(UUID ownerId) {§super(ownerId, 6, "Brigid, Hero of Kinsbaile", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{W}{W}");§this.expansionSetCode = "LRW";§this.supertype.add("Legendary");§this.subtype.add("Kithkin");§this.subtype.add("Archer");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(FirstStrikeAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BrigidHeroOfKinsbaileEffect(), new TapSourceCost());§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public BrigidHeroOfKinsbaile(final BrigidHeroOfKinsbaile card) {§super(card);§}§@Override§public BrigidHeroOfKinsbaile copy() {§return new BrigidHeroOfKinsbaile(this);§}§}§class BrigidHeroOfKinsbaileEffect extends OneShotEffect {§public BrigidHeroOfKinsbaileEffect() {§super(Outcome.Damage);§staticText = "{this} deals 2 damage to each attacking or blocking creature target player controls";§}§public BrigidHeroOfKinsbaileEffect(final BrigidHeroOfKinsbaileEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player targetPlayer = game.getPlayer(getTargetPointer().getFirst(game, source));§if (targetPlayer != null) {§for (Permanent creature : game.getBattlefield().getAllActivePermanents(new FilterAttackingOrBlockingCreature(), targetPlayer.getId(), game)) {§creature.damage(2, source.getSourceId(), game, false, true);§}§return true;§}§return false;§}§@Override§public BrigidHeroOfKinsbaileEffect copy() {§return new BrigidHeroOfKinsbaileEffect(this);§}§}§
public class DoranTheSiegeTower extends CardImpl {§public DoranTheSiegeTower(UUID ownerId) {§super(ownerId, 247, "Doran, the Siege Tower", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{B}{G}{W}");§this.expansionSetCode = "LRW";§this.supertype.add("Legendary");§this.subtype.add("Treefolk");§this.subtype.add("Shaman");§this.power = new MageInt(0);§this.toughness = new MageInt(5);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new DoranTheSiegeTowerCombatDamageRuleEffect()));§}§public DoranTheSiegeTower(final DoranTheSiegeTower card) {§super(card);§}§@Override§public DoranTheSiegeTower copy() {§return new DoranTheSiegeTower(this);§}§}§class DoranTheSiegeTowerCombatDamageRuleEffect extends ContinuousEffectImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent();§public DoranTheSiegeTowerCombatDamageRuleEffect() {§super(Duration.WhileOnBattlefield, Outcome.Detriment);§staticText = "Each creature assigns combat damage equal to its toughness rather than its power";§}§public DoranTheSiegeTowerCombatDamageRuleEffect(final DoranTheSiegeTowerCombatDamageRuleEffect effect) {§super(effect);§}§@Override§public DoranTheSiegeTowerCombatDamageRuleEffect copy() {§return new DoranTheSiegeTowerCombatDamageRuleEffect(this);§}§@Override§public boolean apply(Layer layer, SubLayer sublayer, Ability source, Game game) {§game.getCombat().setUseToughnessForDamage(true);§game.getCombat().addUseToughnessForDamageFilter(filter);§return true;§}§@Override§public boolean apply(Game game, Ability source) {§return false;§}§@Override§public boolean hasLayer(Layer layer) {§return layer == Layer.RulesEffects;§}§}§
public class FinalRevels extends CardImpl {§public FinalRevels(UUID ownerId) {§super(ownerId, 113, "Final Revels", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{4}{B}");§this.expansionSetCode = "LRW";§this.getSpellAbility().addEffect(new BoostAllEffect(2, 0, Duration.EndOfTurn, new FilterCreaturePermanent(), false));§Mode mode = new Mode();§mode.getEffects().add(new BoostAllEffect(0, -2, Duration.EndOfTurn, new FilterCreaturePermanent(), false));§this.getSpellAbility().addMode(mode);§}§public FinalRevels(final FinalRevels card) {§super(card);§}§@Override§public FinalRevels copy() {§return new FinalRevels(this);§}§}§
public class HarpoonSniper extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("Merfolk you control");§static {§filter.add(new SubtypePredicate("Merfolk"));§}§public HarpoonSniper(UUID ownerId) {§super(ownerId, 19, "Harpoon Sniper", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "LRW";§this.subtype.add("Merfolk");§this.subtype.add("Archer");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(new PermanentsOnBattlefieldCount(filter)), new ColoredManaCost(ColoredManaSymbol.W));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetAttackingOrBlockingCreature());§this.addAbility(ability);§}§public HarpoonSniper(final HarpoonSniper card) {§super(card);§}§@Override§public HarpoonSniper copy() {§return new HarpoonSniper(this);§}§}§
public class KinsbaileSkirmisher extends CardImpl {§public KinsbaileSkirmisher(UUID ownerId) {§super(ownerId, 24, "Kinsbaile Skirmisher", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "LRW";§this.subtype.add("Kithkin");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new EntersBattlefieldTriggeredAbility(new BoostTargetEffect(1, 1, Duration.EndOfTurn), false);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public KinsbaileSkirmisher(final KinsbaileSkirmisher card) {§super(card);§}§@Override§public KinsbaileSkirmisher copy() {§return new KinsbaileSkirmisher(this);§}§}§
public class MudbuttonTorchrunner extends CardImpl {§public MudbuttonTorchrunner(UUID ownerId) {§super(ownerId, 185, "Mudbutton Torchrunner", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "LRW";§this.subtype.add("Goblin");§this.subtype.add("Warrior");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new DiesTriggeredAbility(new DamageTargetEffect(3), false);§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public MudbuttonTorchrunner(final MudbuttonTorchrunner card) {§super(card);§}§@Override§public MudbuttonTorchrunner copy() {§return new MudbuttonTorchrunner(this);§}§}§
public class Rootgrapple extends CardImpl {§private static final FilterPermanent filterNoncreature = new FilterPermanent("noncreature permanent");§private static final FilterPermanent filterTreefolk = new FilterPermanent("If you control a Treefolk,");§static {§filterNoncreature.add(Predicates.not(new CardTypePredicate(CardType.CREATURE)));§filterTreefolk.add(new SubtypePredicate("Treefolk"));§}§public Rootgrapple(UUID ownerId) {§super(ownerId, 234, "Rootgrapple", Rarity.COMMON, new CardType[]{CardType.TRIBAL, CardType.INSTANT}, "{4}{G}");§this.expansionSetCode = "LRW";§this.subtype.add("Treefolk");§this.getSpellAbility().addTarget(new TargetPermanent(filterNoncreature));§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addEffect(new ConditionalOneShotEffect(new DrawCardSourceControllerEffect(1),§new PermanentsOnTheBattlefieldCondition(filterTreefolk, PermanentsOnTheBattlefieldCondition.CountType.MORE_THAN, 0),§"If you control a Treefolk, draw a card"));§}§public Rootgrapple(final Rootgrapple card) {§super(card);§}§@Override§public Rootgrapple copy() {§return new Rootgrapple(this);§}§}§
public class StreambedAquitects extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Merfolk creature");§static {§filter.add(new SubtypePredicate("Merfolk"));§}§public StreambedAquitects(UUID ownerId) {§super(ownerId, 91, "Streambed Aquitects", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{U}{U}");§this.expansionSetCode = "LRW";§this.subtype.add("Merfolk");§this.subtype.add("Scout");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(1,1, Duration.EndOfTurn), new TapSourceCost());§ability.addEffect(new GainAbilityTargetEffect(new IslandwalkAbility(false), Duration.EndOfTurn));§Target target = new TargetCreaturePermanent(filter);§ability.addTarget(target);§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BecomesBasicLandTargetEffect(Duration.EndOfTurn, "Island"), new TapSourceCost());§target = new TargetLandPermanent();§ability.addTarget(target);§this.addAbility(ability);§}§public StreambedAquitects(final StreambedAquitects card) {§super(card);§}§@Override§public StreambedAquitects copy() {§return new StreambedAquitects(this);§}§}§
public class VividMarsh extends CardImpl {§public VividMarsh(UUID ownerId) {§super(ownerId, 278, "Vivid Marsh", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "LRW";§Ability ability = new EntersBattlefieldAbility(new TapSourceEffect(true), false, null, "{this} enters the battlefield tapped with two charge counters on it", null);§ability.addEffect(new AddCountersSourceEffect(CounterType.CHARGE.createInstance(2)));§this.addAbility(ability);§this.addAbility(new BlackManaAbility());§ability = new AnyColorManaAbility();§ability.addCost(new RemoveCountersSourceCost(CounterType.CHARGE.createInstance(1)));§this.addAbility(ability);§}§public VividMarsh(final VividMarsh card) {§super(card);§}§@Override§public VividMarsh copy() {§return new VividMarsh(this);§}§}§
public class AirElemental extends CardImpl {§public AirElemental(UUID ownerId) {§super(ownerId, 42, "Air Elemental", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{U}{U}");§this.expansionSetCode = "M10";§this.subtype.add("Elemental");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§}§public AirElemental(final AirElemental card) {§super(card);§}§@Override§public AirElemental copy() {§return new AirElemental(this);§}§}§
public class CentaurCourser extends CardImpl {§public CentaurCourser(UUID ownerId) {§super(ownerId, 172, "Centaur Courser", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "M10";§this.subtype.add("Centaur");§this.subtype.add("Warrior");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§}§public CentaurCourser(final CentaurCourser card) {§super(card);§}§@Override§public CentaurCourser copy() {§return new CentaurCourser(this);§}§}§
public class Earthquake extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature without flying");§static {§filter.add(Predicates.not(new AbilityPredicate(FlyingAbility.class)));§}§public Earthquake(UUID ownerId) {§super(ownerId, 134, "Earthquake", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{X}{R}");§this.expansionSetCode = "M10";§this.getSpellAbility().addEffect(new DamageEverythingEffect(new ManacostVariableValue(), filter));§}§public Earthquake(final Earthquake card) {§super(card);§}§@Override§public Earthquake copy() {§return new Earthquake(this);§}§}§
public class GriffinSentinel extends CardImpl {§public GriffinSentinel(UUID ownerId) {§super(ownerId, 12, "Griffin Sentinel", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "M10";§this.subtype.add("Griffin");§this.addAbility(FlyingAbility.getInstance());§this.addAbility(VigilanceAbility.getInstance());§this.power = new MageInt(1);§this.toughness = new MageInt(3);§}§public GriffinSentinel(final GriffinSentinel card) {§super(card);§}§@Override§public GriffinSentinel copy() {§return new GriffinSentinel(this);§}§}§
public class KelinoreBat extends CardImpl {§public KelinoreBat(UUID ownerId) {§super(ownerId, 101, "Kelinore Bat", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "M10";§this.subtype.add("Bat");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§}§public KelinoreBat(final KelinoreBat card) {§super(card);§}§@Override§public KelinoreBat copy() {§return new KelinoreBat(this);§}§}§
public class Negate extends CardImpl {§private static final FilterSpell filter = new FilterSpell("noncreature spell");§static {§filter.add(Predicates.not(new CardTypePredicate(CardType.CREATURE)));§}§public Negate(UUID ownerId) {§super(ownerId, 65, "Negate", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "M10";§this.getSpellAbility().addTarget(new TargetSpell(filter));§this.getSpellAbility().addEffect(new CounterTargetEffect());§}§public Negate(final Negate card) {§super(card);§}§@Override§public Negate copy() {§return new Negate(this);§}§}§
public class SageOwl extends CardImpl {§public SageOwl(UUID ownerId) {§super(ownerId, 69, "Sage Owl", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "M10";§this.subtype.add("Bird");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new LookLibraryControllerEffect(4)));§}§public SageOwl(final SageOwl card) {§super(card);§}§@Override§public SageOwl copy() {§return new SageOwl(this);§}§}§
public class TempestOfLight extends CardImpl {§public TempestOfLight(UUID ownerId) {§super(ownerId, 36, "Tempest of Light", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{2}{W}");§this.expansionSetCode = "M10";§this.getSpellAbility().addEffect(new TempestOfLightEffect());§}§public TempestOfLight(final TempestOfLight card) {§super(card);§}§@Override§public TempestOfLight copy() {§return new TempestOfLight(this);§}§}§class TempestOfLightEffect extends OneShotEffect {§private static final FilterPermanent filter = new FilterPermanent("");§static {§filter.add(new CardTypePredicate(CardType.ENCHANTMENT));§}§public TempestOfLightEffect() {§super(Outcome.DestroyPermanent);§staticText = "Destroy all enchantments";§}§public TempestOfLightEffect(final TempestOfLightEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§for (Permanent permanent : game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game)) {§permanent.destroy(source.getSourceId(), game, false);§}§return true;§}§@Override§public TempestOfLightEffect copy() {§return new TempestOfLightEffect(this);§}§}§
public class WindDrake extends CardImpl {§public WindDrake(UUID ownerId) {§super(ownerId, 81, "Wind Drake", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "M10";§this.subtype.add("Drake");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§}§public WindDrake(final WindDrake card) {§super(card);§}§@Override§public WindDrake copy() {§return new WindDrake(this);§}§}§
public class BloodTithe extends CardImpl {§public BloodTithe(UUID ownerId) {§super(ownerId, 84, "Blood Tithe", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{3}{B}");§this.expansionSetCode = "M11";§this.getSpellAbility().addEffect(new BloodTitheEffect());§}§public BloodTithe(final BloodTithe card) {§super(card);§}§@Override§public BloodTithe copy() {§return new BloodTithe(this);§}§}§class BloodTitheEffect extends OneShotEffect {§public BloodTitheEffect() {§super(Outcome.Damage);§staticText = "Each opponent loses 3 life. You gain life equal to the life lost this way";§}§public BloodTitheEffect(final BloodTitheEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§int damage = 0;§for (UUID opponentId: game.getOpponents(source.getControllerId())) {§damage += game.getPlayer(opponentId).damage(3, source.getSourceId(), game, false, true);§}§game.getPlayer(source.getControllerId()).gainLife(damage, game);§return true;§}§@Override§public BloodTitheEffect copy() {§return new BloodTitheEffect(this);§}§}§
public class DuskdaleWurm extends CardImpl {§public DuskdaleWurm(UUID ownerId) {§super(ownerId, 170, "Duskdale Wurm", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{5}{G}{G}");§this.expansionSetCode = "M11";§this.subtype.add("Wurm");§this.power = new MageInt(7);§this.toughness = new MageInt(7);§this.addAbility(TrampleAbility.getInstance());§}§public DuskdaleWurm(final DuskdaleWurm card) {§super(card);§}§@Override§public DuskdaleWurm copy() {§return new DuskdaleWurm(this);§}§}§
public class HuntersFeast extends CardImpl {§public HuntersFeast(UUID ownerId) {§super(ownerId, 182, "Hunters' Feast", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{3}{G}");§this.expansionSetCode = "M11";§this.getSpellAbility().addTarget(new TargetPlayer(0, Integer.MAX_VALUE, false));§this.getSpellAbility().addEffect(new GainLifeTargetEffect(6));§}§public HuntersFeast(final HuntersFeast card) {§super(card);§}§@Override§public HuntersFeast copy() {§return new HuntersFeast(this);§}§}§
public class MerfolkSpy extends CardImpl {§public MerfolkSpy(UUID ownerId) {§super(ownerId, 66, "Merfolk Spy", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{U}");§this.expansionSetCode = "M11";§this.subtype.add("Merfolk");§this.subtype.add("Rogue");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new IslandwalkAbility());§this.addAbility(new DealsCombatDamageToAPlayerTriggeredAbility(new MerfolkSpyEffect(), false, true));§}§public MerfolkSpy(final MerfolkSpy card) {§super(card);§}§@Override§public MerfolkSpy copy() {§return new MerfolkSpy(this);§}§}§class MerfolkSpyEffect extends OneShotEffect {§public MerfolkSpyEffect() {§super(Outcome.Detriment);§staticText = "that player reveals a card at random from his or her hand";§}§public MerfolkSpyEffect(final MerfolkSpyEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(targetPointer.getFirst(game, source));§if (player != null && player.getHand().size() > 0) {§Cards revealed = new CardsImpl();§revealed.add(player.getHand().getRandom(game));§player.revealCards("Merfolk Spy", revealed, game);§return true;§}§return false;§}§@Override§public MerfolkSpyEffect copy() {§return new MerfolkSpyEffect(this);§}§}§
public class Reverberate extends CardImpl {§private static final FilterSpell filter = new FilterSpell();§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.INSTANT),§new CardTypePredicate(CardType.SORCERY)));§}§public Reverberate(UUID ownerId) {§super(ownerId, 155, "Reverberate", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{R}{R}");§this.expansionSetCode = "M11";§this.getSpellAbility().addTarget(new TargetSpell(filter));§this.getSpellAbility().addEffect(new CopyTargetSpellEffect());§}§public Reverberate(final Reverberate card) {§super(card);§}§@Override§public Reverberate copy() {§return new Reverberate(this);§}§}§
public class Triskelion extends CardImpl {§public Triskelion(UUID ownerId) {§super(ownerId, 218, "Triskelion", Rarity.RARE, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{6}");§this.expansionSetCode = "M11";§this.subtype.add("Construct");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new EntersBattlefieldAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance(3)), "with three +1/+1 counters on it"));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new RemoveCountersSourceCost(CounterType.P1P1.createInstance()));§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public Triskelion(final Triskelion card) {§super(card);§}§@Override§public Triskelion copy() {§return new Triskelion(this);§}§}§
public class ArmoredWarhorse extends CardImpl {§public ArmoredWarhorse(UUID ownerId) {§super(ownerId, 7, "Armored Warhorse", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{W}{W}");§this.expansionSetCode = "M12";§this.subtype.add("Horse");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§}§public ArmoredWarhorse(final ArmoredWarhorse card) {§super(card);§}§@Override§public ArmoredWarhorse copy() {§return new ArmoredWarhorse(this);§}§}§
public class CrumblingColossus extends CardImpl {§public CrumblingColossus(UUID ownerId) {§super(ownerId, 204, "Crumbling Colossus", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{5}");§this.expansionSetCode = "M12";§this.subtype.add("Golem");§this.power = new MageInt(7);§this.toughness = new MageInt(4);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new AttacksTriggeredAbility(new CreateDelayedTriggeredAbilityEffect(new AtTheEndOfCombatDelayedTriggeredAbility(new SacrificeSourceEffect())), false));§}§public CrumblingColossus(final CrumblingColossus card) {§super(card);§}§@Override§public CrumblingColossus copy() {§return new CrumblingColossus(this);§}§}§
public class GoblinFireslinger extends CardImpl {§public GoblinFireslinger(UUID ownerId) {§super(ownerId, 139, "Goblin Fireslinger", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "M12";§this.subtype.add("Goblin");§this.subtype.add("Warrior");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new TapSourceCost());§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public GoblinFireslinger(final GoblinFireslinger card) {§super(card);§}§@Override§public GoblinFireslinger copy() {§return new GoblinFireslinger(this);§}§}§
public class MerfolkLooter extends CardImpl {§public MerfolkLooter(UUID ownerId) {§super(ownerId, 65, "Merfolk Looter", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "M12";§this.subtype.add("Merfolk");§this.subtype.add("Rogue");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawDiscardControllerEffect(), new TapSourceCost()));§}§public MerfolkLooter(final MerfolkLooter card) {§super(card);§}§@Override§public MerfolkLooter copy() {§return new MerfolkLooter(this);§}§}§
public class SkywinderDrake extends CardImpl {§public SkywinderDrake(UUID ownerId) {§super(ownerId, 75, "Skywinder Drake", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "M12";§this.subtype.add("Drake");§this.power = new MageInt(3);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new CanBlockOnlyFlyingAbility());§}§public SkywinderDrake(final SkywinderDrake card) {§super(card);§}§@Override§public SkywinderDrake copy() {§return new SkywinderDrake(this);§}§}§
public class TitanicGrowth extends CardImpl {§public TitanicGrowth(UUID ownerId) {§super(ownerId, 198, "Titanic Growth", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{G}");§this.expansionSetCode = "M12";§this.getSpellAbility().addEffect(new BoostTargetEffect(4, 4, Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public TitanicGrowth(final TitanicGrowth card) {§super(card);§}§@Override§public TitanicGrowth copy() {§return new TitanicGrowth(this);§}§}§
public class AttendedKnight extends CardImpl {§public AttendedKnight(UUID ownerId) {§super(ownerId, 5, "Attended Knight", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "M13";§this.subtype.add("Human");§this.subtype.add("Knight");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§}§@Override§public void build() {§this.addAbility(FirstStrikeAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new CreateTokenEffect(new SoldierToken())));§}§public AttendedKnight(final AttendedKnight card) {§super(card);§}§@Override§public AttendedKnight copy() {§return new AttendedKnight(this);§}§}§
public class DiscipleOfBolas extends CardImpl {§public DiscipleOfBolas(UUID ownerId) {§super(ownerId, 88, "Disciple of Bolas", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{B}");§this.expansionSetCode = "M13";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new EntersBattlefieldTriggeredAbility(new DiscipleOfBolasEffect()));§}§public DiscipleOfBolas(final DiscipleOfBolas card) {§super(card);§}§@Override§public DiscipleOfBolas copy() {§return new DiscipleOfBolas(this);§}§}§class DiscipleOfBolasEffect extends OneShotEffect {§public DiscipleOfBolasEffect() {§super(Outcome.Benefit);§this.staticText = "sacrifice another creature. You gain X life and draw X cards, where X is that creature's power";§}§public DiscipleOfBolasEffect(final DiscipleOfBolasEffect effect) {§super(effect);§}§@Override§public DiscipleOfBolasEffect copy() {§return new DiscipleOfBolasEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("another creature");§filter.add(new AnotherPredicate());§Target target = new TargetControlledCreaturePermanent(1,1, filter, true);§target.setRequired(true);§if (target.canChoose(source.getSourceId(), source.getControllerId(), game)) {§controller.chooseTarget(outcome, target, source, game);§Permanent sacrificed = game.getPermanent(target.getFirstTarget());§if (sacrificed != null) {§sacrificed.sacrifice(source.getSourceId(), game);§int power = sacrificed.getPower().getValue();§controller.gainLife(power, game);§controller.drawCards(power, game);§}§}§return true;§}§return false;§}§}§
public class GuardianLions extends CardImpl {§public GuardianLions(UUID ownerId) {§super(ownerId, 17, "Guardian Lions", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{W}");§this.expansionSetCode = "M13";§this.subtype.add("Cat");§this.power = new MageInt(1);§this.toughness = new MageInt(6);§this.addAbility(VigilanceAbility.getInstance());§}§public GuardianLions(final GuardianLions card) {§super(card);§}§@Override§public GuardianLions copy() {§return new GuardianLions(this);§}§}§
public class Mutilate extends CardImpl {§private static final String ruleText = "All creatures get -1/-1 until end of turn for each Swamp you control";§private static final FilterLandPermanent filter = new FilterLandPermanent("Swamp you control");§static {§filter.add(new SubtypePredicate("Swamp"));§filter.add(new ControllerPredicate(TargetController.YOU));§}§public Mutilate(UUID ownerId) {§super(ownerId, 102, "Mutilate", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{2}{B}{B}");§this.expansionSetCode = "M13";§PermanentsOnBattlefieldCount count = new PermanentsOnBattlefieldCount(filter, -1);§ContinuousEffect effect = new BoostAllEffect(count, count, Duration.EndOfTurn, new FilterCreaturePermanent(), false, null, true);§effect.overrideRuleText(ruleText);§this.getSpellAbility().addEffect(effect);§}§public Mutilate(final Mutilate card) {§super(card);§}§@Override§public Mutilate copy() {§return new Mutilate(this);§}§}§
public class RummagingGoblin extends CardImpl {§public RummagingGoblin(UUID ownerId) {§super(ownerId, 146, "Rummaging Goblin", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "M13";§this.subtype.add("Goblin");§this.subtype.add("Rogue");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1), new TapSourceCost());§ability.addCost(new DiscardTargetCost(new TargetCardInHand()));§this.addAbility(ability);§}§public RummagingGoblin(final RummagingGoblin card) {§super(card);§}§@Override§public RummagingGoblin copy() {§return new RummagingGoblin(this);§}§}§
public class TouchOfTheEternal extends CardImpl {§public TouchOfTheEternal(UUID ownerId) {§super(ownerId, 37, "Touch of the Eternal", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{5}{W}{W}");§this.expansionSetCode = "M13";§this.addAbility(new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new TouchOfTheEternalEffect(), TargetController.YOU, false));§}§public TouchOfTheEternal(final TouchOfTheEternal card) {§super(card);§}§@Override§public TouchOfTheEternal copy() {§return new TouchOfTheEternal(this);§}§}§class TouchOfTheEternalEffect extends OneShotEffect {§public TouchOfTheEternalEffect() {§super(Outcome.Neutral);§this.staticText = "count the number of permanents you control. Your life total becomes that number";§}§public TouchOfTheEternalEffect(final TouchOfTheEternalEffect effect) {§super(effect);§}§@Override§public TouchOfTheEternalEffect copy() {§return new TouchOfTheEternalEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§FilterControlledPermanent filter = new FilterControlledPermanent();§Player player = game.getPlayer(source.getControllerId());§int permanentsInPlay = game.getBattlefield().countAll(filter, source.getControllerId(), game);§if (player != null) {§player.setLife(permanentsInPlay, game);§return true;§}§return false;§}§}§
public class AngelicAccord extends CardImpl {§public AngelicAccord(UUID ownerId) {§super(ownerId, 3, "Angelic Accord", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{3}{W}");§this.expansionSetCode = "M14";§this.addAbility(new BeginningOfEndStepTriggeredAbility(Zone.BATTLEFIELD, new CreateTokenEffect(new AngelToken()), TargetController.ANY, new YouGainedLifeCondition(Condition.ComparisonType.GreaterThan, 3), false), new PlayerGainedLifeWatcher());§}§public AngelicAccord(final AngelicAccord card) {§super(card);§}§@Override§public AngelicAccord copy() {§return new AngelicAccord(this);§}§}§class YouGainedLifeCondition extends IntCompareCondition {§public YouGainedLifeCondition(Condition.ComparisonType type, int value) {§super(type, value);§}§@Override§protected int getInputValue(Game game, Ability source) {§int gainedLife = 0;§PlayerGainedLifeWatcher watcher = (PlayerGainedLifeWatcher) game.getState().getWatchers().get("PlayerGainedLifeWatcher");§if (watcher != null) {§gainedLife = watcher.getLiveGained(source.getControllerId());§}§return gainedLife;§}§@Override§public String toString() {§return "if you gained 4 or more life this turn ";§}§}§
public class DarkProphecy extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("a creature you control");§static {§filter.add(new ControllerPredicate(TargetController.YOU));§}§public DarkProphecy(UUID ownerId) {§super(ownerId, 93, "Dark Prophecy", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{B}{B}{B}");§this.expansionSetCode = "M14";§Effect effect = new DrawCardSourceControllerEffect(1);§effect.setText("you draw a card");§Ability ability = new DiesCreatureTriggeredAbility(effect, false, filter);§effect = new LoseLifeSourceControllerEffect(1);§effect.setText("and you lose 1 life");§ability.addEffect(effect);§this.addAbility(ability);§}§public DarkProphecy(final DarkProphecy card) {§super(card);§}§@Override§public DarkProphecy copy() {§return new DarkProphecy(this);§}§}§
public class GrimReturn extends CardImpl {§private static final String textFilter = "creature card in a graveyard that was put there from the battlefield this turn";§public GrimReturn(UUID ownerId) {§super(ownerId, 100, "Grim Return", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{2}{B}");§this.expansionSetCode = "M14";§Effect effect = new ReturnFromGraveyardToBattlefieldTargetEffect();§effect.setText("Choose target creature card in a graveyard that was put there from the battlefield this turn. Put that card onto the battlefield under your control");§this.getSpellAbility().addEffect(new ReturnFromGraveyardToBattlefieldTargetEffect());§this.getSpellAbility().addTarget(new TargetCardInGraveyard(new FilterCreatureCard(textFilter)));§this.getSpellAbility().addWatcher(new CardsPutIntoGraveyardWatcher());§}§public GrimReturn(final GrimReturn card) {§super(card);§}§@Override§public GrimReturn copy() {§return new GrimReturn(this);§}§@Override§public void adjustTargets(Ability ability, Game game) {§CardsPutIntoGraveyardWatcher watcher = (CardsPutIntoGraveyardWatcher) game.getState().getWatchers().get("CardsPutIntoGraveyardWatcher");§if (watcher != null) {§FilterCard filter = new FilterCreatureCard(textFilter);§List<CardIdPredicate> uuidPredicates = new ArrayList<>();§for (MageObjectReference mor : watcher.getCardsPutToGraveyardFromBattlefield()) {§if (game.getState().getZoneChangeCounter(mor.getSourceId()) == mor.getZoneChangeCounter()) {§uuidPredicates.add(new CardIdPredicate(mor.getSourceId()));§}§}§filter.add(Predicates.or(uuidPredicates));§ability.getTargets().clear();§ability.addTarget(new TargetCardInGraveyard(filter));§}§}§}§
public class Mindsparker extends CardImpl {§private static final FilterSpell filter = new FilterSpell("white or blue instant or sorcery spell");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.INSTANT),§new CardTypePredicate(CardType.SORCERY)));§filter.add(Predicates.or(§new ColorPredicate(ObjectColor.WHITE),§new ColorPredicate(ObjectColor.BLUE)));§}§public Mindsparker(UUID ownerId) {§super(ownerId, 146, "Mindsparker", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{R}{R}");§this.expansionSetCode = "M14";§this.subtype.add("Elemental");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(FirstStrikeAbility.getInstance());§this.addAbility(new SpellCastOpponentTriggeredAbility(Zone.BATTLEFIELD, new MindsparkerEffect(), filter, false, SetTargetPointer.PLAYER));§}§public Mindsparker(final Mindsparker card) {§super(card);§}§@Override§public Mindsparker copy() {§return new Mindsparker(this);§}§}§class MindsparkerEffect extends OneShotEffect {§public MindsparkerEffect() {§super(Outcome.Damage);§staticText = "{this} deals 2 damage to that player";§}§public MindsparkerEffect(final MindsparkerEffect effect) {§super(effect);§}§@Override§public MindsparkerEffect copy() {§return new MindsparkerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player targetPlayer = game.getPlayer(targetPointer.getFirst(game, source));§if (targetPlayer != null) {§targetPlayer.damage(2, source.getSourceId(), game, false, true);§return true;§}§return false;§}§}§
public class ShadowbornApostle extends CardImpl {§private static final FilterCreatureCard filter = new FilterCreatureCard("a Demon creature");§private static final FilterControlledCreaturePermanent filterApostle = new FilterControlledCreaturePermanent("six creatures named Shadowborn Apostle");§static {§filter.add(new SubtypePredicate("Demon"));§filterApostle.add(new NamePredicate("Shadowborn Apostle"));§}§public ShadowbornApostle(UUID ownerId) {§super(ownerId, 114, "Shadowborn Apostle", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{B}");§this.expansionSetCode = "M14";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.getSpellAbility().addEffect(new InfoEffect("A deck can have any number of cards named Shadowborn Apostle."));§Effect effect = new SearchLibraryPutInPlayEffect(new TargetCardInLibrary(filter), false, true);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl("{B}"));§ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent(6,6,filterApostle, false)));§this.addAbility(ability);§}§public ShadowbornApostle(final ShadowbornApostle card) {§super(card);§}§@Override§public ShadowbornApostle copy() {§return new ShadowbornApostle(this);§}§}§
public class VampireWarlord extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("another creature");§static {§filter.add(new AnotherPredicate());§}§public VampireWarlord(UUID ownerId) {§super(ownerId, 120, "Vampire Warlord", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{B}");§this.expansionSetCode = "M14";§this.subtype.add("Vampire");§this.subtype.add("Warrior");§this.power = new MageInt(4);§this.toughness = new MageInt(2);§TargetControlledCreaturePermanent target = new TargetControlledCreaturePermanent(1,1, filter, false);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new SacrificeTargetCost(target)));§}§public VampireWarlord(final VampireWarlord card) {§super(card);§}§@Override§public VampireWarlord copy() {§return new VampireWarlord(this);§}§}§
public class BelligerentSliver extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Sliver creatures you control");§static {§filter.add(new ControllerPredicate(TargetController.YOU));§filter.add(new SubtypePredicate("Sliver"));§}§public BelligerentSliver(UUID ownerId) {§super(ownerId, 129, "Belligerent Sliver", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "M15";§this.subtype.add("Sliver");§this.color.setRed(true);§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Effect effect = new GainAbilityAllEffect(new MenaceAbility(), Duration.WhileOnBattlefield, filter);§effect.setText("Sliver creatures you control have menace. (They can't be blocked except by two or more creatures.)");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§}§public BelligerentSliver(final BelligerentSliver card) {§super(card);§}§@Override§public BelligerentSliver copy() {§return new BelligerentSliver(this);§}§}§
public class EndlessObedience extends CardImpl {§public EndlessObedience(UUID ownerId) {§super(ownerId, 94, "Endless Obedience", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{4}{B}{B}");§this.expansionSetCode = "M15";§this.addAbility(new ConvokeAbility());§this.getSpellAbility().addTarget(new TargetCardInGraveyard(new FilterCreatureCard("creature card from a graveyard")));§this.getSpellAbility().addEffect(new ReturnFromGraveyardToBattlefieldTargetEffect());§}§public EndlessObedience(final EndlessObedience card) {§super(card);§}§@Override§public EndlessObedience copy() {§return new EndlessObedience(this);§}§}§
public class HotSoup extends CardImpl {§public HotSoup(UUID ownerId) {§super(ownerId, 219, "Hot Soup", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "M15";§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CantBeBlockedAttachedEffect(AttachmentType.EQUIPMENT)));§this.addAbility(new HotSoupTriggeredAbility());§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(3)));§}§public HotSoup(final HotSoup card) {§super(card);§}§@Override§public HotSoup copy() {§return new HotSoup(this);§}§}§class HotSoupTriggeredAbility extends TriggeredAbilityImpl {§HotSoupTriggeredAbility() {§super(Zone.BATTLEFIELD, new DestroyTargetEffect(), false);§}§HotSoupTriggeredAbility(final HotSoupTriggeredAbility ability) {§super(ability);§}§@Override§public HotSoupTriggeredAbility copy() {§return new HotSoupTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_CREATURE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Permanent equipment = game.getPermanent(this.getSourceId());§if (equipment != null && equipment.getAttachedTo() != null) {§if (event.getTargetId() == equipment.getAttachedTo()) {§for(Effect effect : this.getEffects())§{§effect.setTargetPointer(new FixedTarget(equipment.getAttachedTo()));§}§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever equipped creature is dealt damage, " + super.getRule();§}§}§
public class MeditationPuzzle extends CardImpl {§public MeditationPuzzle(UUID ownerId) {§super(ownerId, 19, "Meditation Puzzle", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{3}{W}{W}");§this.expansionSetCode = "M15";§this.addAbility(new ConvokeAbility());§this.getSpellAbility().addEffect(new GainLifeEffect(8));§}§public MeditationPuzzle(final MeditationPuzzle card) {§super(card);§}§@Override§public MeditationPuzzle copy() {§return new MeditationPuzzle(this);§}§}§
public class PerilousVault extends CardImpl {§public PerilousVault(UUID ownerId) {§super(ownerId, 224, "Perilous Vault", Rarity.MYTHIC, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "M15";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PerilousVaultEffect(), new GenericManaCost(5));§ability.addCost(new TapSourceCost());§ability.addCost(new ExileSourceCost());§this.addAbility(ability);§}§public PerilousVault(final PerilousVault card) {§super(card);§}§@Override§public PerilousVault copy() {§return new PerilousVault(this);§}§}§class PerilousVaultEffect extends OneShotEffect {§private static final FilterPermanent filter = new FilterNonlandPermanent();§PerilousVaultEffect() {§super(Outcome.Exile);§this.staticText = "Exile all nonland permanents";§}§PerilousVaultEffect(final PerilousVaultEffect effect) {§super(effect);§}§@Override§public PerilousVaultEffect copy() {§return new PerilousVaultEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§for (Permanent permanent : game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game)) {§controller.moveCardToExileWithInfo(permanent, null, "", source.getSourceId(), game, Zone.HAND, true);§}§return true;§}§return false;§}§}§
public class ShieldOfTheAvatar extends CardImpl {§public ShieldOfTheAvatar(UUID ownerId) {§super(ownerId, 230, "Shield of the Avatar", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "M15";§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ShieldOfTheAvatarPreventionEffect()));§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(2)));§}§public ShieldOfTheAvatar(final ShieldOfTheAvatar card) {§super(card);§}§@Override§public ShieldOfTheAvatar copy() {§return new ShieldOfTheAvatar(this);§}§}§class ShieldOfTheAvatarPreventionEffect extends PreventionEffectImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("creatures you control");§ShieldOfTheAvatarPreventionEffect() {§super(Duration.WhileOnBattlefield);§this.staticText = "If a source would deal damage to equipped creature, prevent X of that damage, where X is the number of creatures you control.";§}§ShieldOfTheAvatarPreventionEffect(final ShieldOfTheAvatarPreventionEffect effect) {§super(effect);§}§@Override§public ShieldOfTheAvatarPreventionEffect copy() {§return new ShieldOfTheAvatarPreventionEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§boolean result = false;§Permanent equipment = game.getPermanent(source.getSourceId());§if (equipment != null && equipment.getAttachedTo() != null) {§int numberOfCreaturesControlled = new PermanentsOnBattlefieldCount(filter).calculate(game, source, this);§int toPrevent = Math.min(numberOfCreaturesControlled, event.getAmount());§GameEvent preventEvent = new GameEvent(GameEvent.EventType.PREVENT_DAMAGE, equipment.getAttachedTo(), source.getSourceId(), source.getControllerId(), toPrevent, false);§if (!game.replaceEvent(preventEvent)) {§if (event.getAmount() >= toPrevent) {§event.setAmount(event.getAmount() - toPrevent);§}§else {§event.setAmount(0);§result = true;§}§if (toPrevent > 0) {§game.informPlayers(new StringBuilder("Shield of the Avatar ").append("prevented ").append(toPrevent).append(" damage to ").append(game.getPermanent(equipment.getAttachedTo()).getName()).toString());§game.fireEvent(GameEvent.getEvent(GameEvent.EventType.PREVENTED_DAMAGE,§equipment.getAttachedTo(), source.getSourceId(), source.getControllerId(), toPrevent));§}§}§}§return result;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (super.applies(event, source, game)) {§Permanent equipment = game.getPermanent(source.getSourceId());§if (equipment != null && equipment.getAttachedTo() != null§&& event.getTargetId().equals(equipment.getAttachedTo())) {§return true;§}§}§return false;§}§}§
public class Ulcerate extends CardImpl {§public Ulcerate(UUID ownerId) {§super(ownerId, 119, "Ulcerate", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{B}");§this.expansionSetCode = "M15";§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new BoostTargetEffect(-3, -3, Duration.EndOfTurn));§this.getSpellAbility().addEffect(new LoseLifeSourceControllerEffect(3));§}§public Ulcerate(final Ulcerate card) {§super(card);§}§@Override§public Ulcerate copy() {§return new Ulcerate(this);§}§}§
public class AlhammarretsArchive extends CardImpl {§public AlhammarretsArchive(UUID ownerId) {§super(ownerId, 221, "Alhammarret's Archive", Rarity.MYTHIC, new CardType[]{CardType.ARTIFACT}, "{5}");§this.expansionSetCode = "ORI";§this.supertype.add("Legendary");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new AlhammarretsArchiveEffect()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new AlhammarretsArchiveReplacementEffect()), new CardsDrawnDuringDrawStepWatcher());§}§public AlhammarretsArchive(final AlhammarretsArchive card) {§super(card);§}§@Override§public AlhammarretsArchive copy() {§return new AlhammarretsArchive(this);§}§}§class AlhammarretsArchiveEffect extends ReplacementEffectImpl {§public AlhammarretsArchiveEffect() {§super(Duration.WhileOnBattlefield, Outcome.Benefit);§staticText = "If you would gain life, you gain twice that much life instead";§}§public AlhammarretsArchiveEffect(final AlhammarretsArchiveEffect effect) {§super(effect);§}§@Override§public AlhammarretsArchiveEffect copy() {§return new AlhammarretsArchiveEffect(this);§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§event.setAmount(event.getAmount() * 2);§return false;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType().equals(GameEvent.EventType.GAIN_LIFE);§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§return event.getPlayerId().equals(source.getControllerId()) && (source.getControllerId() != null);§}§}§class AlhammarretsArchiveReplacementEffect extends ReplacementEffectImpl {§public AlhammarretsArchiveReplacementEffect() {§super(Duration.WhileOnBattlefield, Outcome.Neutral);§staticText = "If you draw a card except the first one you draw in each of your draw steps, draw two cards instead";§}§public AlhammarretsArchiveReplacementEffect(final AlhammarretsArchiveReplacementEffect effect) {§super(effect);§}§@Override§public AlhammarretsArchiveReplacementEffect copy() {§return new AlhammarretsArchiveReplacementEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§controller.drawCards(2, game, event.getAppliedEffects());§}§return true;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.DRAW_CARD;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (event.getPlayerId().equals(source.getControllerId())) {§if (game.getActivePlayerId().equals(event.getPlayerId())§&& game.getPhase().getStep().getType().equals(PhaseStep.DRAW)) {§CardsDrawnDuringDrawStepWatcher watcher = (CardsDrawnDuringDrawStepWatcher) game.getState().getWatchers().get("CardsDrawnDuringDrawStep");§if (watcher != null && watcher.getAmountCardsDrawn(event.getPlayerId()) > 0) {§return true;§}§} else {§return true;§}§}§return false;§}§}§
public class ChandraRoaringFlame extends CardImpl {§public ChandraRoaringFlame(UUID ownerId) {§super(ownerId, 135, "Chandra, Roaring Flame", Rarity.MYTHIC, new CardType[]{CardType.PLANESWALKER}, "");§this.expansionSetCode = "ORI";§this.subtype.add("Chandra");§this.color.setRed(true);§this.nightCard = true;§this.canTransform = true;§this.addAbility(new PlanswalkerEntersWithLoyalityCountersAbility(4));§LoyaltyAbility loyaltyAbility = new LoyaltyAbility(new DamageTargetEffect(2), 1);§loyaltyAbility.addTarget(new TargetPlayer());§this.addAbility(loyaltyAbility);§loyaltyAbility = new LoyaltyAbility(new DamageTargetEffect(2), -2);§loyaltyAbility.addTarget(new TargetCreaturePermanent());§this.addAbility(loyaltyAbility);§this.addAbility(new LoyaltyAbility(new ChandraRoaringFlameEmblemEffect(), -7));§}§public ChandraRoaringFlame(final ChandraRoaringFlame card) {§super(card);§}§@Override§public ChandraRoaringFlame copy() {§return new ChandraRoaringFlame(this);§}§}§class ChandraRoaringFlameEmblemEffect extends OneShotEffect {§public ChandraRoaringFlameEmblemEffect() {§super(Outcome.Damage);§this.staticText = "{this} deals 6 damage to each opponent. Each player dealt damage this way gets an emblem with \"At the beginning of your upkeep, this emblem deals 3 damage to you.\"";§}§public ChandraRoaringFlameEmblemEffect(final ChandraRoaringFlameEmblemEffect effect) {§super(effect);§}§@Override§public ChandraRoaringFlameEmblemEffect copy() {§return new ChandraRoaringFlameEmblemEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§List<Player> opponentsEmblem = new ArrayList<>();§for (UUID playerId : game.getOpponents(controller.getId())) {§Player opponent = game.getPlayer(playerId);§if (opponent != null) {§if (opponent.damage(6, source.getSourceId(), game, false, true) > 0) {§opponentsEmblem.add(opponent);§}§}§}§for (Player opponent : opponentsEmblem) {§game.addEmblem(new ChandraRoaringFlameEmblem(), source, opponent.getId());§}§}§return false;§}§}§/**§* Emblem with "At the beginning of your upkeep, this emblem deals 3 damage to§* you."§*/§class ChandraRoaringFlameEmblem extends Emblem {§public ChandraRoaringFlameEmblem() {§setName("EMBLEM: Chandra, Roaring Flame");§Effect effect = new DamageTargetEffect(3);§effect.setText("this emblem deals 3 damage to you");§this.getAbilities().add(new BeginningOfUpkeepTriggeredAbility(Zone.COMMAND, effect, TargetController.YOU, false, true));§}§}§
public class ElementalBond extends CardImpl {§private static final FilterPermanent filter = new FilterControlledCreaturePermanent("a creature with power 3 or greater");§static {§filter.add(new PowerPredicate(ComparisonType.GreaterThan, 2));§}§public ElementalBond(UUID ownerId) {§super(ownerId, 174, "Elemental Bond", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{G}");§this.expansionSetCode = "ORI";§this.addAbility(new EntersBattlefieldControlledTriggeredAbility(new DrawCardSourceControllerEffect(1), filter));§}§public ElementalBond(final ElementalBond card) {§super(card);§}§@Override§public ElementalBond copy() {§return new ElementalBond(this);§}§}§
public class GideonsPhalanx extends CardImpl {§public GideonsPhalanx(UUID ownerId) {§super(ownerId, 14, "Gideon's Phalanx", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{5}{W}{W}");§this.expansionSetCode = "ORI";§this.getSpellAbility().addEffect(new CreateTokenEffect(new KnightToken(), 4));§Effect effect = new ConditionalOneShotEffect(§new AddContinuousEffectToGame(new GainAbilityAllEffect(IndestructibleAbility.getInstance(), Duration.EndOfTurn, new FilterControlledCreaturePermanent())),§SpellMasteryCondition.getInstance(),§"<br><i>Spell mastery</i> - If there are two or more instant and/or sorcery cards in your graveyard, creatures you control gain indestructible until end of turn");§this.getSpellAbility().addEffect(effect);§}§public GideonsPhalanx(final GideonsPhalanx card) {§super(card);§}§@Override§public GideonsPhalanx copy() {§return new GideonsPhalanx(this);§}§}§
public class InfiniteObliteration extends CardImpl {§public InfiniteObliteration(UUID ownerId) {§super(ownerId, 103, "Infinite Obliteration", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{1}{B}{B}");§this.expansionSetCode = "ORI";§this.getSpellAbility().addEffect(new InfiniteObliterationEffect());§this.getSpellAbility().addTarget(new TargetOpponent());§}§public InfiniteObliteration(final InfiniteObliteration card) {§super(card);§}§@Override§public InfiniteObliteration copy() {§return new InfiniteObliteration(this);§}§}§class InfiniteObliterationEffect extends SearchTargetGraveyardHandLibraryForCardNameAndExileEffect {§public InfiniteObliterationEffect() {§super(true, "target opponent's", "any number of cards with that name");§}§public InfiniteObliterationEffect(final InfiniteObliterationEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(getTargetPointer().getFirst(game, source));§Player controller = game.getPlayer(source.getControllerId());§if (player != null && controller != null) {§Choice cardChoice = new ChoiceImpl();§cardChoice.setChoices(CardRepository.instance.getCreatureNames());§cardChoice.clearChoice();§cardChoice.setMessage("Name a creature card");§while (!controller.choose(Outcome.Exile, cardChoice, game)) {§if (!controller.canRespond()) {§return false;§}§}§String cardName;§cardName = cardChoice.getChoice();§MageObject sourceObject = game.getObject(source.getSourceId());§if (sourceObject != null) {§game.informPlayers(sourceObject.getName() + " named card: [" + cardName + "]");§}§super.applySearchAndExile(game, source, cardName, player.getId());§}§return true;§}§@Override§public InfiniteObliterationEffect copy() {§return new InfiniteObliterationEffect(this);§}§@Override§public String getText(Mode mode) {§return "Name a creature card. " + super.getText(mode);§}§}§
public class MagmaticInsight extends CardImpl {§public MagmaticInsight(UUID ownerId) {§super(ownerId, 155, "Magmatic Insight", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{R}");§this.expansionSetCode = "ORI";§this.getSpellAbility().addCost(new DiscardTargetCost(new TargetCardInHand(new FilterLandCard())));§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(2));§}§public MagmaticInsight(final MagmaticInsight card) {§super(card);§}§@Override§public MagmaticInsight copy() {§return new MagmaticInsight(this);§}§}§
public class PriestOfTheBloodRite extends CardImpl {§public PriestOfTheBloodRite(UUID ownerId) {§super(ownerId, 112, "Priest of the Blood Rite", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{B}{B}");§this.expansionSetCode = "ORI";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new EntersBattlefieldTriggeredAbility(new CreateTokenEffect(new DemonToken())));§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new LoseLifeSourceControllerEffect(2), TargetController.YOU, false));§}§public PriestOfTheBloodRite(final PriestOfTheBloodRite card) {§super(card);§}§@Override§public PriestOfTheBloodRite copy() {§return new PriestOfTheBloodRite(this);§}§}§
public class SigilOfValor extends CardImpl {§public SigilOfValor(UUID ownerId) {§super(ownerId, 239, "Sigil of Valor", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "ORI";§this.subtype.add("Equipment");§this.addAbility(new SigilOfValorTriggeredAbility(new SigilOfValorCount()));§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(1)));§}§public SigilOfValor(final SigilOfValor card) {§super(card);§}§@Override§public SigilOfValor copy() {§return new SigilOfValor(this);§}§}§class SigilOfValorTriggeredAbility extends TriggeredAbilityImpl {§public SigilOfValorTriggeredAbility(DynamicValue boostValue) {§super(Zone.BATTLEFIELD, new BoostTargetEffect(boostValue, boostValue, Duration.EndOfTurn));§}§public SigilOfValorTriggeredAbility(final SigilOfValorTriggeredAbility ability) {§super(ability);§}§@Override§public SigilOfValorTriggeredAbility copy() {§return new SigilOfValorTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.DECLARED_ATTACKERS;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (game.getActivePlayerId().equals(getControllerId())) {§if (game.getCombat().attacksAlone()) {§Permanent equipment = game.getPermanent(getSourceId());§UUID attackerId = game.getCombat().getAttackers().get(0);§if (equipment != null§&& equipment.getAttachedTo() != null§&& equipment.getAttachedTo().equals(attackerId)) {§this.getEffects().get(0).setTargetPointer(new FixedTarget(attackerId));§return true;§}§}§}§return false;§}§@Override§public String getRule() {§return "Whenever equipped creature attacks alone, it gets +1/+1 until end of turn for each other creature you control.";§}§}§class SigilOfValorCount implements DynamicValue {§public SigilOfValorCount() {§}§public SigilOfValorCount(final SigilOfValorCount dynamicValue) {§super();§}§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§Permanent equipment = game.getPermanent(sourceAbility.getSourceId());§if (equipment != null && equipment.getAttachedTo() != null) {§FilterPermanent filterPermanent = new FilterControlledCreaturePermanent();§filterPermanent.add(Predicates.not(new CardIdPredicate(equipment.getAttachedTo())));§return game.getBattlefield().count(filterPermanent, sourceAbility.getSourceId(), sourceAbility.getControllerId(), game);§}§return 0;§}§@Override§public DynamicValue copy() {§return new SigilOfValorCount(this);§}§@Override§public String toString() {§return "X";§}§@Override§public String getMessage() {§return filter.getMessage();§}§}§
public class TopanFreeblade extends CardImpl {§public TopanFreeblade(UUID ownerId) {§super(ownerId, 36, "Topan Freeblade", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "ORI";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(new RenownAbility(1));§}§public TopanFreeblade(final TopanFreeblade card) {§super(card);§}§@Override§public TopanFreeblade copy() {§return new TopanFreeblade(this);§}§}§
public class PowderKeg extends CardImpl {§public PowderKeg(UUID ownerId) {§super(ownerId, 3, "Powder Keg", Rarity.SPECIAL, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "MPRP";§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new AddCountersSourceEffect(CounterType.FUSE.createInstance(), true), TargetController.YOU, true));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PowderKegEffect(), new SacrificeSourceCost());§this.addAbility(ability);§}§public PowderKeg(final PowderKeg card) {§super(card);§}§@Override§public PowderKeg copy() {§return new PowderKeg(this);§}§}§class PowderKegEffect extends OneShotEffect {§public PowderKegEffect() {§super(Outcome.DestroyPermanent);§staticText = "Destroy each artifact and creature with converted mana cost equal to the number of fuse counters on Powder Keg {this}";§}§public PowderKegEffect(final PowderKegEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent p = game.getBattlefield().getPermanent(source.getSourceId());§if (p == null) {§p = (Permanent) game.getLastKnownInformation(source.getSourceId(), Zone.BATTLEFIELD);§if (p == null) {§return false;§}§}§int count = p.getCounters().getCount(CounterType.FUSE);§for (Permanent perm: game.getBattlefield().getAllActivePermanents()) {§if (perm.getManaCost().convertedManaCost() == count && ((perm.getCardType().contains(CardType.ARTIFACT))§|| (perm.getCardType().contains(CardType.CREATURE)))) {§perm.destroy(source.getSourceId(), game, false);§}§}§return true;§}§@Override§public PowderKegEffect copy() {§return new PowderKegEffect(this);§}§}§
public class SpectralBears extends CardImpl {§public SpectralBears(UUID ownerId) {§super(ownerId, 131, "Spectral Bears", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "MED";§this.subtype.add("Bear");§this.subtype.add("Spirit");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new SpectralBearsTriggeredAbility());§}§public SpectralBears(final SpectralBears card) {§super(card);§}§@Override§public SpectralBears copy() {§return new SpectralBears(this);§}§}§class SpectralBearsTriggeredAbility extends TriggeredAbilityImpl {§private static final FilterPermanent filter = new FilterPermanent("black nontoken permanents");§static {§filter.add(new ColorPredicate(ObjectColor.BLACK));§filter.add(Predicates.not(new TokenPredicate()));§}§public SpectralBearsTriggeredAbility() {§super(Zone.BATTLEFIELD, new DontUntapInControllersNextUntapStepSourceEffect());§}§public SpectralBearsTriggeredAbility(final SpectralBearsTriggeredAbility ability) {§super(ability);§}§@Override§public SpectralBearsTriggeredAbility copy() {§return new SpectralBearsTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ATTACKER_DECLARED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§return event.getSourceId().equals(this.getSourceId());§}§@Override§public boolean checkInterveningIfClause(Game game) {§UUID defendingPlayerId = game.getCombat().getDefendingPlayerId(getSourceId(), game);§return defendingPlayerId != null && game.getBattlefield().countAll(filter, defendingPlayerId, game) < 1;§}§@Override§public String getRule() {§return "Whenever {this} attacks, if defending player controls no black nontoken permanents, it doesn't untap during your next untap step.";§}§}§
public class Errantry extends CardImpl {§public Errantry(UUID ownerId) {§super(ownerId, 124, "Errantry", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{R}");§this.expansionSetCode = "ME2";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Benefit));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(3, 0, Duration.WhileOnBattlefield));§Effect effect = new CanAttackOnlyAloneEffect();§effect.setText("and can only attack alone");§ability.addEffect(effect);§this.addAbility(ability);§}§public Errantry(final Errantry card) {§super(card);§}§@Override§public Errantry copy() {§return new Errantry(this);§}§}§
public class StormSpirit extends CardImpl {§public StormSpirit(UUID ownerId) {§super(ownerId, 198, "Storm Spirit", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{G}{W}{U}");§this.expansionSetCode = "ME2";§this.subtype.add("Elemental");§this.subtype.add("Spirit");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(2), new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public StormSpirit(final StormSpirit card) {§super(card);§}§@Override§public StormSpirit copy() {§return new StormSpirit(this);§}§}§
public class FireSprites extends CardImpl {§public FireSprites(UUID ownerId) {§super(ownerId, 118, "Fire Sprites", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "ME3";§this.subtype.add("Faerie");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleManaAbility(Zone.BATTLEFIELD, Mana.RedMana(1), new ManaCostsImpl("{G}"));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public FireSprites(final FireSprites card) {§super(card);§}§@Override§public FireSprites copy() {§return new FireSprites(this);§}§}§
public class SunCeYoungConquerer extends CardImpl {§public SunCeYoungConquerer(UUID ownerId) {§super(ownerId, 52, "Sun Ce, Young Conquerer", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{U}{U}");§this.expansionSetCode = "ME3";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(HorsemanshipAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new ReturnToHandTargetEffect(), true);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public SunCeYoungConquerer(final SunCeYoungConquerer card) {§super(card);§}§@Override§public SunCeYoungConquerer copy() {§return new SunCeYoungConquerer(this);§}§}§
public class GorillaWarCry extends CardImpl {§public GorillaWarCry(UUID ownerId) {§super(ownerId, 124, "Gorilla War Cry", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{R}");§this.expansionSetCode = "ME4";§this.addAbility(new CastOnlyDuringPhaseStepSourceAbility(TurnPhase.COMBAT, BeforeBlockersAreDeclaredCondition.getInstance()));§Effect effect = new GainAbilityAllEffect(new MenaceAbility(), Duration.EndOfTurn, new FilterCreaturePermanent());§effect.setText("All creatures gain menace until end of turn. <i>(They can't be blocked except by two or more creatures.)</i>");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addEffect(new CreateDelayedTriggeredAbilityEffect(new AtTheBeginOfNextUpkeepDelayedTriggeredAbility(new DrawCardSourceControllerEffect(1)), false));§}§public GorillaWarCry(final GorillaWarCry card) {§super(card);§}§@Override§public GorillaWarCry copy() {§return new GorillaWarCry(this);§}§}§
public class WindseekerCentaur extends CardImpl {§public WindseekerCentaur(UUID ownerId) {§super(ownerId, 7, "Windseeker Centaur", Rarity.SPECIAL, new CardType[]{CardType.CREATURE}, "{1}{R}{R}");§this.expansionSetCode = "MBP";§this.subtype.add("Centaur");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(VigilanceAbility.getInstance());§}§public WindseekerCentaur(final WindseekerCentaur card) {§super(card);§}§@Override§public WindseekerCentaur copy() {§return new WindseekerCentaur(this);§}§}§
public class CausticWasps extends CardImpl {§public CausticWasps(UUID ownerId) {§super(ownerId, 234, "Caustic Wasps", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "MMQ";§this.subtype.add("Insect");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new CausticWaspsTriggeredAbility());§}§public CausticWasps(final CausticWasps card) {§super(card);§}§@Override§public CausticWasps copy() {§return new CausticWasps(this);§}§}§class CausticWaspsTriggeredAbility extends TriggeredAbilityImpl {§public CausticWaspsTriggeredAbility() {§super(Zone.BATTLEFIELD, new DestroyTargetEffect(), true);§}§public CausticWaspsTriggeredAbility(final CausticWaspsTriggeredAbility ability) {§super(ability);§}§@Override§public CausticWaspsTriggeredAbility copy() {§return new CausticWaspsTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_PLAYER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getSourceId().equals(this.sourceId) && ((DamagedPlayerEvent) event).isCombatDamage()) {§Player player = game.getPlayer(event.getTargetId());§if (player != null) {§FilterPermanent filter = new FilterPermanent("an artifact controlled by " + player.getLogName());§filter.add(Predicates.or(§new CardTypePredicate(CardType.ARTIFACT)));§filter.add(new ControllerIdPredicate(event.getTargetId()));§this.getTargets().clear();§this.addTarget(new TargetPermanent(filter));§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever {this} deals combat damage to a player, you may destroy target artifact that player controls.";§}§}§
public class DeepwoodDrummer extends CardImpl {§public DeepwoodDrummer(UUID ownerId) {§super(ownerId, 239, "Deepwood Drummer", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "MMQ";§this.subtype.add("Human");§this.subtype.add("Spellshaper");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(2, 2, Duration.EndOfTurn), new ManaCostsImpl("{G}"));§ability.addCost(new TapSourceCost());§ability.addCost(new DiscardCardCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public DeepwoodDrummer(final DeepwoodDrummer card) {§super(card);§}§@Override§public DeepwoodDrummer copy() {§return new DeepwoodDrummer(this);§}§}§
public class GiantCaterpillar extends CardImpl {§public GiantCaterpillar(UUID ownerId) {§super(ownerId, 249, "Giant Caterpillar", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "MMQ";§this.subtype.add("Insect");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CreateDelayedTriggeredAbilityEffect(§new AtTheBeginOfNextEndStepDelayedTriggeredAbility(new CreateTokenEffect(new ButterflyToken()))),§new ManaCostsImpl("{G}"));§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public GiantCaterpillar(final GiantCaterpillar card) {§super(card);§}§@Override§public GiantCaterpillar copy() {§return new GiantCaterpillar(this);§}§}§class ButterflyToken extends Token {§public ButterflyToken() {§super("Butterfly", "1/1 green Insect creature token with flying named Butterfly");§cardType.add(CardType.CREATURE);§color.setGreen(true);§subtype.add("Insect");§power = new MageInt(1);§toughness = new MageInt(1);§addAbility(FlyingAbility.getInstance());§}§}§
public class KyrenLegate extends CardImpl {§private static final FilterPermanent filterPlains = new FilterPermanent();§private static final FilterPermanent filterMountain = new FilterPermanent();§static {§filterPlains.add(new SubtypePredicate(("Plains")));§filterMountain.add(new SubtypePredicate(("Mountain")));§}§public KyrenLegate(UUID ownerId) {§super(ownerId, 197, "Kyren Legate", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "MMQ";§this.subtype.add("Goblin");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(HasteAbility.getInstance());§Condition condition = new CompoundCondition("If an opponent controls a Plains and you control a Mountain",§new OpponentControlsPermanentCondition(filterPlains),§new PermanentsOnTheBattlefieldCondition(filterMountain));§this.addAbility(new AlternativeCostSourceAbility(null, condition));§}§public KyrenLegate(final KyrenLegate card) {§super(card);§}§@Override§public KyrenLegate copy() {§return new KyrenLegate(this);§}§}§
public class NightwindGlider extends CardImpl {§private static final FilterCard filter = new FilterCard("Black");§static {§filter.add(new ColorPredicate(ObjectColor.BLACK));§}§public NightwindGlider(UUID ownerId) {§super(ownerId, 31, "Nightwind Glider", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "MMQ";§this.subtype.add("Human");§this.subtype.add("Rebel");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new ProtectionAbility(filter));§}§public NightwindGlider(final NightwindGlider card) {§super(card);§}§@Override§public NightwindGlider copy() {§return new NightwindGlider(this);§}§}§
public class RishadanAirship extends CardImpl {§public RishadanAirship(UUID ownerId) {§super(ownerId, 91, "Rishadan Airship", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "MMQ";§this.subtype.add("Human");§this.subtype.add("Pirate");§this.power = new MageInt(3);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new CanBlockOnlyFlyingAbility());§}§public RishadanAirship(final RishadanAirship card) {§super(card);§}§@Override§public RishadanAirship copy() {§return new RishadanAirship(this);§}§}§
public class SkullOfRamos extends CardImpl {§public SkullOfRamos(UUID ownerId) {§super(ownerId, 312, "Skull of Ramos", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "MMQ";§this.addAbility(new BlackManaAbility());§this.addAbility(new SimpleManaAbility(Zone.BATTLEFIELD, Mana.BlackMana(1), new SacrificeSourceCost()));§}§public SkullOfRamos(final SkullOfRamos card) {§super(card);§}§@Override§public SkullOfRamos copy() {§return new SkullOfRamos(this);§}§}§
public class TidalBore extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("an Island");§static {§filter.add(new SubtypePredicate("Island"));§filter.add(new CardTypePredicate(CardType.LAND));§}§public TidalBore(UUID ownerId) {§super(ownerId, 109, "Tidal Bore", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "MMQ";§this.addAbility(new AlternativeCostSourceAbility(new ReturnToHandChosenControlledPermanentCost(new TargetControlledPermanent(filter))));§this.getSpellAbility().addEffect(new MayTapOrUntapTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public TidalBore(final TidalBore card) {§super(card);§}§@Override§public TidalBore copy() {§return new TidalBore(this);§}§}§
public class AuspiciousAncestor extends CardImpl {§private static final FilterSpell filter = new FilterSpell("a white spell");§static {§filter.add(new ColorPredicate(ObjectColor.WHITE));§}§public AuspiciousAncestor(UUID ownerId) {§super(ownerId, 207, "Auspicious Ancestor", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "MIR";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(new DiesTriggeredAbility(new GainLifeEffect(3), false));§this.addAbility(new SpellCastAllTriggeredAbility(new DoIfCostPaid(new GainLifeEffect(1), new ManaCostsImpl("{1}")), filter, true));§}§public AuspiciousAncestor(final AuspiciousAncestor card) {§super(card);§}§@Override§public AuspiciousAncestor copy() {§return new AuspiciousAncestor(this);§}§}§
public class CrashOfRhinos extends CardImpl {§public CrashOfRhinos(UUID ownerId) {§super(ownerId, 108, "Crash of Rhinos", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{6}{G}{G}");§this.expansionSetCode = "MIR";§this.subtype.add("Rhino");§this.power = new MageInt(8);§this.toughness = new MageInt(4);§this.addAbility(TrampleAbility.getInstance());§}§public CrashOfRhinos(final CrashOfRhinos card) {§super(card);§}§@Override§public CrashOfRhinos copy() {§return new CrashOfRhinos(this);§}§}§
public class ForsakenWastes extends CardImpl {§public ForsakenWastes(UUID ownerId) {§super(ownerId, 23, "Forsaken Wastes", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{2}{B}");§this.expansionSetCode = "MIR";§this.supertype.add("World");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CantGainLifeAllEffect()));§this.addAbility(new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new LoseLifeTargetEffect(1), TargetController.ANY, false, true));§this.addAbility(new ForsakenWastesTriggeredAbility());§}§public ForsakenWastes(final ForsakenWastes card) {§super(card);§}§@Override§public ForsakenWastes copy() {§return new ForsakenWastes(this);§}§}§class ForsakenWastesTriggeredAbility extends TriggeredAbilityImpl {§public ForsakenWastesTriggeredAbility() {§super(Zone.BATTLEFIELD, new LoseLifeTargetEffect(5), false);§}§public ForsakenWastesTriggeredAbility(final ForsakenWastesTriggeredAbility ability) {§super(ability);§}§@Override§public ForsakenWastesTriggeredAbility copy() {§return new ForsakenWastesTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.TARGETED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§MageObject eventSourceObject = game.getObject(event.getSourceId());§if (eventSourceObject != null && event.getTargetId().equals(this.getSourceId())&& eventSourceObject instanceof Spell ) {§getEffects().get(0).setTargetPointer(new FixedTarget(event.getPlayerId()));§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever {this} becomes the target of a spell, that spell's controller loses 5 life.";§}§}§
public class Jolt extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("artifact, creature, or land");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.ARTIFACT),§new CardTypePredicate(CardType.CREATURE),§new CardTypePredicate(CardType.LAND)));§}§public Jolt(UUID ownerId) {§super(ownerId, 70, "Jolt", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{U}");§this.expansionSetCode = "MIR";§this.getSpellAbility().addEffect(new MayTapOrUntapTargetEffect());§this.getSpellAbility().addTarget(new TargetPermanent(filter));§this.getSpellAbility().addEffect(new CreateDelayedTriggeredAbilityEffect(new AtTheBeginOfNextUpkeepDelayedTriggeredAbility(new DrawCardSourceControllerEffect(1)), false));§}§public Jolt(final Jolt card) {§super(card);§}§@Override§public Jolt copy() {§return new Jolt(this);§}§}§
public class NocturnalRaid extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("black creatures");§static {§filter.add(new ColorPredicate(ObjectColor.BLACK));§}§public NocturnalRaid(UUID ownerId) {§super(ownerId, 30, "Nocturnal Raid", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{2}{B}{B}");§this.expansionSetCode = "MIR";§this.getSpellAbility().addEffect(new BoostAllEffect(2, 0, Duration.EndOfTurn, filter, false));§}§public NocturnalRaid(final NocturnalRaid card) {§super(card);§}§@Override§public NocturnalRaid copy() {§return new NocturnalRaid(this);§}§}§
public class SapphireCharm extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature an opponent controls");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public SapphireCharm(UUID ownerId) {§super(ownerId, 89, "Sapphire Charm", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{U}");§this.expansionSetCode = "MIR";§Effect effect = new DrawCardTargetEffect(1);§effect.setText("Target player draws a card");§this.getSpellAbility().addEffect(new CreateDelayedTriggeredAbilityEffect(§new AtTheBeginOfNextUpkeepDelayedTriggeredAbility(effect), true));§this.getSpellAbility().addTarget(new TargetPlayer());§Mode mode = new Mode();§mode.getEffects().add(new GainAbilityTargetEffect(FlyingAbility.getInstance(), Duration.EndOfTurn));§mode.getTargets().add(new TargetCreaturePermanent());§this.getSpellAbility().addMode(mode);§mode = new Mode();§mode.getEffects().add(new PhaseOutTargetEffect());§mode.getTargets().add(new TargetCreaturePermanent(filter));§this.getSpellAbility().addMode(mode);§}§public SapphireCharm(final SapphireCharm card) {§super(card);§}§@Override§public SapphireCharm copy() {§return new SapphireCharm(this);§}§}§
public class TeferisIsle extends CardImpl {§public TeferisIsle(UUID ownerId) {§super(ownerId, 315, "Teferi's Isle", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "MIR";§this.supertype.add("Legendary");§this.addAbility(PhasingAbility.getInstance());§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new SimpleManaAbility(Zone.BATTLEFIELD, new Mana(0, 0, 2, 0, 0, 0, 0, 0), new TapSourceCost()));§}§public TeferisIsle(final TeferisIsle card) {§super(card);§}§@Override§public TeferisIsle copy() {§return new TeferisIsle(this);§}§}§
public class WorldlyTutor extends CardImpl {§public WorldlyTutor(UUID ownerId) {§super(ownerId, 153, "Worldly Tutor", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{G}");§this.expansionSetCode = "MIR";§this.getSpellAbility().addEffect(new SearchLibraryPutOnLibraryEffect(new TargetCardInLibrary(new FilterCreatureCard()), true, true));§}§public WorldlyTutor(final WorldlyTutor card) {§super(card);§}§@Override§public WorldlyTutor copy() {§return new WorldlyTutor(this);§}§}§
public class BlinkmothWell extends CardImpl {§private static final FilterArtifactPermanent filter = new FilterArtifactPermanent("noncreature artifact");§static {§filter.add(Predicates.not(new CardTypePredicate(CardType.CREATURE)));§}§public BlinkmothWell(UUID ownerId) {§super(ownerId, 279, "Blinkmoth Well", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "MRD";§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TapTargetEffect(), new GenericManaCost(2));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§}§public BlinkmothWell(final BlinkmothWell card) {§super(card);§}§@java.lang.Override§public BlinkmothWell copy() {§return new BlinkmothWell(this);§}§}§
public class DragonBlood extends CardImpl {§public DragonBlood(UUID ownerId) {§super(ownerId, 163, "Dragon Blood", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "MRD";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersTargetEffect(CounterType.P1P1.createInstance(1)), new GenericManaCost(3));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public DragonBlood(final DragonBlood card) {§super(card);§}§@java.lang.Override§public DragonBlood copy() {§return new DragonBlood(this);§}§}§
public class GoblinDirigible extends CardImpl {§public GoblinDirigible(UUID ownerId) {§super(ownerId, 177, "Goblin Dirigible", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{6}");§this.expansionSetCode = "MRD";§this.subtype.add("Construct");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new DontUntapInControllersUntapStepSourceEffect()));§this.addAbility(new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new DoIfCostPaid(§new UntapSourceEffect(), new ManaCostsImpl("{4}")), TargetController.YOU, false));§}§public GoblinDirigible(final GoblinDirigible card) {§super(card);§}§@java.lang.Override§public GoblinDirigible copy() {§return new GoblinDirigible(this);§}§}§
public class KrarkClanGrunt extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("an artifact");§static {§filter.add(new CardTypePredicate(CardType.ARTIFACT));§}§public KrarkClanGrunt(UUID ownerId) {§super(ownerId, 97, "Krark-Clan Grunt", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "MRD";§this.subtype.add("Goblin");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 0, Duration.EndOfTurn), new SacrificeTargetCost(new TargetControlledPermanent(filter)));§ability.addEffect(new GainAbilitySourceEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn));§this.addAbility(ability);§}§public KrarkClanGrunt(final KrarkClanGrunt card) {§super(card);§}§@java.lang.Override§public KrarkClanGrunt copy() {§return new KrarkClanGrunt(this);§}§}§
public class Megatog extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("an artifact");§static {§filter.add(new CardTypePredicate(CardType.ARTIFACT));§}§public Megatog(UUID ownerId) {§super(ownerId, 100, "Megatog", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{R}{R}");§this.expansionSetCode = "MRD";§this.subtype.add("Atog");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(3, 3, Duration.EndOfTurn), new SacrificeTargetCost(new TargetControlledPermanent(filter)));§ability.addEffect(new GainAbilitySourceEffect(TrampleAbility.getInstance(), Duration.EndOfTurn));§this.addAbility(ability);§}§public Megatog(final Megatog card) {§super(card);§}§@java.lang.Override§public Megatog copy() {§return new Megatog(this);§}§}§
public class OblivionStone extends CardImpl {§public OblivionStone(UUID ownerId) {§super(ownerId, 222, "Oblivion Stone", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "MRD";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersTargetEffect(CounterType.FATE.createInstance()), new GenericManaCost(4));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetPermanent());§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new OblivionStoneEffect(), new GenericManaCost(5));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public OblivionStone(final OblivionStone card) {§super(card);§}§@java.lang.Override§public OblivionStone copy() {§return new OblivionStone(this);§}§}§class OblivionStoneEffect extends OneShotEffect {§OblivionStoneEffect() {§super(Outcome.DestroyPermanent);§staticText = "Destroy each nonland permanent without a fate counter on it, then remove all fate counters from all permanents";§}§OblivionStoneEffect(final OblivionStoneEffect effect) {§super(effect);§}§@java.lang.Override§public boolean apply(Game game, Ability source) {§for (Permanent p : game.getBattlefield().getAllActivePermanents()) {§if (!(p.getCardType().contains(CardType.LAND) || p.getCounters().containsKey(CounterType.FATE))) {§p.destroy(source.getSourceId(), game, false);§}§}§for (Permanent p : game.getBattlefield().getAllActivePermanents()) {§if (p.getCounters().containsKey(CounterType.FATE)) {§p.getCounters().removeCounter(CounterType.FATE, p.getCounters().getCount(CounterType.FATE));§}§}§return true;§}§@java.lang.Override§public OblivionStoneEffect copy() {§return new OblivionStoneEffect(this);§}§}§
public class ScrabblingClaws extends CardImpl {§public ScrabblingClaws(UUID ownerId) {§super(ownerId, 237, "Scrabbling Claws", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "MRD";§Ability firstAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ScrabblingClawsEffect(), new TapSourceCost());§firstAbility.addTarget(new TargetPlayer());§this.addAbility(firstAbility);§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new mage.abilities.effects.common.ExileTargetEffect(), new SacrificeSourceCost());§ability.addCost(new GenericManaCost(1));§ability.addTarget(new TargetCardInGraveyard());§this.addAbility(ability);§ability.addEffect(new DrawCardSourceControllerEffect(1));§}§public ScrabblingClaws(final ScrabblingClaws card) {§super(card);§}§@java.lang.Override§public ScrabblingClaws copy() {§return new ScrabblingClaws(this);§}§}§class ScrabblingClawsEffect extends OneShotEffect {§public ScrabblingClawsEffect() {§super(Outcome.Exile);§this.staticText = "Target player exiles a card from his or her graveyard";§}§public ScrabblingClawsEffect(final ScrabblingClawsEffect effect) {§super(effect);§}§@java.lang.Override§public ScrabblingClawsEffect copy() {§return new ScrabblingClawsEffect(this);§}§@java.lang.Override§public boolean apply(Game game, Ability source) {§Player targetPlayer = game.getPlayer(source.getFirstTarget());§if (targetPlayer != null) {§FilterCard filter = new FilterCard("card from your graveyard");§filter.add(new OwnerIdPredicate(targetPlayer.getId()));§TargetCardInGraveyard target = new TargetCardInGraveyard(filter);§if (targetPlayer.chooseTarget(Outcome.Exile, target, source, game)) {§Card card = game.getCard(target.getFirstTarget());§if (card != null) {§targetPlayer.moveCardToExileWithInfo(card, null, "", source.getSourceId(), game, Zone.GRAVEYARD, true);§}§return true;§}§}§return false;§}§}§
public class SpoilsOfTheVault extends CardImpl {§public SpoilsOfTheVault(UUID ownerId) {§super(ownerId, 78, "Spoils of the Vault", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{B}");§this.expansionSetCode = "MRD";§this.getSpellAbility().addEffect(new NameACardEffect(NameACardEffect.TypeOfName.ALL));§this.getSpellAbility().addEffect(new SpoilsOfTheVaultEffect());§}§public SpoilsOfTheVault(final SpoilsOfTheVault card) {§super(card);§}§@java.lang.Override§public SpoilsOfTheVault copy() {§return new SpoilsOfTheVault(this);§}§}§class SpoilsOfTheVaultEffect extends OneShotEffect {§public SpoilsOfTheVaultEffect() {§super(Outcome.Damage);§this.staticText = "Reveal cards from the top of your library until you reveal the named card, then put that card into your hand. Exile all other cards revealed this way, and you lose 1 life for each of the exiled cards";§}§public SpoilsOfTheVaultEffect(final SpoilsOfTheVaultEffect effect) {§super(effect);§}§@java.lang.Override§public SpoilsOfTheVaultEffect copy() {§return new SpoilsOfTheVaultEffect(this);§}§@java.lang.Override§public boolean apply(Game game, Ability source) {§MageObject sourceObject = game.getObject(source.getSourceId());§Player controller = game.getPlayer(source.getControllerId());§String cardName = (String) game.getState().getValue(source.getSourceId().toString() + NameACardEffect.INFO_KEY);§if (sourceObject == null || controller == null || cardName == null || cardName.isEmpty()) {§return false;§}§Cards cardsToReveal = new CardsImpl();§Cards cardsToExile = new CardsImpl();§while (controller.getLibrary().size() > 0) {§Card card = controller.getLibrary().removeFromTop(game);§if (card != null) {§cardsToReveal.add(card);§if (card.getName().equals(cardName)) {§controller.moveCards(card, null, Zone.HAND, source, game);§break;§} else {§cardsToExile.add(card);§}§}§}§controller.revealCards(sourceObject.getIdName(), cardsToReveal, game);§controller.moveCards(cardsToExile, null, Zone.EXILED, source, game);§controller.loseLife(cardsToExile.size(), game);§return true;§}§}§
public class TowerOfFortunes extends CardImpl {§public TowerOfFortunes(UUID ownerId) {§super(ownerId, 267, "Tower of Fortunes", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "MRD";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(4), new GenericManaCost(8));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public TowerOfFortunes(final TowerOfFortunes card) {§super(card);§}§@java.lang.Override§public TowerOfFortunes copy() {§return new TowerOfFortunes(this);§}§}§
public class WurmskinForger extends CardImpl {§public WurmskinForger(UUID ownerId) {§super(ownerId, 140, "Wurmskin Forger", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{5}{G}{G}");§this.expansionSetCode = "MRD";§this.subtype.add("Elf");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new EntersBattlefieldTriggeredAbility(new DistributeCountersEffect(CounterType.P1P1, 3, false, "one, two, or three target creatures"), false);§ability.addTarget(new TargetCreaturePermanentAmount(3));§this.addAbility(ability);§}§public WurmskinForger(final WurmskinForger card) {§super(card);§}§@java.lang.Override§public WurmskinForger copy() {§return new WurmskinForger(this);§}§}§
public class CoreProwler extends CardImpl {§public CoreProwler (UUID ownerId) {§super(ownerId, 103, "Core Prowler", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{4}");§this.expansionSetCode = "MBS";§this.subtype.add("Horror");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(InfectAbility.getInstance());§this.addAbility(new DiesTriggeredAbility(new ProliferateEffect()));§}§public CoreProwler (final CoreProwler card) {§super(card);§}§@Override§public CoreProwler copy() {§return new CoreProwler(this);§}§}§
public class GoblinWardriver extends CardImpl {§public GoblinWardriver (UUID ownerId) {§super(ownerId, 64, "Goblin Wardriver", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{R}{R}");§this.expansionSetCode = "MBS";§this.subtype.add("Goblin");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new BattleCryAbility());§}§public GoblinWardriver (final GoblinWardriver card) {§super(card);§}§@Override§public GoblinWardriver copy() {§return new GoblinWardriver(this);§}§}§
public class LeoninRelicWarder extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("artifact or enchantment");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.ARTIFACT),§new CardTypePredicate(CardType.ENCHANTMENT)));§}§public LeoninRelicWarder (UUID ownerId) {§super(ownerId, 10, "Leonin Relic-Warder", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{W}{W}");§this.expansionSetCode = "MBS";§this.subtype.add("Cat");§this.subtype.add("Cleric");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new EntersBattlefieldTriggeredAbility(new ExileTargetForSourceEffect(), true);§Target target = new TargetPermanent(filter);§ability.addTarget(target);§this.addAbility(ability);§Ability ability2 = new LeavesBattlefieldTriggeredAbility(new ReturnFromExileForSourceEffect(Zone.BATTLEFIELD), false);§this.addAbility(ability2);§}§public LeoninRelicWarder (final LeoninRelicWarder card) {§super(card);§}§@Override§public LeoninRelicWarder copy() {§return new LeoninRelicWarder(this);§}§}§
public class Oculus extends CardImpl {§public Oculus (UUID ownerId) {§super(ownerId, 29, "Oculus", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "MBS";§this.subtype.add("Homunculus");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new DiesTriggeredAbility(new DrawCardSourceControllerEffect(1), true));§}§public Oculus (final Oculus card) {§super(card);§}§@Override§public Oculus copy() {§return new Oculus(this);§}§}§
public class QuilledSlagwurm extends CardImpl {§public QuilledSlagwurm (UUID ownerId) {§super(ownerId, 89, "Quilled Slagwurm", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{G}{G}{G}");§this.expansionSetCode = "MBS";§this.subtype.add("Wurm");§this.power = new MageInt(8);§this.toughness = new MageInt(8);§}§public QuilledSlagwurm (final QuilledSlagwurm card) {§super(card);§}§@Override§public QuilledSlagwurm copy() {§return new QuilledSlagwurm(this);§}§}§
public class SpireSerpent extends CardImpl {§private static final String abilityText1 = "Metalcraft - As long as you control three or more artifacts, {this} gets +2/+2";§public SpireSerpent(UUID ownerId) {§super(ownerId, 32, "Spire Serpent", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{U}");§this.expansionSetCode = "MBS";§this.subtype.add("Serpent");§this.color.setBlue(true);§this.power = new MageInt(3);§this.toughness = new MageInt(5);§this.addAbility(DefenderAbility.getInstance());§ConditionalContinuousEffect effect1 = new ConditionalContinuousEffect(new BoostSourceEffect(2, 2, Duration.WhileOnBattlefield), MetalcraftCondition.getInstance(), abilityText1);§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, effect1);§Effect effect = new ConditionalAsThoughEffect(new CanAttackAsThoughItDidntHaveDefenderSourceEffect(Duration.WhileOnBattlefield),§MetalcraftCondition.getInstance());§effect.setText("and can attack as though it didn't have defender");§ability.addEffect(effect);§this.addAbility(ability);§}§public SpireSerpent(final SpireSerpent card) {§super(card);§}§@Override§public SpireSerpent copy() {§return new SpireSerpent(this);§}§}§
public class ViridianCorrupter extends CardImpl {§public ViridianCorrupter (UUID ownerId) {§super(ownerId, 94, "Viridian Corrupter", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{G}{G}");§this.expansionSetCode = "MBS";§this.subtype.add("Elf");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(InfectAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new DestroyTargetEffect(), false);§Target target = new TargetPermanent(new FilterArtifactPermanent());§ability.addTarget(target);§this.addAbility(ability);§}§public ViridianCorrupter (final ViridianCorrupter card) {§super(card);§}§@Override§public ViridianCorrupter copy() {§return new ViridianCorrupter(this);§}§}§
public class Epochrasite extends CardImpl {§public Epochrasite(UUID ownerId) {§super(ownerId, 205, "Epochrasite", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{2}");§this.expansionSetCode = "MMA";§this.subtype.add("Construct");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new EntersBattlefieldAbility(§new AddCountersSourceEffect(CounterType.P1P1.createInstance(3)),§new InvertCondition(new CastFromHandCondition()),§"{this} enters the battlefield with three +1/+1 counters on it if you didn't cast it from your hand",""),§new CastFromHandWatcher());§this.addAbility(new DiesTriggeredAbility(new EpochrasiteEffect()));§}§public Epochrasite(final Epochrasite card) {§super(card);§}§@Override§public Epochrasite copy() {§return new Epochrasite(this);§}§}§class EpochrasiteEffect extends OneShotEffect {§public EpochrasiteEffect() {§super(Outcome.Benefit);§this.staticText = "exile it with three time counters on it and it gains suspend";§}§public EpochrasiteEffect(final EpochrasiteEffect effect) {§super(effect);§}§@Override§public EpochrasiteEffect copy() {§return new EpochrasiteEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Card card = game.getCard(source.getSourceId());§if (controller != null && card != null) {§if (game.getState().getZone(card.getId()).equals(Zone.GRAVEYARD)) {§UUID exileId = SuspendAbility.getSuspendExileId(controller.getId(), game);§controller.moveCardToExileWithInfo(card, exileId, "Suspended cards of " + controller.getName(), source.getSourceId(), game, Zone.GRAVEYARD, true);§card.addCounters(CounterType.TIME.createInstance(3), game);§game.addEffect(new GainSuspendEffect(new MageObjectReference(card, game)), source);§}§return true;§}§return false;§}§}§
public class Riftsweeper extends CardImpl {§private static final FilterCard filter = new FilterCard("face-up exiled card");§static {§filter.add(Predicates.not(new FaceDownPredicate()));§}§public Riftsweeper(UUID ownerId) {§super(ownerId, 159, "Riftsweeper", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "MMA";§this.subtype.add("Elf");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new EntersBattlefieldTriggeredAbility(new RiftsweeperEffect(), false);§ability.addTarget(new TargetCardInExile(1, 1, filter, null, true));§this.addAbility(ability);§}§public Riftsweeper(final Riftsweeper card) {§super(card);§}§@Override§public Riftsweeper copy() {§return new Riftsweeper(this);§}§}§class RiftsweeperEffect extends OneShotEffect {§public RiftsweeperEffect() {§super(Outcome.Benefit);§this.staticText = "choose target face-up exiled card. Its owner shuffles it into his or her library";§}§public RiftsweeperEffect(final RiftsweeperEffect effect) {§super(effect);§}§@Override§public RiftsweeperEffect copy() {§return new RiftsweeperEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Card card = game.getCard(targetPointer.getFirst(game, source));§if (card != null) {§card.getCounters(game).clear();§card.moveToZone(Zone.LIBRARY, source.getSourceId(), game, true);§game.getPlayer(card.getOwnerId()).shuffleLibrary(game);§game.informPlayers(new StringBuilder("Riftsweeper: Choosen card was ").append(card.getName()).toString());§return true;§}§return false;§}§}§
public class BallyrushBanneret extends CardImpl {§private static final FilterCard filter = new FilterCard("Kithkin spells and Soldier spells");§static {§filter.add(Predicates.or(§new SubtypePredicate("Kithkin"),§new SubtypePredicate("Soldier")));§}§public BallyrushBanneret(UUID ownerId) {§super(ownerId, 1, "Ballyrush Banneret", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "MOR";§this.subtype.add("Kithkin");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new SpellsCostReductionControllerEffect(filter, 1)));§}§public BallyrushBanneret(final BallyrushBanneret card) {§super(card);§}§@Override§public BallyrushBanneret copy() {§return new BallyrushBanneret(this);§}§}§
public class Earthbrawn extends CardImpl {§public Earthbrawn(UUID ownerId) {§super(ownerId, 119, "Earthbrawn", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{G}");§this.expansionSetCode = "MOR";§this.getSpellAbility().addEffect(new BoostTargetEffect(3, 3, Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.addAbility(new ReinforceAbility(1, new ManaCostsImpl("{1}{G}")));§}§public Earthbrawn(final Earthbrawn card) {§super(card);§}§@Override§public Earthbrawn copy() {§return new Earthbrawn(this);§}§}§
public class InspiredSprite extends CardImpl {§private static final FilterSpell filter = new FilterSpell("Wizard");§static {§filter.add(new SubtypePredicate("Wizard"));§}§public InspiredSprite(UUID ownerId) {§super(ownerId, 37, "Inspired Sprite", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "MOR";§this.subtype.add("Faerie");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlashAbility.getInstance());§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SpellCastControllerTriggeredAbility(new UntapSourceEffect(), filter, true));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawDiscardControllerEffect(), new TapSourceCost()));§}§public InspiredSprite(final InspiredSprite card) {§super(card);§}§@Override§public InspiredSprite copy() {§return new InspiredSprite(this);§}§}§
public class NightshadeSchemers extends CardImpl {§public NightshadeSchemers(UUID ownerId) {§super(ownerId, 69, "Nightshade Schemers", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{B}");§this.expansionSetCode = "MOR";§this.subtype.add("Faerie");§this.subtype.add("Wizard");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new KinshipAbility(new LoseLifeOpponentsEffect(2)));§}§public NightshadeSchemers(final NightshadeSchemers card) {§super(card);§}§@Override§public NightshadeSchemers copy() {§return new NightshadeSchemers(this);§}§}§
public class RoarOfTheCrowd extends CardImpl {§public RoarOfTheCrowd(UUID ownerId) {§super(ownerId, 100, "Roar of the Crowd", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{3}{R}");§this.expansionSetCode = "MOR";§TargetCreatureOrPlayer target = new TargetCreatureOrPlayer();§this.getSpellAbility().addTarget(target);§this.getSpellAbility().addEffect(new RoarOfTheCrowdEffect());§}§public RoarOfTheCrowd(final RoarOfTheCrowd card) {§super(card);§}§@Override§public RoarOfTheCrowd copy() {§return new RoarOfTheCrowd(this);§}§}§class RoarOfTheCrowdEffect extends OneShotEffect {§RoarOfTheCrowdEffect() {§super(Outcome.LoseLife);§this.staticText = "Choose a creature type. {this} deals damage to target creature or player equal to the number of permanents you control of the chosen type.";§}§RoarOfTheCrowdEffect(final RoarOfTheCrowdEffect effect) {§super(effect);§}§@Override§public RoarOfTheCrowdEffect copy() {§return new RoarOfTheCrowdEffect(this);§}§@Override public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§Choice typeChoice = new ChoiceImpl(true);§typeChoice.setMessage("Choose a creature type:");§typeChoice.setChoices(CardRepository.instance.getCreatureTypes());§while (!player.choose(Outcome.LoseLife, typeChoice, game)) {§if (!player.canRespond()) {§return false;§}§}§FilterControlledPermanent filter = new FilterControlledPermanent();§filter.add(new SubtypePredicate(typeChoice.getChoice()));§return new DamageTargetEffect(new PermanentsOnBattlefieldCount(filter)).apply(game, source);§}§return false;§}§}§
public class ThievesFortune extends CardImpl {§public ThievesFortune(UUID ownerId) {§super(ownerId, 54, "Thieves' Fortune", Rarity.UNCOMMON, new CardType[]{CardType.TRIBAL, CardType.INSTANT}, "{2}{U}");§this.expansionSetCode = "MOR";§this.subtype.add("Rogue");§this.addAbility(new ProwlAbility(this, "{U}"));§this.getSpellAbility().addEffect(new LookLibraryAndPickControllerEffect(new StaticValue(4), false, new StaticValue(1), new FilterCard(), Zone.LIBRARY, false, false));§}§public ThievesFortune(final ThievesFortune card) {§super(card);§}§@Override§public ThievesFortune copy() {§return new ThievesFortune(this);§}§}§
public class AvengerEnDal extends CardImpl {§public AvengerEnDal(UUID ownerId) {§super(ownerId, 2, "Avenger en-Dal", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "NMS";§this.subtype.add("Human");§this.subtype.add("Spellshaper");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ExileTargetEffect(), new ManaCostsImpl("{2}{W}"));§ability.addCost(new TapSourceCost());§ability.addCost(new DiscardCardCost());§ability.addTarget(new TargetAttackingCreature());§ability.addEffect(new AvengerEnDalEffect());§this.addAbility(ability);§}§public AvengerEnDal(final AvengerEnDal card) {§super(card);§}§@Override§public AvengerEnDal copy() {§return new AvengerEnDal(this);§}§}§class AvengerEnDalEffect extends OneShotEffect {§public AvengerEnDalEffect() {§super(Outcome.GainLife);§staticText = "Its controller gains life equal to its toughness";§}§public AvengerEnDalEffect(final AvengerEnDalEffect effect) {§super(effect);§}§@Override§public AvengerEnDalEffect copy() {§return new AvengerEnDalEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanentOrLKIBattlefield(getTargetPointer().getFirst(game, source));§if (permanent != null) {§Player player = game.getPlayer(permanent.getControllerId());§if (player != null) {§player.gainLife(permanent.getToughness().getValue(), game);§}§return true;§}§return false;§}§}§
public class JoltingMerfolk extends CardImpl {§public JoltingMerfolk(UUID ownerId) {§super(ownerId, 34, "Jolting Merfolk", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{U}{U}");§this.expansionSetCode = "NMS";§this.subtype.add("Merfolk");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new FadingAbility(4, this));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TapTargetEffect(),§new RemoveCountersSourceCost(CounterType.FADE.createInstance()));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public JoltingMerfolk(final JoltingMerfolk card) {§super(card);§}§@Override§public JoltingMerfolk copy() {§return new JoltingMerfolk(this);§}§}§
public class PlagueWitch extends CardImpl {§public PlagueWitch(UUID ownerId) {§super(ownerId, 66, "Plague Witch", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "NMS";§this.subtype.add("Elf");§this.subtype.add("Spellshaper");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(-1, -1, Duration.EndOfTurn), new ManaCostsImpl("{B}"));§ability.addCost(new TapSourceCost());§ability.addCost(new DiscardCardCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public PlagueWitch(final PlagueWitch card) {§super(card);§}§@Override§public PlagueWitch copy() {§return new PlagueWitch(this);§}§}§
public class SivvisRuse extends CardImpl {§private static final FilterPermanent filterMountain = new FilterPermanent();§private static final FilterPermanent filterPlains = new FilterPermanent();§static {§filterMountain.add(new SubtypePredicate(("Mountain")));§filterPlains.add(new SubtypePredicate(("Plains")));§}§public SivvisRuse(UUID ownerId) {§super(ownerId, 21, "Sivvi's Ruse", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{2}{W}{W}");§this.expansionSetCode = "NMS";§Condition condition = new CompoundCondition("If an opponent controls a Mountain and you control a Plains",§new OpponentControlsPermanentCondition(filterMountain),§new PermanentsOnTheBattlefieldCondition(filterPlains));§this.addAbility(new AlternativeCostSourceAbility(null, condition));§this.getSpellAbility().addEffect(new PreventAllDamageToAllEffect(Duration.EndOfTurn, new FilterControlledCreatureInPlay()));§}§public SivvisRuse(final SivvisRuse card) {§super(card);§}§@Override§public SivvisRuse copy() {§return new SivvisRuse(this);§}§}§
public class AlloyMyr extends CardImpl {§public AlloyMyr(UUID ownerId) {§super(ownerId, 129, "Alloy Myr", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{3}");§this.expansionSetCode = "NPH";§this.subtype.add("Myr");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new AnyColorManaAbility());§}§public AlloyMyr(final AlloyMyr card) {§super(card);§}§@Override§public AlloyMyr copy() {§return new AlloyMyr(this);§}§}§
public class ChancellorOfTheDross extends CardImpl {§private static String abilityText = "at the beginning of the first upkeep, each opponent loses 3 life, then you gain life equal to the life lost this way";§public ChancellorOfTheDross(UUID ownerId) {§super(ownerId, 54, "Chancellor of the Dross", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{B}{B}{B}");§this.expansionSetCode = "NPH";§this.subtype.add("Vampire");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(new ChancellorAbility(new ChancellorOfTheDrossDelayedTriggeredAbility(), abilityText));§this.addAbility(FlyingAbility.getInstance());§this.addAbility(LifelinkAbility.getInstance());§}§public ChancellorOfTheDross(final ChancellorOfTheDross card) {§super(card);§}§@Override§public ChancellorOfTheDross copy() {§return new ChancellorOfTheDross(this);§}§}§class ChancellorOfTheDrossDelayedTriggeredAbility extends DelayedTriggeredAbility {§ChancellorOfTheDrossDelayedTriggeredAbility () {§super(new ChancellorOfTheDrossEffect());§}§ChancellorOfTheDrossDelayedTriggeredAbility(ChancellorOfTheDrossDelayedTriggeredAbility ability) {§super(ability);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.UPKEEP_STEP_PRE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§return true;§}§@Override§public ChancellorOfTheDrossDelayedTriggeredAbility copy() {§return new ChancellorOfTheDrossDelayedTriggeredAbility(this);§}§}§class ChancellorOfTheDrossEffect extends OneShotEffect {§ChancellorOfTheDrossEffect () {§super(Outcome.Benefit);§staticText = "each opponent loses 3 life, then you gain life equal to the life lost this way";§}§ChancellorOfTheDrossEffect(ChancellorOfTheDrossEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§int loseLife = 0;§for (UUID opponentId : game.getOpponents(source.getControllerId())) {§loseLife += game.getPlayer(opponentId).loseLife(3, game);§}§if (loseLife > 0) {§game.getPlayer(source.getControllerId()).gainLife(loseLife, game);§}§return true;§}§@Override§public ChancellorOfTheDrossEffect copy() {§return new ChancellorOfTheDrossEffect(this);§}§}§
public class EvilPresence extends CardImpl {§public EvilPresence(UUID ownerId) {§super(ownerId, 60, "Evil Presence", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{B}");§this.expansionSetCode = "NPH";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetLandPermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));§this.addAbility(new EnchantAbility(auraTarget.getTargetName()));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BecomesBasicLandEnchantedEffect("Swamp")));§}§public EvilPresence(final EvilPresence card) {§super(card);§}§@Override§public EvilPresence copy() {§return new EvilPresence(this);§}§}§
public class ImmolatingSouleater extends CardImpl {§public ImmolatingSouleater(UUID ownerId) {§super(ownerId, 139, "Immolating Souleater", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{2}");§this.expansionSetCode = "NPH";§this.subtype.add("Hound");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD,§new BoostSourceEffect(1, 0, Duration.EndOfTurn),§new PhyrexianManaCost(ColoredManaSymbol.R)));§}§public ImmolatingSouleater(final ImmolatingSouleater card) {§super(card);§}§@Override§public ImmolatingSouleater copy() {§return new ImmolatingSouleater(this);§}§}§
public class Mindcrank extends CardImpl {§public Mindcrank(UUID ownerId) {§super(ownerId, 144, "Mindcrank", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "NPH";§this.addAbility(new MindcrankTriggeredAbility());§}§public Mindcrank(final Mindcrank card) {§super(card);§}§@Override§public Mindcrank copy() {§return new Mindcrank(this);§}§}§class MindcrankTriggeredAbility extends TriggeredAbilityImpl {§public MindcrankTriggeredAbility() {§super(Zone.BATTLEFIELD, new MindcrankEffect(), false);§}§public MindcrankTriggeredAbility(final MindcrankTriggeredAbility ability) {§super(ability);§}§@Override§public MindcrankTriggeredAbility copy() {§return new MindcrankTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.LOST_LIFE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§Set<UUID> opponents = game.getOpponents(this.getControllerId());§if (opponents.contains(event.getPlayerId())) {§for (Effect effect : this.getEffects()) {§effect.setValue("lostLife", event.getAmount());§effect.setTargetPointer(new FixedTarget(event.getPlayerId()));§}§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever an opponent loses life, that player puts that many cards from the top of his or her library into his or her graveyard.";§}§}§class MindcrankEffect extends OneShotEffect {§public MindcrankEffect() {§super(Outcome.Detriment);§}§public MindcrankEffect(final MindcrankEffect effect) {§super(effect);§}§@Override§public MindcrankEffect copy() {§return new MindcrankEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player targetPlayer = game.getPlayer(getTargetPointer().getFirst(game, source));§if (targetPlayer != null) {§Integer amount = (Integer) getValue("lostLife");§if (amount == null) {§amount = 0;§}§targetPlayer.moveCards(targetPlayer.getLibrary().getTopCards(game, amount), Zone.LIBRARY, Zone.GRAVEYARD, source, game);§}§return true;§}§}§
public class PhyrexianSwarmlord extends CardImpl {§public PhyrexianSwarmlord(UUID ownerId) {§super(ownerId, 119, "Phyrexian Swarmlord", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{G}{G}");§this.expansionSetCode = "NPH";§this.subtype.add("Insect");§this.subtype.add("Horror");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(InfectAbility.getInstance());§this.addAbility(new OnEventTriggeredAbility(EventType.UPKEEP_STEP_PRE, "beginning of your upkeep",§new CreateTokenEffect(new InsectInfectToken(), new OpponentsPoisonCountersCount())));§}§public PhyrexianSwarmlord(final PhyrexianSwarmlord card) {§super(card);§}§@Override§public PhyrexianSwarmlord copy() {§return new PhyrexianSwarmlord(this);§}§}§class OpponentsPoisonCountersCount implements DynamicValue {§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§int amount = 0;§Set<UUID> playerList = game.getOpponents(sourceAbility.getControllerId());§for (UUID playerUUID : playerList) {§Player player = game.getPlayer(playerUUID);§if (player != null) {§amount += player.getCounters().getCount(CounterType.POISON);§}§}§return amount;§}§@Override§public DynamicValue copy() {§return new OpponentsPoisonCountersCount();§}§@Override§public String toString() {§return "1";§}§@Override§public String getMessage() {§return "poison counter your opponents have";§}§}§
public class ShatteredAngel extends CardImpl {§private static final FilterPermanent filter = new FilterLandPermanent("a land");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public ShatteredAngel (UUID ownerId) {§super(ownerId, 23, "Shattered Angel", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{W}{W}");§this.expansionSetCode = "NPH";§this.subtype.add("Angel");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EntersBattlefieldAllTriggeredAbility(§Zone.BATTLEFIELD, new GainLifeEffect(3), filter, true, "Whenever a land enters the battlefield under an opponent's control, you may gain 3 life."));§}§public ShatteredAngel (final ShatteredAngel card) {§super(card);§}§@Override§public ShatteredAngel copy() {§return new ShatteredAngel(this);§}§}§
public class TezzeretsGambit extends CardImpl {§public TezzeretsGambit(UUID ownerId) {§super(ownerId, 47, "Tezzeret's Gambit", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{3}{UP}");§this.expansionSetCode = "NPH";§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(2));§this.getSpellAbility().addEffect(new ProliferateEffect());§}§public TezzeretsGambit(final TezzeretsGambit card) {§super(card);§}§@Override§public TezzeretsGambit copy() {§return new TezzeretsGambit(this);§}§}§
public class Whipflare extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("nonartifact creature");§static {§filter.add(Predicates.not(new CardTypePredicate(CardType.ARTIFACT)));§}§public Whipflare(UUID ownerId) {§super(ownerId, 102, "Whipflare", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{1}{R}");§this.expansionSetCode = "NPH";§this.getSpellAbility().addEffect(new DamageAllEffect(2, filter));§}§public Whipflare(final Whipflare card) {§super(card);§}§@Override§public Whipflare copy() {§return new Whipflare(this);§}§}§
public class DancingScimitar extends CardImpl {§public DancingScimitar(UUID ownerId) {§super(ownerId, 292, "Dancing Scimitar", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{4}");§this.expansionSetCode = "9ED";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§}§public DancingScimitar(final DancingScimitar card) {§super(card);§}§@Override§public DancingScimitar copy() {§return new DancingScimitar(this);§}§}§
public class GreaterGood extends CardImpl {§public GreaterGood(UUID ownerId) {§super(ownerId, 245, "Greater Good", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{2}{G}{G}");§this.expansionSetCode = "9ED";§Effect effect = new DrawCardSourceControllerEffect(new SacrificeCostCreaturesPower());§effect.setText("Draw cards equal to the sacrificed creature's power");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new SacrificeTargetCost(new TargetControlledCreaturePermanent(new FilterControlledCreaturePermanent("a creature"))));§effect = new DiscardControllerEffect(3);§effect.setText(", then discard three cards");§ability.addEffect(effect);§this.addAbility(ability);§}§public GreaterGood(final GreaterGood card) {§super(card);§}§@Override§public GreaterGood copy() {§return new GreaterGood(this);§}§}§
public class Plagiarize extends CardImpl {§public Plagiarize(UUID ownerId) {§super(ownerId, 89, "Plagiarize", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{3}{U}");§this.expansionSetCode = "9ED";§this.getSpellAbility().addTarget(new TargetPlayer());§this.getSpellAbility().addEffect(new PlagiarizeEffect());§}§public Plagiarize(final Plagiarize card) {§super(card);§}§@Override§public Plagiarize copy() {§return new Plagiarize(this);§}§}§class PlagiarizeEffect extends ReplacementEffectImpl {§public PlagiarizeEffect() {§super(Duration.EndOfTurn, Outcome.Detriment);§staticText = "Until end of turn, if target player would draw a card, instead that player skips that draw and you draw a card";§}§public PlagiarizeEffect(final PlagiarizeEffect effect) {§super(effect);§}§@Override§public PlagiarizeEffect copy() {§return new PlagiarizeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§player.drawCards(1, game, event.getAppliedEffects());§}§return true;§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.DRAW_CARD;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (event.getPlayerId().equals(source.getFirstTarget())) {§return true;§}§return false;§}§}§
public class ThoughtCourier extends CardImpl {§public ThoughtCourier(UUID ownerId) {§super(ownerId, 104, "Thought Courier", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "9ED";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawDiscardControllerEffect(), new TapSourceCost()));§}§public ThoughtCourier(final ThoughtCourier card) {§super(card);§}§@Override§public ThoughtCourier copy() {§return new ThoughtCourier(this);§}§}§
public class BalothPup extends CardImpl {§private final String rule = "{this} has trample as long as it has a +1/+1 counter on it";§public BalothPup(UUID ownerId) {§super(ownerId, 127, "Baloth Pup", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "OGW";§this.subtype.add("Beast");§this.power = new MageInt(3);§this.toughness = new MageInt(1);§Effect effect = new ConditionalContinuousEffect(new GainAbilitySourceEffect(TrampleAbility.getInstance()), new SourceHasCounterCondition(CounterType.P1P1), rule);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§}§public BalothPup(final BalothPup card) {§super(card);§}§@Override§public BalothPup copy() {§return new BalothPup(this);§}§}§
public class CrumblingVestige extends CardImpl {§public CrumblingVestige(UUID ownerId) {§super(ownerId, 170, "Crumbling Vestige", Rarity.COMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "OGW";§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new EntersBattlefieldTriggeredAbility(new AddManaOfAnyColorEffect()));§this.addAbility(new ColorlessManaAbility());§}§public CrumblingVestige(final CrumblingVestige card) {§super(card);§}§@Override§public CrumblingVestige copy() {§return new CrumblingVestige(this);§}§}§
public class Expedite extends CardImpl {§public Expedite(UUID ownerId) {§super(ownerId, 108, "Expedite", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{R}");§this.expansionSetCode = "OGW";§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));§}§public Expedite(final Expedite card) {§super(card);§}§@Override§public Expedite copy() {§return new Expedite(this);§}§}§
public class InverterOfTruth extends CardImpl {§public InverterOfTruth(UUID ownerId) {§super(ownerId, 72, "Inverter of Truth", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{2}{B}{B}");§this.expansionSetCode = "OGW";§this.subtype.add("Eldrazi");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(new DevoidAbility(this.color));§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new ExileLibraryEffect(), false));§}§public InverterOfTruth(final InverterOfTruth card) {§super(card);§}§@Override§public InverterOfTruth copy() {§return new InverterOfTruth(this);§}§}§class ExileLibraryEffect extends OneShotEffect {§public ExileLibraryEffect() {§super(Outcome.Exile);§staticText = "exile all cards from your library face down, then shuffle all cards from your graveyard into your library";§}§@java.lang.Override§public ExileLibraryEffect copy() {§return new ExileLibraryEffect();§}§@java.lang.Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int count = controller.getLibrary().size();§if (count > 0) {§for (Card cardToExile: controller.getLibrary().getCards(game)) {§cardToExile.moveToExile(null, "", source.getSourceId(), game);§cardToExile.setFaceDown(true, game);§}§}§for (Card cardToLibrary: controller.getGraveyard().getCards(game)) {§controller.moveCardToLibraryWithInfo(cardToLibrary, source.getSourceId(), game, Zone.GRAVEYARD, true, true);§}§controller.shuffleLibrary(game);§return true;§}§return false;§}§}§
public class MalakirSoothsayer extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("untapped Ally you control");§static {§filter.add(new SubtypePredicate("Ally"));§filter.add(Predicates.not(new TappedPredicate()));§}§public MalakirSoothsayer(UUID ownerId) {§super(ownerId, 87, "Malakir Soothsayer", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{B}");§this.expansionSetCode = "OGW";§this.subtype.add("Vampire");§this.subtype.add("Shaman");§this.subtype.add("Ally");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new DrawCardSourceControllerEffect(1),§new TapSourceCost());§ability.setAbilityWord(AbilityWord.COHORT);§ability.addCost(new TapTargetCost(new TargetControlledCreaturePermanent(1, 1, filter, false)));§Effect effect = new LoseLifeSourceControllerEffect(1);§effect.setText("and you lose a life");§ability.addEffect(effect);§this.addAbility(ability);§}§public MalakirSoothsayer(final MalakirSoothsayer card) {§super(card);§}§@Override§public MalakirSoothsayer copy() {§return new MalakirSoothsayer(this);§}§}§
public class PressIntoService extends CardImpl {§public PressIntoService(UUID ownerId) {§super(ownerId, 114, "Press into Service", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{4}{R}");§this.expansionSetCode = "OGW";§getSpellAbility().addEffect(new SupportEffect(this, 2, false));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§Effect effect = new GainControlTargetEffect(Duration.EndOfTurn);§effect.setTargetPointer(new SecondTargetPointer()); §
public class SeersLantern extends CardImpl {§public SeersLantern(UUID ownerId) {§super(ownerId, 165, "Seer's Lantern", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "OGW";§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ScryEffect(1), new GenericManaCost(2));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public SeersLantern(final SeersLantern card) {§super(card);§}§@Override§public SeersLantern copy() {§return new SeersLantern(this);§}§}§
public class TarSnare extends CardImpl {§public TarSnare(UUID ownerId) {§super(ownerId, 90, "Tar Snare", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{B}");§this.expansionSetCode = "OGW";§this.getSpellAbility().addEffect(new BoostTargetEffect(-3, -2, Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public TarSnare(final TarSnare card) {§super(card);§}§@Override§public TarSnare copy() {§return new TarSnare(this);§}§}§
public class WardenOfGeometries extends CardImpl {§public WardenOfGeometries(UUID ownerId) {§super(ownerId, 11, "Warden of Geometries", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}");§this.expansionSetCode = "OGW";§this.subtype.add("Eldrazi");§this.subtype.add("Drone");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(new ColorlessManaAbility());§}§public WardenOfGeometries(final WardenOfGeometries card) {§super(card);§}§@Override§public WardenOfGeometries copy() {§return new WardenOfGeometries(this);§}§}§
public class AvenArcher extends CardImpl {§public AvenArcher(UUID ownerId) {§super(ownerId, 6, "Aven Archer", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{W}{W}");§this.expansionSetCode = "ODY";§this.subtype.add("Bird");§this.subtype.add("Soldier");§this.subtype.add("Archer");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(2), new ManaCostsImpl("{2}{W}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetAttackingOrBlockingCreature());§this.addAbility(ability);§}§public AvenArcher(final AvenArcher card) {§super(card);§}§@Override§public AvenArcher copy() {§return new AvenArcher(this);§}§}§
public class CabalPit extends CardImpl {§public CabalPit(UUID ownerId) {§super(ownerId, 315, "Cabal Pit", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "ODY";§Ability manaAbility = new BlackManaAbility();§manaAbility.addEffect(new DamageControllerEffect(1));§this.addAbility(manaAbility);§Ability thresholdAbility = new ConditionalActivatedAbility(Zone.BATTLEFIELD,§new BoostTargetEffect(-2,-2, Duration.EndOfTurn),§new ManaCostsImpl("{B}"),§new CardsInControllerGraveCondition(7));§thresholdAbility.addCost(new TapSourceCost());§thresholdAbility.addCost(new SacrificeSourceCost());§thresholdAbility.addTarget(new TargetCreaturePermanent());§thresholdAbility.setAbilityWord(AbilityWord.THRESHOLD);§this.addAbility(thresholdAbility);§}§public CabalPit(final CabalPit card) {§super(card);§}§@Override§public CabalPit copy() {§return new CabalPit(this);§}§}§
public class Confessor extends CardImpl {§public Confessor(UUID ownerId) {§super(ownerId, 15, "Confessor", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{W}");§this.expansionSetCode = "ODY";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SimpleTriggeredAbility(§Zone.BATTLEFIELD, EventType.DISCARDED_CARD, new GainLifeEffect(1), "Whenever a player discards a card, you may", false, true));§}§public Confessor(final Confessor card) {§super(card);§}§@Override§public Confessor copy() {§return new Confessor(this);§}§}§
public class DoggedHunter extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature token");§static {§filter.add(new TokenPredicate());§}§public DoggedHunter(UUID ownerId) {§super(ownerId, 20, "Dogged Hunter", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "ODY";§this.subtype.add("Human");§this.subtype.add("Nomad");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public DoggedHunter(final DoggedHunter card) {§super(card);§}§@Override§public DoggedHunter copy() {§return new DoggedHunter(this);§}§}§
public class FledglingImp extends CardImpl {§public FledglingImp(UUID ownerId) {§super(ownerId, 137, "Fledgling Imp", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "ODY";§this.subtype.add("Imp");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilitySourceEffect(FlyingAbility.getInstance(), Duration.EndOfTurn), new ManaCostsImpl("{B}"));§ability.addCost(new DiscardCardCost());§this.addAbility(ability);§}§public FledglingImp(final FledglingImp card) {§super(card);§}§@Override§public FledglingImp copy() {§return new FledglingImp(this);§}§}§
public class Lithatog extends CardImpl {§public Lithatog(UUID ownerId) {§super(ownerId, 289, "Lithatog", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{R}{G}");§this.expansionSetCode = "ODY";§this.subtype.add("Atog");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(new SimpleActivatedAbility(§Zone.BATTLEFIELD,§new BoostSourceEffect(1,1, Duration.EndOfTurn),§new SacrificeTargetCost(new TargetControlledPermanent(new FilterControlledArtifactPermanent("an artifact")))));§this.addAbility(new SimpleActivatedAbility(§Zone.BATTLEFIELD,§new BoostSourceEffect(1,1, Duration.EndOfTurn),§new SacrificeTargetCost(new TargetControlledPermanent(new FilterControlledLandPermanent("a land")))));§}§public Lithatog(final Lithatog card) {§super(card);§}§@Override§public Lithatog copy() {§return new Lithatog(this);§}§}§
public class NantukoElder extends CardImpl {§public NantukoElder(UUID ownerId) {§super(ownerId, 254, "Nantuko Elder", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "ODY";§this.subtype.add("Insect");§this.subtype.add("Druid");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(new SimpleManaAbility(Zone.BATTLEFIELD, new Mana(0, 1, 0, 0, 0, 0, 0, 1), new TapSourceCost()));§}§public NantukoElder(final NantukoElder card) {§super(card);§}§@Override§public NantukoElder copy() {§return new NantukoElder(this);§}§}§
public class Predict extends CardImpl {§public Predict(UUID ownerId) {§super(ownerId, 94, "Predict", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "ODY";§this.getSpellAbility().addEffect(new NameACardEffect(NameACardEffect.TypeOfName.ALL));§this.getSpellAbility().addEffect(new PredictEffect());§this.getSpellAbility().addTarget(new TargetPlayer());§}§public Predict(final Predict card) {§super(card);§}§@Override§public Predict copy() {§return new Predict(this);§}§}§class PredictEffect extends OneShotEffect {§public PredictEffect() {§super(Outcome.DrawCard);§this.staticText = ", then target player puts the top card of his or her library into his or her graveyard. "§+ "If that card is the named card, you draw two cards. Otherwise, you draw a card.";§}§public PredictEffect(final PredictEffect effect) {§super(effect);§}§@Override§public PredictEffect copy() {§return new PredictEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Player targetPlayer = game.getPlayer(source.getFirstTarget());§String cardName = (String) game.getState().getValue(source.getSourceId().toString() + NameACardEffect.INFO_KEY);§if (controller != null && targetPlayer != null && cardName != null && !cardName.isEmpty()) {§int amount = 1;§Card card = targetPlayer.getLibrary().getFromTop(game);§if (card != null) {§controller.moveCards(card, Zone.LIBRARY, Zone.GRAVEYARD, source, game);§if (card.getName().equals(cardName)) {§amount = 2;§}§}§controller.drawCards(amount, game);§return true;§}§return false;§}§}§
public class SavageFirecat extends CardImpl {§public SavageFirecat(UUID ownerId) {§super(ownerId, 218, "Savage Firecat", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{R}{R}");§this.expansionSetCode = "ODY";§this.subtype.add("Elemental");§this.subtype.add("Cat");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new EntersBattlefieldAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance(7))));§this.addAbility(new SavageFirecatTriggeredAbility(new RemoveCounterSourceEffect(CounterType.P1P1.createInstance())));§}§public SavageFirecat(final SavageFirecat card) {§super(card);§}§@Override§public SavageFirecat copy() {§return new SavageFirecat(this);§}§}§class SavageFirecatTriggeredAbility extends TriggeredAbilityImpl {§public SavageFirecatTriggeredAbility(Effect effect) {§super(Zone.BATTLEFIELD, effect, false);§}§public SavageFirecatTriggeredAbility(final SavageFirecatTriggeredAbility ability) {§super(ability);§}§@Override§public SavageFirecatTriggeredAbility copy() {§return new SavageFirecatTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.TAPPED_FOR_MANA;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§return game.getCard(event.getSourceId()).getCardType().contains(CardType.LAND) &&§event.getPlayerId().equals(this.controllerId);§}§@Override§public String getRule() {§return "Whenever you tap a land for mana, remove a +1/+1 counter from {this}";§}§}§
public class StalkingBloodsucker extends CardImpl {§public StalkingBloodsucker(UUID ownerId) {§super(ownerId, 163, "Stalking Bloodsucker", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{B}{B}");§this.expansionSetCode = "ODY";§this.subtype.add("Vampire");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(2, 2, Duration.EndOfTurn), new ManaCostsImpl("{1}{B}"));§ability.addCost(new DiscardCardCost());§this.addAbility(ability);§}§public StalkingBloodsucker(final StalkingBloodsucker card) {§super(card);§}§@Override§public StalkingBloodsucker copy() {§return new StalkingBloodsucker(this);§}§}§
public class TreetopSentinel extends CardImpl {§public static final FilterCard filter = new FilterCard("green");§static {§filter.add(new ColorPredicate(ObjectColor.GREEN));§}§public TreetopSentinel(UUID ownerId) {§super(ownerId, 111, "Treetop Sentinel", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{U}{U}");§this.expansionSetCode = "ODY";§this.subtype.add("Bird");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new ProtectionAbility(filter));§}§public TreetopSentinel(final TreetopSentinel card) {§super(card);§}§@Override§public TreetopSentinel copy() {§return new TreetopSentinel(this);§}§}§
public class AirdropCondor extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("a Goblin creature");§static {§filter.add(new SubtypePredicate("Goblin"));§}§public AirdropCondor(UUID ownerId) {§super(ownerId, 186, "Airdrop Condor", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{R}");§this.expansionSetCode = "ONS";§this.subtype.add("Bird");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(new SacrificeCostCreaturesPower()), new ManaCostsImpl("{1}{R}"));§ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent(filter)));§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public AirdropCondor(final AirdropCondor card) {§super(card);§}§@Override§public AirdropCondor copy() {§return new AirdropCondor(this);§}§}§
public class BloodstainedMire extends CardImpl {§public BloodstainedMire(UUID ownerId) {§super(ownerId, 313, "Bloodstained Mire", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "ONS";§this.addAbility(new FetchLandActivatedAbility(new String[]{"Swamp", "Mountain"}));§}§public BloodstainedMire(final BloodstainedMire card) {§super(card);§}§@Override§public BloodstainedMire copy() {§return new BloodstainedMire(this);§}§}§
public class DaruCavalier extends CardImpl {§private static final FilterCard filter = new FilterCard("card named Daru Cavalier");§static {§filter.add(new NamePredicate("Daru Cavalier"));§}§public DaruCavalier(UUID ownerId) {§super(ownerId, 18, "Daru Cavalier", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "ONS";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FirstStrikeAbility.getInstance());§TargetCardInLibrary target = new TargetCardInLibrary(0, 1, filter);§this.addAbility(new EntersBattlefieldTriggeredAbility(new SearchLibraryPutInHandEffect(target, true, true), true));§}§public DaruCavalier(final DaruCavalier card) {§super(card);§}§@Override§public DaruCavalier copy() {§return new DaruCavalier(this);§}§}§
public class EvergloveCourier extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Elf creature");§static {§filter.add(new SubtypePredicate("Elf"));§}§public EvergloveCourier(UUID ownerId) {§super(ownerId, 262, "Everglove Courier", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "ONS";§this.subtype.add("Elf");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new SkipUntapOptionalAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(§new BoostTargetEffect(2, 2, Duration.Custom), SourceTappedCondition.getInstance(),§"target Elf creature gets +2/+2"), new ManaCostsImpl("{2}{G}"));§ability.addEffect(new ConditionalContinuousEffect(new GainAbilityTargetEffect(TrampleAbility.getInstance(),§Duration.Custom), SourceTappedCondition.getInstance(),"and has trample for as long as {this} remains tapped"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public EvergloveCourier(final EvergloveCourier card) {§super(card);§}§@Override§public EvergloveCourier copy() {§return new EvergloveCourier(this);§}§}§
public class GoblinSledder extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("a Goblin");§static {§filter.add(new SubtypePredicate("Goblin"));§}§public GoblinSledder(UUID ownerId) {§super(ownerId, 209, "Goblin Sledder", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "ONS";§this.subtype.add("Goblin");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(1,1,Duration.EndOfTurn),§new SacrificeTargetCost(new TargetControlledCreaturePermanent(1,1, filter, true)));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public GoblinSledder(final GoblinSledder card) {§super(card);§}§@Override§public GoblinSledder copy() {§return new GoblinSledder(this);§}§}§
public class Insurrection extends CardImpl {§public Insurrection(UUID ownerId) {§super(ownerId, 213, "Insurrection", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{5}{R}{R}{R}");§this.expansionSetCode = "ONS";§this.getSpellAbility().addEffect(new InsurrectionEffect());§}§public Insurrection(final Insurrection card) {§super(card);§}§@Override§public Insurrection copy() {§return new Insurrection(this);§}§}§class InsurrectionEffect extends OneShotEffect {§public InsurrectionEffect() {§super(Outcome.Benefit);§this.staticText = "Untap all creatures and gain control of them until end of turn. They gain haste until end of turn";§}§public InsurrectionEffect(final InsurrectionEffect effect) {§super(effect);§}§@Override§public InsurrectionEffect copy() {§return new InsurrectionEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§boolean result = false;§ContinuousEffect gainControl = new GainControlTargetEffect(Duration.EndOfTurn);§ContinuousEffect gainHaste = new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.EndOfTurn);§for (Permanent creature : game.getBattlefield().getAllActivePermanents(CardType.CREATURE)) {§creature.untap(game);§gainControl.setTargetPointer(new FixedTarget(creature.getId()));§gainHaste.setTargetPointer(new FixedTarget(creature.getId()));§game.addEffect(gainControl, source);§game.addEffect(gainHaste, source);§result = true;§}§return result;§}§}§
public class PeerPressure extends CardImpl {§public PeerPressure(UUID ownerId) {§super(ownerId, 101, "Peer Pressure", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{U}");§this.expansionSetCode = "ONS";§this.getSpellAbility().addEffect(new PeerPressureEffect());§}§public PeerPressure(final PeerPressure card) {§super(card);§}§@Override§public PeerPressure copy() {§return new PeerPressure(this);§}§}§class PeerPressureEffect extends OneShotEffect {§PeerPressureEffect() {§super(Outcome.GainControl);§this.staticText = "Choose a creature type. If you control more creatures of that type than each other player, you gain control of all creatures of that type";§}§PeerPressureEffect(final PeerPressureEffect effect) {§super(effect);§}§@Override§public PeerPressureEffect copy() {§return new PeerPressureEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Choice choice = new ChoiceImpl(true);§choice.setMessage("Choose creature type");§choice.setChoices(CardRepository.instance.getCreatureTypes());§while (!controller.choose(Outcome.GainControl, choice, game)) {§if (!controller.canRespond()) {§return false;§}§}§String chosenType = choice.getChoice();§if (!game.isSimulation()) {§game.informPlayers(controller.getLogName() + " has chosen " + chosenType);§}§UUID playerWithMost = null;§int maxControlled = 0;§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§FilterPermanent filter = new FilterCreaturePermanent(chosenType, chosenType);§filter.add(new ControllerIdPredicate(playerId));§int controlled = new PermanentsOnBattlefieldCount(filter).calculate(game, source, this);§if (controlled > maxControlled) {§maxControlled = controlled;§playerWithMost = playerId;§} else if (controlled == maxControlled) {§playerWithMost = null; §
public class ShepherdOfRot extends CardImpl {§final String rule = "Each player loses 1 life for each Zombie on the battlefield";§static final private FilterPermanent filter = new FilterPermanent("Zombie");§static {§filter.add(new SubtypePredicate("Zombie"));§}§public ShepherdOfRot(UUID ownerId) {§super(ownerId, 168, "Shepherd of Rot", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "ONS";§this.subtype.add("Zombie");§this.subtype.add("Cleric");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new LoseLifeAllPlayersEffect(new PermanentsOnBattlefieldCount(filter), rule), new TapSourceCost()));§}§public ShepherdOfRot(final ShepherdOfRot card) {§super(card);§}§@Override§public ShepherdOfRot copy() {§return new ShepherdOfRot(this);§}§}§
public class SteelyResolve extends CardImpl {§public SteelyResolve(UUID ownerId) {§super(ownerId, 286, "Steely Resolve", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{1}{G}");§this.expansionSetCode = "ONS";§this.addAbility(new AsEntersBattlefieldAbility(new ChooseCreatureTypeEffect(Outcome.AddAbility)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAllEffect(ShroudAbility.getInstance(), Duration.WhileOnBattlefield, new FilterSteelyResolve())));§}§public SteelyResolve(final SteelyResolve card) {§super(card);§}§@Override§public SteelyResolve copy() {§return new SteelyResolve(this);§}§}§class FilterSteelyResolve extends FilterCreaturePermanent {§public FilterSteelyResolve() {§super("All creatures of the chosen type");§}§public FilterSteelyResolve(final FilterSteelyResolve filter) {§super(filter);§}§@Override§public FilterSteelyResolve copy() {§return new FilterSteelyResolve(this);§}§@Override§public boolean match(Permanent permanent, UUID sourceId, UUID playerId, Game game) {§if (super.match(permanent, sourceId, playerId, game)) {§String subtype = (String) game.getState().getValue(sourceId + "_type");§if (subtype != null && !subtype.equals("") && permanent.hasSubtype(subtype)) {§return true;§}§}§return false;§}§}§
public class VoidmageProdigy extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("a Wizard");§static {§filter.add(new SubtypePredicate("Wizard"));§}§public VoidmageProdigy(UUID ownerId) {§super(ownerId, 120, "Voidmage Prodigy", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{U}{U}");§this.expansionSetCode = "ONS";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CounterTargetEffect(), new ManaCostsImpl("{U}{U}"));§ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent(1, 1, filter, false)));§Target target = new TargetSpell();§ability.addTarget(target);§this.addAbility(ability);§this.addAbility(new MorphAbility(this, new ManaCostsImpl("{U}")));§}§public VoidmageProdigy(final VoidmageProdigy card) {§super(card);§}§@Override§public VoidmageProdigy copy() {§return new VoidmageProdigy(this);§}§}§
public class ExoticCurse extends CardImpl {§public ExoticCurse(UUID ownerId) {§super(ownerId, 56, "Exotic Curse", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{B}");§this.expansionSetCode = "DDE";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetPermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.UnboostCreature));§this.addAbility(new EnchantAbility(auraTarget.getTargetName()));§DynamicValue unboost = new SignInversionDynamicValue(new DomainValue());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD,§new BoostEnchantedEffect(unboost, unboost, Duration.WhileOnBattlefield)));§}§public ExoticCurse(final ExoticCurse card) {§super(card);§}§@Override§public ExoticCurse copy() {§return new ExoticCurse(this);§}§}§
public class BruteForce extends CardImpl {§public BruteForce(UUID ownerId) {§super(ownerId, 116, "Brute Force", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{R}");§this.expansionSetCode = "PLC";§this.getSpellAbility().getEffects().add(new BoostTargetEffect(3,3, Duration.EndOfTurn));§this.getSpellAbility().getTargets().add(new TargetCreaturePermanent());§}§public BruteForce(final BruteForce card) {§super(card);§}§@Override§public BruteForce copy() {§return new BruteForce(this);§}§}§
public class EvolutionCharm extends CardImpl {§private static FilterCreatureCard filter = new FilterCreatureCard("creature card from your graveyard");§public EvolutionCharm(UUID ownerId) {§super(ownerId, 127, "Evolution Charm", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{G}");§this.expansionSetCode = "PLC";§this.getSpellAbility().addEffect(new SearchLibraryPutInHandEffect(new TargetCardInLibrary(0, 1, new FilterBasicLandCard()), true, true));§Mode mode = new Mode();§mode.getEffects().add(new ReturnToHandTargetEffect());§mode.getTargets().add(new TargetCardInYourGraveyard(filter));§this.getSpellAbility().addMode(mode);§mode = new Mode();§mode.getEffects().add(new GainAbilityTargetEffect(FlyingAbility.getInstance(), Duration.EndOfTurn));§mode.getTargets().add(new TargetCreaturePermanent());§this.getSpellAbility().addMode(mode);§}§public EvolutionCharm(final EvolutionCharm card) {§super(card);§}§@Override§public EvolutionCharm copy() {§return new EvolutionCharm(this);§}§}§
public class ImpsMischief extends CardImpl {§private static final FilterSpell filter = new FilterSpell("spell with a single target");§static {§filter.add(new NumberOfTargetsPredicate(1));§}§public ImpsMischief(UUID ownerId) {§super(ownerId, 72, "Imp's Mischief", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{1}{B}");§this.expansionSetCode = "PLC";§this.getSpellAbility().addEffect(new ChooseNewTargetsTargetEffect(true, true));§this.getSpellAbility().addEffect(new ImpsMischiefLoseLifeEffect());§this.getSpellAbility().addTarget(new TargetSpell(filter));§}§public ImpsMischief(final ImpsMischief card) {§super(card);§}§@Override§public ImpsMischief copy() {§return new ImpsMischief(this);§}§}§class ImpsMischiefLoseLifeEffect extends OneShotEffect {§public ImpsMischiefLoseLifeEffect() {§super(Outcome.LoseLife);§staticText = "You lose life equal to that spell's converted mana cost";§}§public ImpsMischiefLoseLifeEffect(final ImpsMischiefLoseLifeEffect effect) {§super(effect);§}§@Override§public ImpsMischiefLoseLifeEffect copy() {§return new ImpsMischiefLoseLifeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Spell spell = game.getStack().getSpell(source.getFirstTarget());§if (spell != null) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§player.loseLife(spell.getConvertedManaCost(), game);§return true;§}§}§return false;§}§}§
public class NullProfusion extends CardImpl {§public NullProfusion(UUID ownerId) {§super(ownerId, 89, "Null Profusion", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{4}{B}{B}");§this.expansionSetCode = "PLC";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new SkipDrawStepEffect()));§this.addAbility(new NullProfusionTriggeredAbility());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new MaximumHandSizeControllerEffect(2, Duration.WhileOnBattlefield, HandSizeModification.SET)));§}§public NullProfusion(final NullProfusion card) {§super(card);§}§@Override§public NullProfusion copy() {§return new NullProfusion(this);§}§}§class NullProfusionTriggeredAbility extends TriggeredAbilityImpl {§NullProfusionTriggeredAbility() {§super(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1), false);§}§NullProfusionTriggeredAbility(final NullProfusionTriggeredAbility ability) {§super(ability);§}§@Override§public NullProfusionTriggeredAbility copy() {§return new NullProfusionTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.SPELL_CAST || event.getType() == EventType.LAND_PLAYED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§return event.getPlayerId().equals(this.getControllerId());§}§@Override§public String getRule() {§return "Whenever you play a card, draw a card.";§}§}§
public class RoilingHorror extends CardImpl {§public RoilingHorror(UUID ownerId) {§super(ownerId, 79, "Roiling Horror", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{B}{B}");§this.expansionSetCode = "PLC";§this.subtype.add("Horror");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(new SimpleStaticAbility(Zone.ALL, new SetPowerToughnessSourceEffect(new RoilingHorrorDynamicValue(), Duration.EndOfGame)));§this.addAbility(new SuspendAbility(Integer.MAX_VALUE, new ManaCostsImpl("{B}{B}{B}"), this, true));§this.addAbility(new RoilingHorrorTriggeredAbility());§}§public RoilingHorror(final RoilingHorror card) {§super(card);§}§@Override§public RoilingHorror copy() {§return new RoilingHorror(this);§}§}§class RoilingHorrorTriggeredAbility extends TriggeredAbilityImpl {§public RoilingHorrorTriggeredAbility() {§super(Zone.EXILED, new LoseLifeTargetEffect(1), false);§this.addTarget(new TargetPlayer());§Effect effect = new GainLifeEffect(1);§effect.setText("and you gain 1 life");§this.addEffect(effect);§}§public RoilingHorrorTriggeredAbility(final RoilingHorrorTriggeredAbility ability) {§super(ability);§}§@Override§public RoilingHorrorTriggeredAbility copy() {§return new RoilingHorrorTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.COUNTER_REMOVED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§return event.getData().equals(CounterType.TIME.getName()) && event.getTargetId().equals(this.getSourceId());§}§@Override§public String getRule() {§return "Whenever a time counter is removed from {this} while it's exiled, " + super.getRule();§}§}§class RoilingHorrorDynamicValue implements DynamicValue {§@Override§public int calculate(Game game, Ability sourceAbility, Effect effect) {§int opponentsMostLife = Integer.MIN_VALUE;§Player controller = game.getPlayer(sourceAbility.getControllerId());§if (controller != null) {§for (UUID playerUUID : game.getState().getPlayersInRange(controller.getId(), game)) {§if (controller.hasOpponent(playerUUID, game)) {§Player opponent = game.getPlayer(playerUUID);§if (opponent != null && opponent.getLife() > opponentsMostLife) {§opponentsMostLife = opponent.getLife();§}§}§}§return controller.getLife() - opponentsMostLife;§}§return 0;§}§@Override§public DynamicValue copy() {§return this;§}§@Override§public String toString() {§return "X";§}§@Override§public String getMessage() {§return "your life total minus the life total of an opponent with the most life";§}§}§
public class Tidewalker extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("Island you control");§static {§filter.add(new SubtypePredicate("Island"));§}§public Tidewalker(UUID ownerId) {§super(ownerId, 49, "Tidewalker", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "PLC";§this.subtype.add("Elemental");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(new EntersBattlefieldAbility(new AddCountersSourceEffect(CounterType.TIME.createInstance(0), new PermanentsOnBattlefieldCount(filter), true), "with a time counter on it for each Island you control"));§this.addAbility(new VanishingUpkeepAbility(0));§this.addAbility(new VanishingSacrificeAbility());§this.addAbility(new SimpleStaticAbility(Zone.ALL, new SetPowerToughnessSourceEffect(new CountersCount(CounterType.TIME), Duration.EndOfGame)));§}§public Tidewalker(final Tidewalker card) {§super(card);§}§@Override§public Tidewalker copy() {§return new Tidewalker(this);§}§}§
public class BoshIronGolem extends CardImpl {§public BoshIronGolem(UUID ownerId) {§super(ownerId, 108, "Bosh, Iron Golem", Rarity.RARE, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{8}");§this.expansionSetCode = "HOP";§this.supertype.add("Legendary");§this.subtype.add("Golem");§this.power = new MageInt(6);§this.toughness = new MageInt(7);§this.addAbility(TrampleAbility.getInstance());§Effect effect = new DamageTargetEffect(new SacrificeCostConvertedMana("artifact"));§effect.setText("{this} deals damage equal to the sacrificed artifact's converted mana cost to target creature or player");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl("{3}{R}"));§ability.addCost(new SacrificeTargetCost(new TargetControlledPermanent(new FilterControlledArtifactPermanent("an artifact"))));§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public BoshIronGolem(final BoshIronGolem card) {§super(card);§}§@Override§public BoshIronGolem copy() {§return new BoshIronGolem(this);§}§}§
public class LodestoneMyr extends CardImpl {§private static final FilterControlledArtifactPermanent filter = new FilterControlledArtifactPermanent("untapped artifact you control");§static {§filter.add(Predicates.not(new TappedPredicate()));§}§public LodestoneMyr(UUID ownerId) {§super(ownerId, 117, "Lodestone Myr", Rarity.RARE, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{4}");§this.expansionSetCode = "HOP";§this.subtype.add("Myr");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(TrampleAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 1, Duration.EndOfTurn), new TapTargetCost(new TargetControlledPermanent(filter))));§}§public LodestoneMyr(final LodestoneMyr card) {§super(card);§}§@Override§public LodestoneMyr copy() {§return new LodestoneMyr(this);§}§}§
public class TaureanMauler extends CardImpl {§public TaureanMauler(UUID ownerId) {§super(ownerId, 67, "Taurean Mauler", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "HOP";§this.subtype.add("Shapeshifter");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(ChangelingAbility.getInstance());§this.addAbility(new SpellCastOpponentTriggeredAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance()), true));§}§public TaureanMauler(final TaureanMauler card) {§super(card);§}§@Override§public TaureanMauler copy() {§return new TaureanMauler(this);§}§}§
public class KrosanVerge extends CardImpl {§private static final FilterCard filterForest = new FilterCard("a Forest");§private static final FilterCard filterPlains = new FilterCard("a Plains");§static {§filterForest.add(new SubtypePredicate("Forest"));§filterPlains.add(new SubtypePredicate("Plains"));§}§public KrosanVerge(UUID ownerId) {§super(ownerId, 123, "Krosan Verge", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "PC2";§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new ColorlessManaAbility());§Effect effect = new SearchLibraryPutInPlayEffect(new TargetCardInLibrary(filterForest), true, Outcome.PutLandInPlay);§effect.setText("Search your library for a Forest card and a Plains card and put them onto the battlefield tapped. Then shuffle your library");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new GenericManaCost(2));§effect = new SearchLibraryPutInPlayEffect(new TargetCardInLibrary(filterPlains), true, Outcome.PutLandInPlay);§effect.setText(null);§ability.addEffect(effect);§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public KrosanVerge(final KrosanVerge card) {§super(card);§}§@Override§public KrosanVerge copy() {§return new KrosanVerge(this);§}§}§
public class WhirlpoolWarrior extends CardImpl {§public WhirlpoolWarrior(UUID ownerId) {§super(ownerId, 29, "Whirlpool Warrior", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "PC2";§this.subtype.add("Merfolk");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new EntersBattlefieldTriggeredAbility(new ShuffleHandIntoLibraryDrawThatManySourceEffect()));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new WhirlpoolWarriorActivatedEffect(), new ManaCostsImpl("{R}"));§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public WhirlpoolWarrior(final WhirlpoolWarrior card) {§super(card);§}§@Override§public WhirlpoolWarrior copy() {§return new WhirlpoolWarrior(this);§}§}§class WhirlpoolWarriorActivatedEffect extends OneShotEffect {§public WhirlpoolWarriorActivatedEffect() {§super(Outcome.Benefit);§this.staticText = "Each player shuffles the cards from his or her hand into his or her library, then draws that many cards";§}§public WhirlpoolWarriorActivatedEffect(final WhirlpoolWarriorActivatedEffect effect) {§super(effect);§}§@Override§public WhirlpoolWarriorActivatedEffect copy() {§return new WhirlpoolWarriorActivatedEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Map<UUID, Integer> playerCards = new LinkedHashMap<>();§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§int cardsHand = player.getHand().size();§if (cardsHand > 0) {§playerCards.put(playerId, cardsHand);§player.moveCards(player.getHand(), Zone.LIBRARY, source, game);§player.shuffleLibrary(game);§}§}§}§for (Entry<UUID, Integer> entry : playerCards.entrySet()) {§Player player = game.getPlayer(entry.getKey());§if (player != null) {§player.drawCards(entry.getValue(), game);§}§}§return true;§}§return false;§}§}§
public class DiscipleOfKangee extends CardImpl {§public DiscipleOfKangee(UUID ownerId) {§super(ownerId, 3, "Disciple of Kangee", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "PLS";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Effect effect = new GainAbilityTargetEffect(FlyingAbility.getInstance(), Duration.EndOfTurn);§effect.setText("Target creature gains flying");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl("{U}"));§effect = new BecomesColorTargetEffect(ObjectColor.BLUE, Duration.EndOfTurn);§effect.setText("and becomes blue until end of turn.");§ability.addEffect(effect);§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public DiscipleOfKangee(final DiscipleOfKangee card) {§super(card);§}§@Override§public DiscipleOfKangee copy() {§return new DiscipleOfKangee(this);§}§}§
public class KeldonMantle extends CardImpl {§public KeldonMantle(UUID ownerId) {§super(ownerId, 65, "Keldon Mantle", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{R}");§this.expansionSetCode = "PLS";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateAttachedEffect(AttachmentType.AURA), new ManaCostsImpl("{B}")));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(1, 0, Duration.EndOfTurn),§new ManaCostsImpl("{R}")));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(TrampleAbility.getInstance(),§AttachmentType.AURA, Duration.EndOfTurn), new ManaCostsImpl("{G}")));§}§public KeldonMantle(final KeldonMantle card) {§super(card);§}§@Override§public KeldonMantle copy() {§return new KeldonMantle(this);§}§}§
public class PhyrexianScuta extends CardImpl {§public PhyrexianScuta(UUID ownerId) {§super(ownerId, 51, "Phyrexian Scuta", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{B}");§this.expansionSetCode = "PLS";§this.subtype.add("Zombie");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new KickerAbility(new PayLifeCost(3)));§this.addAbility(new EntersBattlefieldAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance(2)), KickedCondition.getInstance(), "If Phyrexian Scuta was kicked, it enters the battlefield with two +1/+1 counters on it.", ""));§}§public PhyrexianScuta(final PhyrexianScuta card) {§super(card);§}§@Override§public PhyrexianScuta copy() {§return new PhyrexianScuta(this);§}§}§
public class Singe extends CardImpl {§public Singe(UUID ownerId) {§super(ownerId, 71, "Singe", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{R}");§this.expansionSetCode = "PLS";§this.getSpellAbility().addEffect(new DamageTargetEffect(1));§Effect effect = new BecomesColorTargetEffect(ObjectColor.BLACK, Duration.EndOfTurn);§effect.setText("That creature becomes black until end of turn.");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public Singe(final Singe card) {§super(card);§}§@Override§public Singe copy() {§return new Singe(this);§}§}§
public class TrevasRuins extends CardImpl {§private static final FilterControlledLandPermanent filter = new FilterControlledLandPermanent("non-Lair land");§static{§filter.add(Predicates.not(new SubtypePredicate("Lair")));§}§public TrevasRuins(UUID ownerId) {§super(ownerId, 143, "Treva's Ruins", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "PLS";§this.subtype.add("Lair");§this.addAbility(new EntersBattlefieldTriggeredAbility(new SacrificeSourceUnlessPaysEffect(new ReturnToHandChosenControlledPermanentCost(new TargetControlledPermanent(filter)))));§this.addAbility(new GreenManaAbility());§this.addAbility(new WhiteManaAbility());§this.addAbility(new BlueManaAbility());§}§public TrevasRuins(final TrevasRuins card) {§super(card);§}§@Override§public TrevasRuins copy() {§return new TrevasRuins(this);§}§}§
public class Devastation extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("creatures and lands");§static {§filter.add(Predicates.or(new CardTypePredicate(CardType.CREATURE), new CardTypePredicate(CardType.LAND)));§}§public Devastation(UUID ownerId) {§super(ownerId, 128, "Devastation", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{5}{R}{R}");§this.expansionSetCode = "POR";§this.getSpellAbility().addEffect(new DestroyAllEffect(filter));§}§public Devastation(final Devastation card) {§super(card);§}§@Override§public Devastation copy() {§return new Devastation(this);§}§}§
public class MercenaryKnight extends CardImpl {§public MercenaryKnight(UUID ownerId) {§super(ownerId, 22, "Mercenary Knight", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "POR";§this.subtype.add("Human");§this.subtype.add("Mercenary");§this.subtype.add("Knight");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new EntersBattlefieldTriggeredAbility(new SacrificeSourceUnlessPaysEffect(new DiscardTargetCost(new TargetCardInHand(new FilterCreatureCard("a creature card"))))));§}§public MercenaryKnight(final MercenaryKnight card) {§super(card);§}§@Override§public MercenaryKnight copy() {§return new MercenaryKnight(this);§}§}§
public class SpiritualGuardian extends CardImpl {§public SpiritualGuardian(UUID ownerId) {§super(ownerId, 189, "Spiritual Guardian", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{W}{W}");§this.expansionSetCode = "POR";§this.subtype.add("Spirit");§this.power = new MageInt(3);§this.toughness = new MageInt(4);§this.addAbility(new EntersBattlefieldTriggeredAbility(new GainLifeEffect(4), false));§}§public SpiritualGuardian(final SpiritualGuardian card) {§super(card);§}§@Override§public SpiritualGuardian copy() {§return new SpiritualGuardian(this);§}§}§
public class AbyssalNightstalker extends CardImpl {§public AbyssalNightstalker(UUID ownerId) {§super(ownerId, 1, "Abyssal Nightstalker", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{B}");§this.expansionSetCode = "PO2";§this.subtype.add("Nightstalker");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Effect effect = new DiscardTargetEffect(1);§effect.setText("defending player discards a card");§this.addAbility(new AttacksAndIsNotBlockedTriggeredAbility(effect, false, true));§}§public AbyssalNightstalker(final AbyssalNightstalker card) {§super(card);§}§@Override§public AbyssalNightstalker copy() {§return new AbyssalNightstalker(this);§}§}§
public class Extinguish extends CardImpl {§private static final FilterSpell filter = new FilterSpell("sorcery spell");§static {§filter.add(new CardTypePredicate(CardType.SORCERY));§}§public Extinguish(UUID ownerId) {§super(ownerId, 38, "Extinguish", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "PO2";§this.getSpellAbility().addTarget(new TargetSpell(filter));§this.getSpellAbility().addEffect(new CounterTargetEffect());§}§public Extinguish(final Extinguish card) {§super(card);§}§@Override§public Extinguish copy() {§return new Extinguish(this);§}§}§
public class OgreBerserker extends CardImpl {§public OgreBerserker(UUID ownerId) {§super(ownerId, 111, "Ogre Berserker", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{R}");§this.expansionSetCode = "PO2";§this.subtype.add("Ogre");§this.subtype.add("Berserker");§this.power = new MageInt(4);§this.toughness = new MageInt(2);§this.addAbility(HasteAbility.getInstance());§}§public OgreBerserker(final OgreBerserker card) {§super(card);§}§@Override§public OgreBerserker copy() {§return new OgreBerserker(this);§}§}§
public class TrokinHighGuard extends CardImpl {§public TrokinHighGuard(UUID ownerId) {§super(ownerId, 146, "Trokin High Guard", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "PO2";§this.subtype.add("Human");§this.subtype.add("Knight");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§}§public TrokinHighGuard(final TrokinHighGuard card) {§super(card);§}§@Override§public TrokinHighGuard copy() {§return new TrokinHighGuard(this);§}§}§
public class DiaochanArtfulBeauty extends CardImpl {§public DiaochanArtfulBeauty(UUID ownerId) {§super(ownerId, 108, "Diaochan, Artful Beauty", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{R}");§this.expansionSetCode = "PTK";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Advisor");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new ActivateIfConditionActivatedAbility(Zone.BATTLEFIELD, new DiaochanArtfulBeautyDestroyEffect(), new TapSourceCost(), MyTurnBeforeAttackersDeclaredCondition.getInstance());§ability.addTarget(new TargetCreaturePermanent());§ability.addTarget(new TargetOpponentsChoicePermanent(new FilterCreaturePermanent()));§this.addAbility(ability);§}§public DiaochanArtfulBeauty(final DiaochanArtfulBeauty card) {§super(card);§}§@Override§public DiaochanArtfulBeauty copy() {§return new DiaochanArtfulBeauty(this);§}§}§class DiaochanArtfulBeautyDestroyEffect extends OneShotEffect {§DiaochanArtfulBeautyDestroyEffect() {§super(Outcome.DestroyPermanent);§this.staticText = "Destroy target creature of your choice, then destroy target creature of an opponent's choice";§}§DiaochanArtfulBeautyDestroyEffect(final DiaochanArtfulBeautyDestroyEffect effect) {§super(effect);§}§@Override§public DiaochanArtfulBeautyDestroyEffect copy() {§return new DiaochanArtfulBeautyDestroyEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Permanent firstTarget = game.getPermanent(source.getFirstTarget());§if (firstTarget != null) {§firstTarget.destroy(source.getSourceId(), game, false);§}§Permanent secondTarget = game.getPermanent(source.getTargets().get(1).getFirstTarget());§if (secondTarget != null) {§secondTarget.destroy(source.getSourceId(), game, false);§}§return true;§}§return false;§}§}§
public class MaChaoWesternWarrior extends CardImpl {§public MaChaoWesternWarrior(UUID ownerId) {§super(ownerId, 116, "Ma Chao, Western Warrior", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{R}{R}");§this.expansionSetCode = "PTK";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Soldier");§this.subtype.add("Warrior");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(HorsemanshipAbility.getInstance());§Effect effect = new CantBeBlockedSourceEffect(Duration.EndOfCombat);§effect.setText("it can't be blocked this combat");§this.addAbility(new AttacksAloneTriggeredAbility(effect));§}§public MaChaoWesternWarrior(final MaChaoWesternWarrior card) {§super(card);§}§@Override§public MaChaoWesternWarrior copy() {§return new MaChaoWesternWarrior(this);§}§}§
public class ShuFootSoldiers extends CardImpl {§public ShuFootSoldiers(UUID ownerId) {§super(ownerId, 24, "Shu Foot Soldiers", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "PTK";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§}§public ShuFootSoldiers(final ShuFootSoldiers card) {§super(card);§}§@Override§public ShuFootSoldiers copy() {§return new ShuFootSoldiers(this);§}§}§
public class WeiAmbushForce extends CardImpl {§public WeiAmbushForce(UUID ownerId) {§super(ownerId, 85, "Wei Ambush Force", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "PTK";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new AttacksTriggeredAbility(new BoostSourceEffect(2, 0, Duration.EndOfTurn), false));§}§public WeiAmbushForce(final WeiAmbushForce card) {§super(card);§}§@Override§public WeiAmbushForce copy() {§return new WeiAmbushForce(this);§}§}§
public class ZhangLiaoHeroOfHefei extends CardImpl {§public ZhangLiaoHeroOfHefei(UUID ownerId) {§super(ownerId, 96, "Zhang Liao, Hero of Hefei", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{B}{B}");§this.expansionSetCode = "PTK";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new DealsDamageToOpponentTriggeredAbility(new DiscardTargetEffect(1), false, false, true));§}§public ZhangLiaoHeroOfHefei(final ZhangLiaoHeroOfHefei card) {§super(card);§}§@Override§public ZhangLiaoHeroOfHefei copy() {§return new ZhangLiaoHeroOfHefei(this);§}§}§
public class Glory extends CardImpl {§public Glory(UUID ownerId) {§super(ownerId, 17, "Glory", Rarity.SPECIAL, new CardType[]{CardType.CREATURE}, "{3}{W}{W}");§this.expansionSetCode = "PTC";§this.subtype.add("Incarnation");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§Effect effect = new GainProtectionFromColorAllEffect(Duration.EndOfTurn, new FilterControlledCreaturePermanent("Creatures you control"));§effect.setText("Choose a color. Creatures you control gain protection from the chosen color until end of turn. Activate this ability only if {this} is in your graveyard.");§this.addAbility(new SimpleActivatedAbility(Zone.GRAVEYARD, effect, new ManaCostsImpl("{2}{W}")));§}§public Glory(final Glory card) {§super(card);§}§@Override§public Glory copy() {§return new Glory(this);§}§}§
public class FaultRiders extends CardImpl {§public FaultRiders(UUID ownerId) {§super(ownerId, 88, "Fault Riders", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "PCY";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Effect effect = new BoostSourceEffect(2,0, Duration.EndOfTurn);§effect.setText("{this} gets +2/+0");§Ability ability = new LimitedTimesPerTurnActivatedAbility(Zone.BATTLEFIELD,§effect,§new SacrificeTargetCost(new TargetControlledPermanent(new FilterControlledLandPermanent("a land"))));§effect = new GainAbilitySourceEffect(FirstStrikeAbility.getInstance(), Duration.EndOfTurn);§effect.setText("and gains first strike");§ability.addEffect(effect);§this.addAbility(ability);§}§public FaultRiders(final FaultRiders card) {§super(card);§}§@Override§public FaultRiders copy() {§return new FaultRiders(this);§}§}§
public class MercenaryInformer extends CardImpl {§private static final FilterObject filterBlack = new FilterStackObject("black spells or abilities from black sources");§private static final FilterPermanent filterMercenary = new FilterPermanent("nontoken Mercenary");§static {§filterBlack.add(new ColorPredicate(ObjectColor.BLACK));§filterMercenary.add(Predicates.not(new TokenPredicate()));§filterMercenary.add(new SubtypePredicate("Mercenary"));§}§public MercenaryInformer(UUID ownerId) {§super(ownerId, 15, "Mercenary Informer", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "PCY";§this.subtype.add("Human");§this.subtype.add("Rebel");§this.subtype.add("Mercenary");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CantBeTargetedSourceEffect(filterBlack, Duration.WhileOnBattlefield)));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PutOnLibraryTargetEffect(false), new ManaCostsImpl("{2}{W}"));§ability.addTarget(new TargetPermanent(filterMercenary));§this.addAbility(ability);§}§public MercenaryInformer(final MercenaryInformer card) {§super(card);§}§@Override§public MercenaryInformer copy() {§return new MercenaryInformer(this);§}§}§
public class ShieldDancer extends CardImpl {§public ShieldDancer(UUID ownerId) {§super(ownerId, 23, "Shield Dancer", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "PCY";§this.subtype.add("Human");§this.subtype.add("Rebel");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ShieldDancerRedirectionEffect(), new ManaCostsImpl("{2}{W}"));§ability.addTarget(new TargetAttackingCreature());§this.addAbility(ability);§}§public ShieldDancer(final ShieldDancer card) {§super(card);§}§@Override§public ShieldDancer copy() {§return new ShieldDancer(this);§}§}§class ShieldDancerRedirectionEffect extends RedirectionEffect {§public ShieldDancerRedirectionEffect() {§super(Duration.EndOfTurn);§staticText = "The next time target attacking creature would deal combat damage to {this} this turn, that creature deals that damage to itself instead";§}§public ShieldDancerRedirectionEffect(final ShieldDancerRedirectionEffect effect) {§super(effect);§}§@Override§public ShieldDancerRedirectionEffect copy() {§return new ShieldDancerRedirectionEffect(this);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGE_CREATURE;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (event.getTargetId().equals(source.getSourceId())§&& event.getSourceId().equals(source.getTargets().get(0).getFirstTarget())) {§DamageEvent damageEvent = (DamageEvent) event;§if (damageEvent.isCombatDamage()) {§TargetPermanent target = new TargetPermanent();§target.add(source.getTargets().get(0).getFirstTarget(), game);§redirectTarget = target;§}§return true;§}§return false;§}§}§
public class WhipSergeant extends CardImpl {§public WhipSergeant(UUID ownerId) {§super(ownerId, 107, "Whip Sergeant", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "PCY";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.EndOfTurn), new ManaCostsImpl("{R}"));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public WhipSergeant(final WhipSergeant card) {§super(card);§}§@Override§public WhipSergeant copy() {§return new WhipSergeant(this);§}§}§
public class Caregiver extends CardImpl {§public Caregiver(UUID ownerId) {§super(ownerId, 6, "Caregiver", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{W}");§this.expansionSetCode = "RAV";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PreventDamageToTargetEffect(Duration.EndOfTurn, 1), new ColoredManaCost(ColoredManaSymbol.W));§ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent()));§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public Caregiver(final Caregiver card) {§super(card);§}§@Override§public Caregiver copy() {§return new Caregiver(this);§}§}§
public class DarkConfidant extends CardImpl {§public DarkConfidant(UUID ownerId) {§super(ownerId, 81, "Dark Confidant", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "RAV";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new DarkConfidantEffect(), TargetController.YOU, false));§}§public DarkConfidant(final DarkConfidant card) {§super(card);§}§@Override§public DarkConfidant copy() {§return new DarkConfidant(this);§}§}§class DarkConfidantEffect extends OneShotEffect {§DarkConfidantEffect() {§super(Outcome.DrawCard);§this.staticText = "reveal the top card of your library and put that card into your hand. You lose life equal to its converted mana cost";§}§DarkConfidantEffect(final DarkConfidantEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Permanent sourcePermanent = game.getPermanentOrLKIBattlefield(source.getSourceId());§if (controller != null && sourcePermanent != null) {§if (controller.getLibrary().size() > 0) {§Card card = controller.getLibrary().removeFromTop(game);§if (card != null) {§Cards cards = new CardsImpl(card);§controller.revealCards(sourcePermanent.getIdName(), cards, game);§controller.moveCards(card, null, Zone.HAND, source, game);§controller.loseLife(card.getManaCost().convertedManaCost(), game);§}§return true;§}§}§return false;§}§@Override§public DarkConfidantEffect copy() {§return new DarkConfidantEffect(this);§}§}§
public class EtherealUsher extends CardImpl {§public EtherealUsher(UUID ownerId) {§super(ownerId, 47, "Ethereal Usher", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{5}{U}");§this.expansionSetCode = "RAV";§this.subtype.add("Spirit");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new CantBeBlockedTargetEffect(),§new ManaCostsImpl("{U}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§this.addAbility(new TransmuteAbility("{1}{U}{U}"));§}§public EtherealUsher(final EtherealUsher card) {§super(card);§}§@Override§public EtherealUsher copy() {§return new EtherealUsher(this);§}§}§
public class GolgariGraveTroll extends CardImpl {§public GolgariGraveTroll(UUID ownerId) {§super(ownerId, 167, "Golgari Grave-Troll", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{G}");§this.expansionSetCode = "RAV";§this.subtype.add("Troll");§this.subtype.add("Skeleton");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(new EntersBattlefieldAbility(new GolgariGraveTrollEffect(), "with a +1/+1 counter on it for each creature card in your graveyard"));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new ManaCostsImpl("{1}"));§ability.addCost(new RemoveCountersSourceCost(CounterType.P1P1.createInstance()));§this.addAbility(ability);§this.addAbility(new DredgeAbility(6));§}§public GolgariGraveTroll(final GolgariGraveTroll card) {§super(card);§}§@Override§public GolgariGraveTroll copy() {§return new GolgariGraveTroll(this);§}§}§class GolgariGraveTrollEffect extends OneShotEffect {§private static final FilterCreatureCard filter = new FilterCreatureCard();§static {§filter.add(new CardTypePredicate(CardType.CREATURE));§}§public GolgariGraveTrollEffect() {§super(Outcome.BoostCreature);§}§public GolgariGraveTrollEffect(final GolgariGraveTrollEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§Permanent permanent = game.getPermanentEntering(source.getSourceId());§if (permanent != null && player != null) {§int amount = player.getGraveyard().count(filter, game);§if (amount > 0) {§permanent.addCounters(CounterType.P1P1.createInstance(amount), game);§}§return true;§}§return false;§}§@Override§public GolgariGraveTrollEffect copy() {§return new GolgariGraveTrollEffect(this);§}§}§
public class HuntedPhantasm extends CardImpl {§public HuntedPhantasm(UUID ownerId) {§super(ownerId, 55, "Hunted Phantasm", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{U}{U}");§this.expansionSetCode = "RAV";§this.subtype.add("Spirit");§this.power = new MageInt(4);§this.toughness = new MageInt(6);§this.addAbility(new CantBeBlockedSourceAbility());§Ability ability = new EntersBattlefieldTriggeredAbility(new CreateTokenTargetEffect(new GoblinToken(), 5), false);§Target target = new TargetOpponent();§ability.addTarget(target);§this.addAbility(ability);§}§public HuntedPhantasm(final HuntedPhantasm card) {§super(card);§}§@Override§public HuntedPhantasm copy() {§return new HuntedPhantasm(this);§}§}§
public class MuddleTheMixture extends CardImpl {§private static final FilterSpell filter = new FilterSpell("instant or sorcery spell");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.INSTANT),§new CardTypePredicate(CardType.SORCERY)));§}§public MuddleTheMixture(UUID ownerId) {§super(ownerId, 60, "Muddle the Mixture", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{U}{U}");§this.expansionSetCode = "RAV";§this.getSpellAbility().addTarget(new TargetSpell(filter));§this.getSpellAbility().addEffect(new CounterTargetEffect());§this.addAbility(new TransmuteAbility("{1}{U}{U}"));§}§public MuddleTheMixture(final MuddleTheMixture card) {§super(card);§}§@Override§public MuddleTheMixture copy() {§return new MuddleTheMixture(this);§}§}§
public class Remand extends CardImpl {§public Remand(UUID ownerId) {§super(ownerId, 63, "Remand", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{U}");§this.expansionSetCode = "RAV";§this.getSpellAbility().addEffect(new CounterTargetWithReplacementEffect(Zone.HAND));§this.getSpellAbility().addTarget(new TargetSpell());§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));§}§public Remand(final Remand card) {§super(card);§}§@Override§public Remand copy() {§return new Remand(this);§}§}§
public class ShamblingShell extends CardImpl {§public ShamblingShell(UUID ownerId) {§super(ownerId, 230, "Shambling Shell", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}{G}");§this.expansionSetCode = "RAV";§this.subtype.add("Plant");§this.subtype.add("Zombie");§this.power = new MageInt(3);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersTargetEffect(CounterType.P1P1.createInstance()), new SacrificeSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§this.addAbility(new DredgeAbility(3));§}§public ShamblingShell(final ShamblingShell card) {§super(card);§}§@Override§public ShamblingShell copy() {§return new ShamblingShell(this);§}§}§
public class Terrarion extends CardImpl {§public Terrarion(UUID ownerId) {§super(ownerId, 273, "Terrarion", Rarity.COMMON, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "RAV";§this.addAbility(new EntersBattlefieldTappedAbility());§Ability ability = new SimpleManaAbility(Zone.BATTLEFIELD, new AddManaInAnyCombinationEffect(2), new GenericManaCost(2));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§this.addAbility(new PutIntoGraveFromBattlefieldSourceTriggeredAbility(new DrawCardSourceControllerEffect(1)));§}§public Terrarion(final Terrarion card) {§super(card);§}§@Override§public Terrarion copy() {§return new Terrarion(this);§}§}§
public class VoyagerStaff extends CardImpl {§public VoyagerStaff(UUID ownerId) {§super(ownerId, 274, "Voyager Staff", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{1}");§this.expansionSetCode = "RAV";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new VoyagerStaffEffect(), new GenericManaCost(2));§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public VoyagerStaff(final VoyagerStaff card) {§super(card);§}§@Override§public VoyagerStaff copy() {§return new VoyagerStaff(this);§}§}§class VoyagerStaffEffect extends OneShotEffect {§public VoyagerStaffEffect() {§super(Outcome.Detriment);§staticText = "exile target creature. Return the exiled card to the battlefield under its owner's control at the beginning of the next end step";§}§public VoyagerStaffEffect(final VoyagerStaffEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent creature = game.getPermanent(source.getFirstTarget());§Player controller = game.getPlayer(source.getControllerId());§Permanent sourcePermanent = game.getPermanentOrLKIBattlefield(source.getSourceId());§if (controller != null && creature != null && sourcePermanent != null) {§if (controller.moveCardToExileWithInfo(creature, source.getSourceId(), sourcePermanent.getIdName(), source.getSourceId(), game, Zone.BATTLEFIELD, true)) {§AtTheBeginOfNextEndStepDelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(new ReturnFromExileEffect(source.getSourceId(), Zone.BATTLEFIELD, false));§delayedAbility.setSourceId(source.getSourceId());§delayedAbility.setControllerId(source.getControllerId());§delayedAbility.setSourceObject(source.getSourceObject(game), game);§game.addDelayedTriggeredAbility(delayedAbility);§return true;§}§}§return false;§}§@Override§public VoyagerStaffEffect copy() {§return new VoyagerStaffEffect(this);§}§}§
public class AzoriusArrester extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature an opponent controls");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public AzoriusArrester(UUID ownerId) {§super(ownerId, 5, "Azorius Arrester", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "RTR";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Ability ability = new EntersBattlefieldTriggeredAbility(new DetainTargetEffect(), false);§TargetCreaturePermanent target = new TargetCreaturePermanent(filter);§ability.addTarget(target);§this.addAbility(ability);§}§public AzoriusArrester(final AzoriusArrester card) {§super(card);§}§@Override§public AzoriusArrester copy() {§return new AzoriusArrester(this);§}§}§
public class ChorusOfMight extends CardImpl {§public ChorusOfMight(UUID ownerId) {§super(ownerId, 119, "Chorus of Might", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{3}{G}");§this.expansionSetCode = "RTR";§PermanentsOnBattlefieldCount value = new PermanentsOnBattlefieldCount(new FilterControlledCreaturePermanent());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new BoostTargetEffect(value, value, Duration.EndOfTurn, true));§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(TrampleAbility.getInstance(), Duration.EndOfTurn));§}§public ChorusOfMight(final ChorusOfMight card) {§super(card);§}§@Override§public ChorusOfMight copy() {§return new ChorusOfMight(this);§}§}§
public class DeathriteShaman extends CardImpl {§private static final FilterCard filter = new FilterCard("instant or sorcery card from a graveyard");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.INSTANT),§new CardTypePredicate(CardType.SORCERY)));§}§public DeathriteShaman(UUID ownerId) {§super(ownerId, 213, "Deathrite Shaman", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{B/G}");§this.expansionSetCode = "RTR";§this.subtype.add("Elf");§this.subtype.add("Shaman");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ExileTargetEffect(), new TapSourceCost());§ability.addEffect(new AddManaOfAnyColorEffect());§ability.addTarget(new TargetCardInGraveyard(new FilterLandCard("land card from a graveyard")));§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ExileTargetEffect(), new ManaCostsImpl("{B}"));§ability.addCost(new TapSourceCost());§ability.addEffect(new LoseLifeOpponentsEffect(2));§ability.addTarget(new TargetCardInGraveyard(filter));§this.addAbility(ability);§ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ExileTargetEffect(), new ManaCostsImpl("{G}"));§ability.addCost(new TapSourceCost());§ability.addEffect(new GainLifeEffect(2));§ability.addTarget(new TargetCardInGraveyard(new FilterCreatureCard("creature card from a graveyard")));§this.addAbility(ability);§}§public DeathriteShaman(final DeathriteShaman card) {§super(card);§}§@Override§public DeathriteShaman copy() {§return new DeathriteShaman(this);§}§}§
public class ExplosiveImpact extends CardImpl {§public ExplosiveImpact(UUID ownerId) {§super(ownerId, 94, "Explosive Impact", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{5}{R}");§this.expansionSetCode = "RTR";§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§this.getSpellAbility().addEffect(new DamageTargetEffect(5));§}§public ExplosiveImpact(final ExplosiveImpact card) {§super(card);§}§@Override§public ExplosiveImpact copy() {§return new ExplosiveImpact(this);§}§}§
public class GroveOfTheGuardian extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("untapped creatures you control");§static {§filter.add(Predicates.not(new TappedPredicate()));§}§public GroveOfTheGuardian(UUID ownerId) {§super(ownerId, 240, "Grove of the Guardian", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "RTR";§this.addAbility(new SimpleManaAbility(Zone.BATTLEFIELD, new Mana(0, 0, 0, 0, 0, 0, 0, 1), new TapSourceCost()));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new CreateTokenEffect(new ElementalToken(), 1), new ManaCostsImpl("{3}{G}{W}"));§ability.addCost(new TapSourceCost());§ability.addCost(new TapTargetCost(new TargetControlledCreaturePermanent(2, 2, filter, false)));§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public GroveOfTheGuardian(final GroveOfTheGuardian card) {§super(card);§}§@Override§public GroveOfTheGuardian copy() {§return new GroveOfTheGuardian(this);§}§private class ElementalToken extends Token {§ElementalToken() {§super("Elemental", "an 8/8 green and white Elemental creature token with vigilance");§cardType.add(CardType.CREATURE);§color.setGreen(true);§color.setWhite(true);§this.subtype.add("Elemental");§power = new MageInt(8);§toughness = new MageInt(8);§this.addAbility(VigilanceAbility.getInstance());§}§}§}§
public class JaradsOrders extends CardImpl {§public JaradsOrders(UUID ownerId) {§super(ownerId, 175, "Jarad's Orders", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{2}{B}{G}");§this.expansionSetCode = "RTR";§this.getSpellAbility().addEffect(new JaradsOrdersEffect());§}§public JaradsOrders(final JaradsOrders card) {§super(card);§}§@Override§public JaradsOrders copy() {§return new JaradsOrders(this);§}§}§class JaradsOrdersEffect extends OneShotEffect {§protected static final FilterCard filter = new FilterCard("card to put into your hand");§public JaradsOrdersEffect() {§super(Outcome.PutLandInPlay);§staticText = "Search your library for up to two creature cards and reveal them. Put one into your hand and the other into your graveyard. Then shuffle your library";§}§public JaradsOrdersEffect(final JaradsOrdersEffect effect) {§super(effect);§}§@Override§public JaradsOrdersEffect copy() {§return new JaradsOrdersEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§TargetCardInLibrary target = new TargetCardInLibrary(0, 2, new FilterCreatureCard("creature cards"));§if (controller.searchLibrary(target, game)) {§if (target.getTargets().size() > 0) {§Cards revealed = new CardsImpl();§for (UUID cardId: (List<UUID>)target.getTargets()) {§Card card = controller.getLibrary().getCard(cardId, game);§revealed.add(card);§}§controller.revealCards("Jarad's Orders", revealed, game);§if (target.getTargets().size() == 2) {§TargetCard target2 = new TargetCard(Zone.LIBRARY, filter);§controller.choose(Outcome.Benefit, revealed, target2, game);§Card card = revealed.get(target2.getFirstTarget(), game);§controller.moveCards(card, Zone.LIBRARY, Zone.HAND, source, game);§revealed.remove(card);§card = revealed.getCards(game).iterator().next();§controller.moveCards(card, Zone.LIBRARY, Zone.GRAVEYARD, source, game);§} else if (target.getTargets().size() == 1) {§Card card = revealed.getCards(game).iterator().next();§controller.moveCards(card, Zone.LIBRARY, Zone.HAND, source, game);§}§}§controller.shuffleLibrary(game);§return true;§}§controller.shuffleLibrary(game);§}§return false;§}§}§
public class NivmagusElemental extends CardImpl {§private static final FilterSpell filter = new FilterSpell("an instant or sorcery spell you control");§static {§filter.add(new ControllerPredicate(TargetController.YOU));§filter.add(Predicates.or(§new CardTypePredicate(CardType.INSTANT),§new CardTypePredicate(CardType.SORCERY)));§}§public NivmagusElemental(UUID ownerId) {§super(ownerId, 219, "Nivmagus Elemental", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{U/R}");§this.expansionSetCode = "RTR";§this.subtype.add("Elemental");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.P1P1.createInstance(2)),new ExileFromStackCost(new TargetSpell(filter)));§this.addAbility(ability);§}§public NivmagusElemental(final NivmagusElemental card) {§super(card);§}§@Override§public NivmagusElemental copy() {§return new NivmagusElemental(this);§}§}§
public class RakdosShredFreak extends CardImpl {§public RakdosShredFreak(UUID ownerId) {§super(ownerId, 221, "Rakdos Shred-Freak", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{B/R}{B/R}");§this.expansionSetCode = "RTR";§this.subtype.add("Human");§this.subtype.add("Berserker");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(HasteAbility.getInstance());§}§public RakdosShredFreak(final RakdosShredFreak card) {§super(card);§}§@Override§public RakdosShredFreak copy() {§return new RakdosShredFreak(this);§}§}§
public class SewerShambler extends CardImpl {§public SewerShambler(UUID ownerId) {§super(ownerId, 75, "Sewer Shambler", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "RTR";§this.subtype.add("Zombie");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new SwampwalkAbility());§this.addAbility(new ScavengeAbility(new ManaCostsImpl("{2}{B}")));§}§public SewerShambler(final SewerShambler card) {§super(card);§}§@Override§public SewerShambler copy() {§return new SewerShambler(this);§}§}§
public class StreetSpasm extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature without flying you don't control");§static {§filter.add(new ControllerPredicate(TargetController.NOT_YOU));§filter.add(Predicates.not(new AbilityPredicate(FlyingAbility.class)));§}§public StreetSpasm(UUID ownerId) {§super(ownerId, 106, "Street Spasm", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{X}{R}");§this.expansionSetCode = "RTR";§this.getSpellAbility().addTarget(new TargetCreaturePermanent(filter));§this.getSpellAbility().addEffect(new DamageTargetEffect(new ManacostVariableValue()));§this.addAbility(new OverloadAbility(this, new DamageAllEffect(new ManacostVariableValue(), filter), new ManaCostsImpl("{X}{X}{R}{R}")));§}§public StreetSpasm(final StreetSpasm card) {§super(card);§}§@Override§public StreetSpasm copy() {§return new StreetSpasm(this);§}§}§
public class TrestleTroll extends CardImpl {§public TrestleTroll(UUID ownerId) {§super(ownerId, 205, "Trestle Troll", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}{G}");§this.expansionSetCode = "RTR";§this.subtype.add("Troll");§this.power = new MageInt(1);§this.toughness = new MageInt(4);§this.addAbility(DefenderAbility.getInstance());§this.addAbility(ReachAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new ManaCostsImpl("{1}{B}{G}")));§}§public TrestleTroll(final TrestleTroll card) {§super(card);§}§@Override§public TrestleTroll copy() {§return new TrestleTroll(this);§}§}§
public class DesertTwister extends CardImpl {§public DesertTwister(UUID ownerId) {§super(ownerId, 99, "Desert Twister", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{4}{G}{G}");§this.expansionSetCode = "3ED";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§this.getSpellAbility().addTarget(new TargetPermanent());§}§public DesertTwister(final DesertTwister card) {§super(card);§}§@Override§public DesertTwister copy() {§return new DesertTwister(this);§}§}§
public class BattleRampart extends CardImpl {§public BattleRampart(UUID ownerId) {§super(ownerId, 135, "Battle Rampart", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "ROE";§this.subtype.add("Wall");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§this.addAbility(DefenderAbility.getInstance());§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.EndOfTurn),§new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public BattleRampart(final BattleRampart card) {§super(card);§}§@Override§public BattleRampart copy() {§return new BattleRampart(this);§}§}§
public class DawnglareInvoker extends CardImpl {§public DawnglareInvoker(UUID ownerId) {§super(ownerId, 16, "Dawnglare Invoker", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "ROE";§this.subtype.add("Kor");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new TapAllTargetPlayerControlsEffect(new FilterCreaturePermanent("creatures")),§new ManaCostsImpl("{8}"));§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public DawnglareInvoker(final DawnglareInvoker card) {§super(card);§}§@Override§public DawnglareInvoker copy() {§return new DawnglareInvoker(this);§}§}§
public class EmrakulTheAeonsTorn extends CardImpl {§private static final FilterSpell filter = new FilterSpell("colored spells");§static {§filter.add(Predicates.not(new ColorlessPredicate()));§}§public EmrakulTheAeonsTorn(UUID ownerId) {§super(ownerId, 4, "Emrakul, the Aeons Torn", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{15}");§this.expansionSetCode = "ROE";§this.supertype.add("Legendary");§this.subtype.add("Eldrazi");§this.power = new MageInt(15);§this.toughness = new MageInt(15);§this.addAbility(new CantBeCounteredAbility());§this.addAbility(new CastSourceTriggeredAbility(new AddExtraTurnControllerEffect()));§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new ProtectionAbility(filter));§this.addAbility(new AnnihilatorAbility(6));§this.addAbility(new PutIntoGraveFromAnywhereSourceTriggeredAbility(new ShuffleIntoLibraryGraveOfSourceOwnerEffect(), false));§}§public EmrakulTheAeonsTorn(final EmrakulTheAeonsTorn card) {§super(card);§}§@Override§public EmrakulTheAeonsTorn copy() {§return new EmrakulTheAeonsTorn(this);§}§}§
public class GrotagSiegeRunner extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature with defender");§static {§filter.add(new AbilityPredicate(DefenderAbility.class));§}§public GrotagSiegeRunner(UUID ownerId) {§super(ownerId, 149, "Grotag Siege-Runner", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "ROE";§this.subtype.add("Goblin");§this.subtype.add("Rogue");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new ManaCostsImpl("{R}"));§ability.addCost(new SacrificeSourceCost());§Effect effect = new DamageTargetControllerEffect(2);§effect.setText("{this} deals 2 damage to that creature's controller");§ability.addEffect(effect);§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public GrotagSiegeRunner(final GrotagSiegeRunner card) {§super(card);§}§@Override§public GrotagSiegeRunner copy() {§return new GrotagSiegeRunner(this);§}§}§
public class KilnFiend extends CardImpl {§private static final FilterSpell filter = new FilterSpell("an instant or sorcery spell");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.INSTANT),§new CardTypePredicate(CardType.SORCERY)));§}§public KilnFiend(UUID ownerId) {§super(ownerId, 153, "Kiln Fiend", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "ROE";§this.subtype.add("Elemental");§this.subtype.add("Beast");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(new SpellCastControllerTriggeredAbility(new BoostSourceEffect(3, 0, Duration.EndOfTurn), filter, false));§}§public KilnFiend(final KilnFiend card) {§super(card);§}§@Override§public KilnFiend copy() {§return new KilnFiend(this);§}§}§
public class MerfolkSkyscout extends CardImpl {§public MerfolkSkyscout(UUID ownerId) {§super(ownerId, 77, "Merfolk Skyscout", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{U}{U}");§this.expansionSetCode = "ROE";§this.subtype.add("Merfolk");§this.subtype.add("Scout");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§AttacksOrBlocksTriggeredAbility ability = new AttacksOrBlocksTriggeredAbility(new UntapTargetEffect(), false);§ability.addTarget(new TargetPermanent());§this.addAbility(ability);§}§public MerfolkSkyscout(final MerfolkSkyscout card) {§super(card);§}§@Override§public MerfolkSkyscout copy() {§return new MerfolkSkyscout(this);§}§}§
public class PawnOfUlamog extends CardImpl {§public PawnOfUlamog(UUID ownerId) {§super(ownerId, 122, "Pawn of Ulamog", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{B}{B}");§this.expansionSetCode = "ROE";§this.subtype.add("Vampire");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new PawnOfUlamogTriggeredAbility());§}§public PawnOfUlamog(final PawnOfUlamog card) {§super(card);§}§@Override§public PawnOfUlamog copy() {§return new PawnOfUlamog(this);§}§}§class PawnOfUlamogTriggeredAbility extends TriggeredAbilityImpl {§public PawnOfUlamogTriggeredAbility() {§super(Zone.BATTLEFIELD, new CreateTokenEffect(new EldraziSpawnToken()), true);§}§public PawnOfUlamogTriggeredAbility(PawnOfUlamogTriggeredAbility ability) {§super(ability);§}§@Override§public PawnOfUlamogTriggeredAbility copy() {§return new PawnOfUlamogTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ZONE_CHANGE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§UUID targetId = event.getTargetId();§MageObject card = game.getLastKnownInformation(targetId, Zone.BATTLEFIELD);§if (card != null && card instanceof Permanent && !(card instanceof PermanentToken)) {§Permanent permanent = (Permanent) card;§ZoneChangeEvent zEvent = (ZoneChangeEvent) event;§if (zEvent.getFromZone() == Zone.BATTLEFIELD && zEvent.getToZone() == Zone.GRAVEYARD§&& permanent.getControllerId().equals(this.controllerId)§&& (targetId.equals(this.getSourceId())§|| (permanent.getCardType().contains(CardType.CREATURE)§&& !targetId.equals(this.getSourceId())§&& !(permanent instanceof PermanentToken)))) {§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever Pawn of Ulamog or another nontoken creature you control dies, you may put a 0/1 colorless Eldrazi Spawn creature token onto the battlefield. It has \"Sacrifice this creature: Add {C} to your mana pool.\"";§}§}§
public class SarkhanTheMad extends CardImpl {§public SarkhanTheMad(UUID ownerId) {§super(ownerId, 214, "Sarkhan the Mad", Rarity.MYTHIC, new CardType[]{CardType.PLANESWALKER}, "{3}{B}{R}");§this.expansionSetCode = "ROE";§this.subtype.add("Sarkhan");§this.addAbility(new PlanswalkerEntersWithLoyalityCountersAbility(7));§this.addAbility(new LoyaltyAbility(new SarkhanTheMadRevealAndDrawEffect(), 0));§Target targetCreature = new TargetCreaturePermanent();§Ability sacAbility = new LoyaltyAbility(new SarkhanTheMadSacEffect(), -2);§sacAbility.addTarget(targetCreature);§this.addAbility(sacAbility);§Ability damageAbility = new LoyaltyAbility(new SarkhanTheMadDragonDamageEffect(), -4);§damageAbility.addTarget(new TargetPlayer());§this.addAbility(damageAbility);§}§public SarkhanTheMad(final SarkhanTheMad card) {§super(card);§}§@Override§public SarkhanTheMad copy() {§return new SarkhanTheMad(this);§}§}§class SarkhanTheMadRevealAndDrawEffect extends OneShotEffect {§private static final String effectText = "Reveal the top card of your library and put it into your hand. {this} deals damage to himself equal to that card's converted mana cost";§SarkhanTheMadRevealAndDrawEffect() {§super(Outcome.DrawCard);§staticText = effectText;§}§SarkhanTheMadRevealAndDrawEffect(SarkhanTheMadRevealAndDrawEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = source.getSourceObject(game);§if (controller != null && sourceObject != null) {§Card card = controller.getLibrary().getFromTop(game);§Permanent sourcePermanent = game.getPermanent(source.getSourceId());§if (card != null) {§controller.moveCards(card, null, Zone.HAND, source, game);§sourcePermanent.damage(card.getManaCost().convertedManaCost(), source.getSourceId(), game, false, false);§controller.revealCards(sourceObject.getIdName(), new CardsImpl(card), game);§}§return true;§}§return false;§}§@Override§public SarkhanTheMadRevealAndDrawEffect copy() {§return new SarkhanTheMadRevealAndDrawEffect(this);§}§}§class SarkhanTheMadSacEffect extends OneShotEffect {§private static final String effectText = "Target creature's controller sacrifices it, then that player puts a 5/5 red Dragon creature token with flying onto the battlefield";§SarkhanTheMadSacEffect() {§super(Outcome.Sacrifice);§staticText = effectText;§}§SarkhanTheMadSacEffect(SarkhanTheMadSacEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(source.getTargets().getFirstTarget());§if (permanent != null) {§Player player = game.getPlayer(permanent.getControllerId());§permanent.sacrifice(this.getId(), game);§Token dragonToken = new DragonToken();§dragonToken.putOntoBattlefield(1, game, this.getId(), player.getId());§}§return false;§}§@Override§public SarkhanTheMadSacEffect copy() {§return new SarkhanTheMadSacEffect(this);§}§}§class SarkhanTheMadDragonDamageEffect extends OneShotEffect {§private static final String effectText = "Each Dragon creature you control deals damage equal to its power to target player";§private static final FilterControlledPermanent filter;§static {§filter = new FilterControlledPermanent();§filter.add(new CardTypePredicate(CardType.CREATURE));§filter.add(new SubtypePredicate("Dragon"));§}§SarkhanTheMadDragonDamageEffect() {§super(Outcome.Damage);§staticText = effectText;§}§SarkhanTheMadDragonDamageEffect(SarkhanTheMadDragonDamageEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§List<Permanent> dragons = game.getBattlefield().getActivePermanents(filter, source.getControllerId(), source.getSourceId(), game);§Player player = game.getPlayer(source.getTargets().getFirstTarget());§if (player != null && dragons != null && !dragons.isEmpty()) {§for (Permanent dragon : dragons) {§player.damage(dragon.getPower().getValue(), dragon.getId(), game, false, true);§}§return true;§}§return false;§}§@Override§public SarkhanTheMadDragonDamageEffect copy() {§return new SarkhanTheMadDragonDamageEffect(this);§}§}§class DragonToken extends mage.game.permanent.token.DragonToken {§DragonToken() {§super();§this.power = new MageInt(5);§this.toughness = new MageInt(5);§}§}§
public class StalwartShieldBearers extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature with defender");§static {§filter.add(new AbilityPredicate(DefenderAbility.class));§}§public StalwartShieldBearers(UUID ownerId) {§super(ownerId, 46, "Stalwart Shield-Bearers", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "ROE";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(0);§this.toughness = new MageInt(3);§this.addAbility(DefenderAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostControlledEffect(0, 2, Duration.WhileOnBattlefield, filter, true)));§}§public StalwartShieldBearers(final StalwartShieldBearers card) {§super(card);§}§@Override§public StalwartShieldBearers copy() {§return new StalwartShieldBearers(this);§}§}§
public class Vengevine extends CardImpl {§public Vengevine(UUID ownerId) {§super(ownerId, 212, "Vengevine", Rarity.MYTHIC, new CardType[]{CardType.CREATURE}, "{2}{G}{G}");§this.expansionSetCode = "ROE";§this.subtype.add("Elemental");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§this.addAbility(HasteAbility.getInstance());§this.addAbility(new VengevineAbility(), new VengevineWatcher());§}§public Vengevine(final Vengevine card) {§super(card);§}§@Override§public Vengevine copy() {§return new Vengevine(this);§}§}§class VengevineAbility extends TriggeredAbilityImpl {§public VengevineAbility() {§super(Zone.GRAVEYARD, new ReturnSourceFromGraveyardToBattlefieldEffect(), true);§}§public VengevineAbility(final VengevineAbility ability) {§super(ability);§}§@Override§public VengevineAbility copy() {§return new VengevineAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.SPELL_CAST;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§if (event.getPlayerId().equals(controllerId)) {§Watcher watcher = game.getState().getWatchers().get("CreatureCast", controllerId);§if (watcher != null && watcher.conditionMet()) {§return true;§}§}§return false;§}§@Override§public String getRule() {§return "Whenever you cast a spell, if it's the second creature spell you cast this turn, you may return {this} from your graveyard to the battlefield.";§}§}§class VengevineWatcher extends Watcher {§int creatureSpellCount = 0;§public VengevineWatcher() {§super("CreatureCast", WatcherScope.PLAYER);§}§public VengevineWatcher(final VengevineWatcher watcher) {§super(watcher);§this.creatureSpellCount = watcher.creatureSpellCount;§}§@Override§public VengevineWatcher copy() {§return new VengevineWatcher(this);§}§@Override§public void watch(GameEvent event, Game game) {§condition = false;§if (event.getType() == EventType.SPELL_CAST && event.getPlayerId().equals(controllerId)) {§Spell spell = game.getStack().getSpell(event.getTargetId());§if (spell != null && spell.getCardType().contains(CardType.CREATURE)) {§creatureSpellCount++;§if (creatureSpellCount == 2)§condition = true;§}§}§}§@Override§public void reset() {§super.reset();§creatureSpellCount = 0;§}§}§
public class BounteousKirin extends CardImpl {§public BounteousKirin(UUID ownerId) {§super(ownerId, 123, "Bounteous Kirin", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{G}{G}");§this.expansionSetCode = "SOK";§this.supertype.add("Legendary");§this.subtype.add("Kirin");§this.subtype.add("Spirit");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SpellCastControllerTriggeredAbility(Zone.BATTLEFIELD, new BounteousKirinEffect(), new FilterSpiritOrArcaneCard(), true, true));§}§public BounteousKirin(final BounteousKirin card) {§super(card);§}§@Override§public BounteousKirin copy() {§return new BounteousKirin(this);§}§}§class BounteousKirinEffect extends OneShotEffect {§public BounteousKirinEffect() {§super(Outcome.GainLife);§this.staticText = "you may gain life equal to that spell's converted mana cost";§}§public BounteousKirinEffect(final BounteousKirinEffect effect) {§super(effect);§}§@Override§public BounteousKirinEffect copy() {§return new BounteousKirinEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Spell spell = game.getState().getStack().getSpell(getTargetPointer().getFirst(game, source));§if (spell != null) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§int life = spell.getConvertedManaCost();§controller.gainLife(life, game);§return true;§}§}§return false;§}§}§
public class Dreamcatcher extends CardImpl {§public Dreamcatcher(UUID ownerId) {§super(ownerId, 34, "Dreamcatcher", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{U}");§this.expansionSetCode = "SOK";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SpellCastControllerTriggeredAbility(new SacrificeSourceEffect(), new FilterSpiritOrArcaneCard(), true,§"Whenever you cast a Spirit or Arcane spell, you may sacrifice Dreamcatcher. If you do, draw a card.");§ability.addEffect(new DrawCardSourceControllerEffect(1));§this.addAbility(ability);§}§public Dreamcatcher(final Dreamcatcher card) {§super(card);§}§@Override§public Dreamcatcher copy() {§return new Dreamcatcher(this);§}§}§
public class Glitterfang extends CardImpl {§public Glitterfang(UUID ownerId) {§super(ownerId, 100, "Glitterfang", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "SOK";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(HasteAbility.getInstance());§this.addAbility(new BeginningOfEndStepTriggeredAbility(new ReturnToHandSourceEffect(true), TargetController.ANY, false));§}§public Glitterfang(final Glitterfang card) {§super(card);§}§@Override§public Glitterfang copy() {§return new Glitterfang(this);§}§}§
public class KagemarosClutch extends CardImpl {§public KagemarosClutch(UUID ownerId) {§super(ownerId, 74, "Kagemaro's Clutch", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{3}{B}");§this.expansionSetCode = "SOK";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.UnboostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§DynamicValue xMinusValue = new SignInversionDynamicValue(new CardsInControllerHandCount());§Effect effect = new BoostEnchantedEffect(xMinusValue, xMinusValue, Duration.WhileOnBattlefield);§effect.setText("Enchanted creature gets -X/-X, where X is the number of cards in your hand");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, effect));§}§public KagemarosClutch(final KagemarosClutch card) {§super(card);§}§@Override§public KagemarosClutch copy() {§return new KagemarosClutch(this);§}§}§
public class MatsuTribeBirdstalker extends CardImpl {§public MatsuTribeBirdstalker(UUID ownerId) {§super(ownerId, 137, "Matsu-Tribe Birdstalker", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{G}{G}");§this.expansionSetCode = "SOK";§this.subtype.add("Snake");§this.subtype.add("Warrior");§this.subtype.add("Archer");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability;§ability = new DealsDamageToACreatureTriggeredAbility(new TapTargetEffect("that creature"), true, false, true);§ability.addEffect(new DontUntapInControllersNextUntapStepTargetEffect("and it"));§this.addAbility(ability);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD,§new GainAbilitySourceEffect(ReachAbility.getInstance(), Duration.EndOfTurn),§new ManaCostsImpl("{G}")));§}§public MatsuTribeBirdstalker(final MatsuTribeBirdstalker card) {§super(card);§}§@Override§public MatsuTribeBirdstalker copy() {§return new MatsuTribeBirdstalker(this);§}§}§
public class OniOfWildPlaces extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("red creature you control");§static {§filter.add(new ColorPredicate(ObjectColor.RED));§}§public OniOfWildPlaces(UUID ownerId) {§super(ownerId, 108, "Oni of Wild Places", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{5}{R}");§this.expansionSetCode = "SOK";§this.subtype.add("Demon");§this.subtype.add("Spirit");§this.power = new MageInt(6);§this.toughness = new MageInt(5);§this.addAbility(HasteAbility.getInstance());§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new ReturnToHandChosenControlledPermanentEffect(filter), TargetController.YOU, false));§}§public OniOfWildPlaces(final OniOfWildPlaces card) {§super(card);§}§@Override§public OniOfWildPlaces copy() {§return new OniOfWildPlaces(this);§}§}§
public class SakashimaTheImpostor extends CardImpl {§public SakashimaTheImpostor(UUID ownerId) {§super(ownerId, 53, "Sakashima the Impostor", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{U}{U}");§this.expansionSetCode = "SOK";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Rogue");§this.power = new MageInt(3);§this.toughness = new MageInt(1);§Effect effect = new CopyPermanentEffect(new FilterCreaturePermanent(), new SakashimaTheImpostorApplier());§effect.setText("as a copy of any creature on the battlefield, except its name is still Sakashima the Impostor, it's legendary in addition to its other types, and it gains \"{2}{U}{U}: Return {this} to its owner's hand at the beginning of the next end step.\"");§this.addAbility(new EntersBattlefieldAbility(effect, true));§}§public SakashimaTheImpostor(final SakashimaTheImpostor card) {§super(card);§}§@Override§public SakashimaTheImpostor copy() {§return new SakashimaTheImpostor(this);§}§}§class SakashimaTheImpostorApplier extends ApplyToPermanent {§@Override§public Boolean apply(Game game, Permanent permanent) {§if (!permanent.getSupertype().contains("Legendary")) {§permanent.getSubtype().add("Legendary");§}§permanent.setName("Sakashima the Impostor");§permanent.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD,§new CreateDelayedTriggeredAbilityEffect(new AtTheBeginOfNextEndStepDelayedTriggeredAbility(new ReturnToHandSourceEffect(true)), false),§new ManaCostsImpl("{2}{U}{U}")§), game);§return true;§}§@Override§public Boolean apply(Game game, MageObject mageObject) {§if (!mageObject.getSupertype().contains("Legendary")) {§mageObject.getSubtype().add("Legendary");§}§mageObject.setName("Sakashima the Impostor");§mageObject.getAbilities().add(new SimpleActivatedAbility(Zone.BATTLEFIELD,§new CreateDelayedTriggeredAbilityEffect(new AtTheBeginOfNextEndStepDelayedTriggeredAbility(new ReturnToHandSourceEffect(true)), false),§new ManaCostsImpl("{2}{U}{U}")§));§return true;§}§}§
public class SoramaroFirstToDream extends CardImpl {§public SoramaroFirstToDream(UUID ownerId) {§super(ownerId, 58, "Soramaro, First to Dream", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{U}{U}");§this.expansionSetCode = "SOK";§this.supertype.add("Legendary");§this.subtype.add("Spirit");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(FlyingAbility.getInstance());§DynamicValue xValue= new CardsInControllerHandCount();§this.addAbility(new SimpleStaticAbility(Zone.ALL, new SetPowerToughnessSourceEffect(xValue, Duration.EndOfGame)));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new DrawCardSourceControllerEffect(1), new GenericManaCost(4));§ability.addCost(new ReturnToHandChosenControlledPermanentCost(new TargetControlledPermanent(new FilterControlledLandPermanent("a land"))));§this.addAbility(ability);§}§public SoramaroFirstToDream(final SoramaroFirstToDream card) {§super(card);§}§@Override§public SoramaroFirstToDream copy() {§return new SoramaroFirstToDream(this);§}§}§
public class Asceticism extends CardImpl {§public Asceticism(UUID ownerId) {§super(ownerId, 110, "Asceticism", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{3}{G}{G}");§this.expansionSetCode = "SOM";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityControlledEffect(HexproofAbility.getInstance(), Duration.WhileOnBattlefield, new FilterControlledCreaturePermanent())));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateTargetEffect(), new ManaCostsImpl("{1}{G}"));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public Asceticism(final Asceticism card) {§super(card);§}§@Override§public Asceticism copy() {§return new Asceticism(this);§}§}§
public class CarrionCall extends CardImpl {§public CarrionCall (UUID ownerId) {§super(ownerId, 115, "Carrion Call", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{3}{G}");§this.expansionSetCode = "SOM";§this.getSpellAbility().addEffect(new CreateTokenEffect(new InsectInfectToken(), 2));§}§public CarrionCall (final CarrionCall card) {§super(card);§}§@Override§public CarrionCall copy() {§return new CarrionCall(this);§}§}§
public class DispenseJustice extends CardImpl {§public DispenseJustice (UUID ownerId) {§super(ownerId, 5, "Dispense Justice", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{2}{W}");§this.expansionSetCode = "SOM";§this.getSpellAbility().addEffect(new DispenseJusticeEffect());§this.getSpellAbility().addTarget(new TargetPlayer());§}§public DispenseJustice (final DispenseJustice card) {§super(card);§}§@Override§public DispenseJustice copy() {§return new DispenseJustice(this);§}§}§class DispenseJusticeEffect extends OneShotEffect {§private static final String effectText = "Target player sacrifices an attacking creature.\r\n\r\n"§+ "Metalcraft - That player sacrifices two attacking creatures instead if you control three or more artifacts";§private static final FilterAttackingCreature filter = new FilterAttackingCreature();§DispenseJusticeEffect ( ) {§super(Outcome.Sacrifice);§staticText = effectText;§}§DispenseJusticeEffect ( DispenseJusticeEffect effect ) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§if ( MetalcraftCondition.getInstance().apply(game, source) ) {§return new SacrificeEffect(filter, 2, effectText).apply(game, source);§}§else {§return new SacrificeEffect(filter, 1, effectText).apply(game, source);§}§}§@Override§public DispenseJusticeEffect copy() {§return new DispenseJusticeEffect(this);§}§}§
public class GalvanicBlast extends CardImpl {§private final String effectText = "{this} deals 2 damage to target creature or player.<br>Metalcraft - {this}t deals 4 damage to that creature or player instead if you control three or more artifacts";§public GalvanicBlast(UUID ownerId) {§super(ownerId, 91, "Galvanic Blast", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{R}");§this.expansionSetCode = "SOM";§this.color.setRed(true);§this.getSpellAbility().addEffect(new ConditionalOneShotEffect(new DamageTargetEffect(4), new DamageTargetEffect(2), MetalcraftCondition.getInstance(), effectText));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§}§public GalvanicBlast(final GalvanicBlast card) {§super(card);§}§@Override§public GalvanicBlast copy() {§return new GalvanicBlast(this);§}§}§
public class HoardSmelterDragon extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("artifact");§static {§filter.add(new CardTypePredicate(CardType.ARTIFACT));§}§public HoardSmelterDragon (UUID ownerId) {§super(ownerId, 93, "Hoard-Smelter Dragon", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{4}{R}{R}");§this.expansionSetCode = "SOM";§this.subtype.add("Dragon");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new ManaCostsImpl("{3}{R}"));§ability.addTarget(new TargetPermanent(filter));§ability.addEffect(new HoardSmelterEffect());§this.addAbility(ability);§}§public HoardSmelterDragon (final HoardSmelterDragon card) {§super(card);§}§@Override§public HoardSmelterDragon copy() {§return new HoardSmelterDragon(this);§}§}§class HoardSmelterEffect extends ContinuousEffectImpl {§private int costValue = 0;§HoardSmelterEffect() {§super(Duration.EndOfTurn, Layer.PTChangingEffects_7, SubLayer.ModifyPT_7c, Outcome.BoostCreature);§staticText = "{this} gets +X/+0 until end of turn, where X is that artifact's converted mana cost";§}§HoardSmelterEffect(final HoardSmelterEffect effect) {§super(effect);§this.costValue = effect.costValue;§}§@Override§public boolean apply(Game game, Ability source) {§Permanent target = game.getPermanent(source.getSourceId());§if (target != null) {§target.addPower(costValue);§return true;§}§return false;§}§@Override§public void init(Ability source, Game game) {§Card targeted = game.getCard(source.getFirstTarget());§if (targeted != null) {§costValue = targeted.getManaCost().convertedManaCost();§}§}§@Override§public HoardSmelterEffect copy() {§return new HoardSmelterEffect(this);§}§}§
public class LumengridDrake extends CardImpl {§private static final String ruleText = "Metalcraft - When {this} enters the battlefield, if you control three or more artifacts, return target creature to its owner's hand.";§public LumengridDrake(UUID ownerId) {§super(ownerId, 36, "Lumengrid Drake", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "SOM";§this.subtype.add("Drake");§this.color.setBlue(true);§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§TriggeredAbility conditional = new ConditionalTriggeredAbility(§new EntersBattlefieldTriggeredAbility(new ReturnToHandTargetEffect()), MetalcraftCondition.getInstance(), ruleText);§conditional.addTarget(new TargetCreaturePermanent());§this.addAbility(conditional);§}§public LumengridDrake(final LumengridDrake card) {§super(card);§}§@Override§public LumengridDrake copy() {§return new LumengridDrake(this);§}§}§
public class Necropede extends CardImpl {§public Necropede (UUID ownerId) {§super(ownerId, 185, "Necropede", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{2}");§this.expansionSetCode = "SOM";§this.subtype.add("Insect");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(InfectAbility.getInstance());§Ability ability = new DiesTriggeredAbility(new AddCountersTargetEffect(CounterType.M1M1.createInstance()), true);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public Necropede (final Necropede card) {§super(card);§}§@Override§public Necropede copy() {§return new Necropede(this);§}§}§
public class PsychicMiasma extends CardImpl {§public PsychicMiasma(UUID ownerId) {§super(ownerId, 76, "Psychic Miasma", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{1}{B}");§this.expansionSetCode = "SOM";§this.getSpellAbility().addTarget(new TargetPlayer());§this.getSpellAbility().addEffect(new PsychicMiasmaEffect());§}§public PsychicMiasma(final PsychicMiasma card) {§super(card);§}§@Override§public PsychicMiasma copy() {§return new PsychicMiasma(this);§}§}§class PsychicMiasmaEffect extends OneShotEffect {§PsychicMiasmaEffect() {§super(Outcome.Discard);§staticText = "Target player discards a card. If a land card is discarded this way, return {this} to its owner's hand";§}§PsychicMiasmaEffect(final PsychicMiasmaEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(targetPointer.getFirst(game, source));§if (player != null) {§Card discardedCard = player.discardOne(false, source, game);§if (discardedCard != null && discardedCard.getCardType().contains(CardType.LAND)) {§Card spellCard = game.getStack().getSpell(source.getSourceId()).getCard();§if (spellCard != null) {§player.moveCards(spellCard, null, Zone.HAND, source, game);§}§}§return true;§}§return false;§}§@Override§public PsychicMiasmaEffect copy() {§return new PsychicMiasmaEffect(this);§}§}§
public class ShapeAnew extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("an artifact");§static {§filter.add(new CardTypePredicate(CardType.ARTIFACT));§}§public ShapeAnew(UUID ownerId) {§super(ownerId, 43, "Shape Anew", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{3}{U}");§this.expansionSetCode = "SOM";§this.getSpellAbility().addEffect(new SacrificeTargetEffect("The controller of target artifact sacrifices it"));§this.getSpellAbility().addTarget(new TargetPermanent(filter));§this.getSpellAbility().addEffect(new ShapeAnewEffect());§}§public ShapeAnew(final ShapeAnew card) {§super(card);§}§@Override§public ShapeAnew copy() {§return new ShapeAnew(this);§}§private class ShapeAnewEffect extends OneShotEffect {§public ShapeAnewEffect() {§super(Outcome.PutCardInPlay);§staticText = ", then reveals cards from the top of his or her library until he or she reveals an artifact card. That player puts that card onto the battlefield, then shuffles all other cards revealed this way into his or her library";§}§public ShapeAnewEffect(ShapeAnewEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent sourcePermanent = (Permanent) game.getLastKnownInformation(targetPointer.getFirst(game, source), Zone.BATTLEFIELD);§if (sourcePermanent == null) {§return false;§}§Player controller = game.getPlayer(source.getControllerId());§if (controller == null) {§return false;§}§Cards revealed = new CardsImpl();§Card artifactCard = null;§Cards nonArtifactCards = new CardsImpl();§Player targetController = game.getPlayer(sourcePermanent.getControllerId());§while (artifactCard == null && targetController.getLibrary().size() > 0) {§Card card = targetController.getLibrary().removeFromTop(game);§revealed.add(card);§if (card.getCardType().contains(CardType.ARTIFACT)) {§artifactCard = card;§} else {§nonArtifactCards.add(card);§}§}§targetController.revealCards(sourcePermanent.getIdName(), revealed, game);§if (artifactCard != null) {§targetController.moveCards(artifactCard, Zone.BATTLEFIELD, source, game);§}§targetController.putCardsOnTopOfLibrary(nonArtifactCards, game, source, false);§targetController.shuffleLibrary(game);§return true;§}§@Override§public ShapeAnewEffect copy() {§return new ShapeAnewEffect(this);§}§}§}§
public class TangleAngler extends CardImpl {§public TangleAngler(UUID ownerId) {§super(ownerId, 128, "Tangle Angler", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "SOM";§this.subtype.add("Horror");§this.power = new MageInt(1);§this.toughness = new MageInt(5);§this.addAbility(InfectAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new MustBeBlockedByTargetSourceEffect(), new ManaCostsImpl("{G}"));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public TangleAngler(final TangleAngler card) {§super(card);§}§@Override§public TangleAngler copy() {§return new TangleAngler(this);§}§}§
public class VaultSkyward extends CardImpl {§public VaultSkyward (UUID ownerId) {§super(ownerId, 51, "Vault Skyward", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{U}");§this.expansionSetCode = "SOM";§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(FlyingAbility.getInstance(), Duration.EndOfTurn));§this.getSpellAbility().addEffect(new UntapTargetEffect());§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§}§public VaultSkyward (final VaultSkyward card) {§super(card);§}§@Override§public VaultSkyward copy() {§return new VaultSkyward(this);§}§}§
public class AvenFarseer extends CardImpl {§public AvenFarseer(UUID ownerId) {§super(ownerId, 3, "Aven Farseer", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "SCG";§this.subtype.add("Bird");§this.subtype.add("Soldier");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new TurnedFaceUpAllTriggeredAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance()), new FilterPermanent("a permanent")));§}§public AvenFarseer(final AvenFarseer card) {§super(card);§}§@Override§public AvenFarseer copy() {§return new AvenFarseer(this);§}§}§
public class DragonTyrant extends CardImpl {§public DragonTyrant(UUID ownerId) {§super(ownerId, 88, "Dragon Tyrant", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{8}{R}{R}");§this.expansionSetCode = "SCG";§this.subtype.add("Dragon");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(TrampleAbility.getInstance());§this.addAbility(DoubleStrikeAbility.getInstance());§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new SacrificeSourceUnlessPaysEffect(new ManaCostsImpl("{R}{R}{R}{R}")), TargetController.YOU, false));§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1, 0, Duration.EndOfTurn), new ManaCostsImpl("{R}")));§}§public DragonTyrant(final DragonTyrant card) {§super(card);§}§@Override§public DragonTyrant copy() {§return new DragonTyrant(this);§}§}§
public class NobleTemplar extends CardImpl {§public NobleTemplar(UUID ownerId) {§super(ownerId, 19, "Noble Templar", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{5}{W}");§this.expansionSetCode = "SCG";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.subtype.add("Soldier");§this.power = new MageInt(3);§this.toughness = new MageInt(6);§this.addAbility(VigilanceAbility.getInstance());§this.addAbility(new PlainscyclingAbility(new ManaCostsImpl("{2}")));§}§public NobleTemplar(final NobleTemplar card) {§super(card);§}§@Override§public NobleTemplar copy() {§return new NobleTemplar(this);§}§}§
public class TendrilsOfAgony extends CardImpl {§public TendrilsOfAgony(UUID ownerId) {§super(ownerId, 75, "Tendrils of Agony", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{2}{B}{B}");§this.expansionSetCode = "SCG";§this.getSpellAbility().addTarget(new TargetPlayer());§this.getSpellAbility().addEffect(new LoseLifeTargetEffect(2));§this.getSpellAbility().addEffect(new GainLifeEffect(2));§this.addAbility(new StormAbility());§}§public TendrilsOfAgony(final TendrilsOfAgony card) {§super(card);§}§@Override§public TendrilsOfAgony copy() {§return new TendrilsOfAgony(this);§}§}§
public class AncestralMemories extends CardImpl {§public AncestralMemories(UUID ownerId) {§super(ownerId, 59, "Ancestral Memories", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{2}{U}{U}{U}");§this.expansionSetCode = "7ED";§this.getSpellAbility().addEffect(new AncestralMemoriesEffect());§}§public AncestralMemories(final AncestralMemories card) {§super(card);§}§@Override§public AncestralMemories copy() {§return new AncestralMemories(this);§}§}§class AncestralMemoriesEffect extends OneShotEffect {§public AncestralMemoriesEffect() {§super(Outcome.DrawCard);§this.staticText = "Look at the top seven cards of your library. Put two of them into your hand and the rest into your graveyard";§}§public AncestralMemoriesEffect(final AncestralMemoriesEffect effect) {§super(effect);§}§@Override§public AncestralMemoriesEffect copy() {§return new AncestralMemoriesEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§Cards cards = new CardsImpl();§int cardsCount = Math.min(7, player.getLibrary().size());§for (int i = 0; i < cardsCount; i++) {§Card card = player.getLibrary().removeFromTop(game);§if (card != null) {§cards.add(card);§}§}§if (cards.size() > 0) {§player.lookAtCards("Ancestral Memories", cards, game);§TargetCard target = new TargetCard(Math.min(2, cards.size()), Zone.LIBRARY, new FilterCard("two cards to put in your hand"));§if (player.choose(Outcome.Benefit, cards, target, game)) {§for (UUID targetId : (List<UUID>)target.getTargets()) {§Card card = cards.get(targetId, game);§if (card != null) {§card.moveToZone(Zone.HAND, source.getSourceId(), game, false);§cards.remove(card);§}§}§}§player.moveCards(cards, Zone.LIBRARY, Zone.GRAVEYARD, source, game);§}§return true;§}§return false;§}§}§
public class GrapeshotCatapult extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature with flying");§static {§filter.add(new AbilityPredicate(FlyingAbility.class));§}§public GrapeshotCatapult(UUID ownerId) {§super(ownerId, 299, "Grapeshot Catapult", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{4}");§this.expansionSetCode = "7ED";§this.subtype.add("Construct");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§Ability activatedAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new TapSourceCost());§activatedAbility.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(activatedAbility);§}§public GrapeshotCatapult(final GrapeshotCatapult card) {§super(card);§}§@Override§public GrapeshotCatapult copy() {§return new GrapeshotCatapult(this);§}§}§
public class Pyrotechnics extends CardImpl {§public Pyrotechnics(UUID ownerId) {§super(ownerId, 210, "Pyrotechnics", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{4}{R}");§this.expansionSetCode = "7ED";§this.getSpellAbility().addEffect(new DamageMultiEffect(4));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayerAmount(4));§}§public Pyrotechnics(final Pyrotechnics card) {§super(card);§}§@Override§public Pyrotechnics copy() {§return new Pyrotechnics(this);§}§}§
public class Thoughtleech extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("an Island an opponent controls");§static {§filter.add(new SubtypePredicate("Island"));§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public Thoughtleech(UUID ownerId) {§super(ownerId, 274, "Thoughtleech", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{G}{G}");§this.expansionSetCode = "7ED";§this.addAbility(new BecomesTappedTriggeredAbility(new GainLifeEffect(1), true, filter));§}§public Thoughtleech(final Thoughtleech card) {§super(card);§}§@Override§public Thoughtleech copy() {§return new Thoughtleech(this);§}§}§
public class BarrentonMedic extends CardImpl {§public BarrentonMedic(UUID ownerId) {§super(ownerId, 4, "Barrenton Medic", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{W}");§this.expansionSetCode = "SHM";§this.subtype.add("Kithkin");§this.subtype.add("Cleric");§this.power = new MageInt(0);§this.toughness = new MageInt(4);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PreventDamageToTargetEffect(Duration.EndOfTurn, 1), new TapSourceCost());§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new UntapSourceEffect(), new PutCountersSourceCost(CounterType.M1M1.createInstance(1))));§}§public BarrentonMedic(final BarrentonMedic card) {§super(card);§}§@Override§public BarrentonMedic copy() {§return new BarrentonMedic(this);§}§}§
public class CinderhazeWretch extends CardImpl {§public CinderhazeWretch(UUID ownerId) {§super(ownerId, 60, "Cinderhaze Wretch", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{B}");§this.expansionSetCode = "SHM";§this.subtype.add("Elemental");§this.subtype.add("Shaman");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§Ability ability = new ActivateIfConditionActivatedAbility(Zone.BATTLEFIELD, new DiscardTargetEffect(1), new TapSourceCost(), MyTurnCondition.getInstance());§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new UntapSourceEffect(), new PutCountersSourceCost(CounterType.M1M1.createInstance(1))));§}§public CinderhazeWretch(final CinderhazeWretch card) {§super(card);§}§@Override§public CinderhazeWretch copy() {§return new CinderhazeWretch(this);§}§}§
public class DreamSalvage extends CardImpl {§public DreamSalvage(UUID ownerId) {§super(ownerId, 160, "Dream Salvage", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{U/B}");§this.expansionSetCode = "SHM";§this.getSpellAbility().addEffect(new DreamSalvageEffect());§this.getSpellAbility().addTarget(new TargetOpponent());§this.getSpellAbility().addWatcher(new CardsDiscardedThisTurnWatcher());§}§public DreamSalvage(final DreamSalvage card) {§super(card);§}§@Override§public DreamSalvage copy() {§return new DreamSalvage(this);§}§}§class CardsDiscardedThisTurnWatcher extends Watcher {§private final Map<UUID, Integer> amountOfCardsDiscardedThisTurn = new HashMap<>();§public CardsDiscardedThisTurnWatcher() {§super("CardsDiscardedThisTurnWatcher", WatcherScope.GAME);§}§public CardsDiscardedThisTurnWatcher(final CardsDiscardedThisTurnWatcher watcher) {§super(watcher);§for (Entry<UUID, Integer> entry : watcher.amountOfCardsDiscardedThisTurn.entrySet()) {§amountOfCardsDiscardedThisTurn.put(entry.getKey(), entry.getValue());§}§}§@Override§public void watch(GameEvent event, Game game) {§if (event.getType() == GameEvent.EventType.DISCARDED_CARD) {§UUID playerId = event.getPlayerId();§if (playerId != null) {§Integer amount = amountOfCardsDiscardedThisTurn.get(playerId);§if (amount == null) {§amount = 1;§} else {§amount++;§}§amountOfCardsDiscardedThisTurn.put(playerId, amount);§}§}§}§public int getAmountCardsDiscarded(UUID playerId) {§Integer amount = amountOfCardsDiscardedThisTurn.get(playerId);§if (amount != null) {§return amount;§}§return 0;§}§@Override§public void reset() {§amountOfCardsDiscardedThisTurn.clear();§}§@Override§public CardsDiscardedThisTurnWatcher copy() {§return new CardsDiscardedThisTurnWatcher(this);§}§}§class DreamSalvageEffect extends OneShotEffect {§public DreamSalvageEffect() {§super(Outcome.DrawCard);§staticText = "Draw cards equal to the number of cards target opponent discarded this turn";§}§public DreamSalvageEffect(final DreamSalvageEffect effect) {§super(effect);§}§@Override§public DreamSalvageEffect copy() {§return new DreamSalvageEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§CardsDiscardedThisTurnWatcher watcher = (CardsDiscardedThisTurnWatcher) game.getState().getWatchers().get("CardsDiscardedThisTurnWatcher");§Player targetOpponent = game.getPlayer(source.getFirstTarget());§Player controller = game.getPlayer(source.getControllerId());§if (targetOpponent != null§&& controller != null§&& watcher != null§&& watcher.getAmountCardsDiscarded(targetOpponent.getId()) > 0) {§controller.drawCards(watcher.getAmountCardsDiscarded(targetOpponent.getId()), game);§return true;§}§return false;§}§}§
public class FlowOfIdeas extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("Island you control");§static {§filter.add(new SubtypePredicate("Island"));§}§public FlowOfIdeas(UUID ownerId) {§super(ownerId, 38, "Flow of Ideas", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{5}{U}");§this.expansionSetCode = "SHM";§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(new PermanentsOnBattlefieldCount(filter)));§}§public FlowOfIdeas(final FlowOfIdeas card) {§super(card);§}§@Override§public FlowOfIdeas copy() {§return new FlowOfIdeas(this);§}§}§
public class GriefTyrant extends CardImpl {§public GriefTyrant(UUID ownerId) {§super(ownerId, 189, "Grief Tyrant", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{5}{B/R}");§this.expansionSetCode = "SHM";§this.subtype.add("Horror");§this.power = new MageInt(8);§this.toughness = new MageInt(8);§this.addAbility(new EntersBattlefieldAbility(new AddCountersSourceEffect(CounterType.M1M1.createInstance(4))));§Ability ability = new DiesTriggeredAbility(new GriefTyrantEffect());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public GriefTyrant(final GriefTyrant card) {§super(card);§}§@Override§public GriefTyrant copy() {§return new GriefTyrant(this);§}§}§class GriefTyrantEffect extends OneShotEffect {§public GriefTyrantEffect() {§super(Outcome.Neutral);§this.staticText = "put a -1/-1 counter on target creature for each -1/-1 counter on {this}";§}§public GriefTyrantEffect(final GriefTyrantEffect effect) {§super(effect);§}§@Override§public GriefTyrantEffect copy() {§return new GriefTyrantEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent targetCreature = game.getPermanent(targetPointer.getFirst(game, source));§Permanent griefTyrant = game.getPermanentOrLKIBattlefield(source.getSourceId());§int countersOnGriefTyrant = griefTyrant.getCounters().getCount(CounterType.M1M1);§if (targetCreature != null) {§targetCreature.addCounters(CounterType.M1M1.createInstance(countersOnGriefTyrant), game);§return true;§}§return false;§}§}§
public class KinscaerHarpoonist extends CardImpl {§public KinscaerHarpoonist(UUID ownerId) {§super(ownerId, 41, "Kinscaer Harpoonist", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "SHM";§this.subtype.add("Kithkin");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§Effect effect = new LoseAbilityTargetEffect(FlyingAbility.getInstance(), Duration.EndOfTurn);§effect.setText("you may have target creature lose flying until end of turn");§Ability ability = new AttacksTriggeredAbility(effect, true);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public KinscaerHarpoonist(final KinscaerHarpoonist card) {§super(card);§}§@Override§public KinscaerHarpoonist copy() {§return new KinscaerHarpoonist(this);§}§}§
public class MedicineRunner extends CardImpl {§public MedicineRunner(UUID ownerId) {§super(ownerId, 230, "Medicine Runner", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G/W}");§this.expansionSetCode = "SHM";§this.subtype.add("Elf");§this.subtype.add("Cleric");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Ability ability = new EntersBattlefieldTriggeredAbility(new RemoveCounterTargetEffect(), true);§ability.addTarget(new TargetPermanent());§this.addAbility(ability);§}§public MedicineRunner(final MedicineRunner card) {§super(card);§}§@Override§public MedicineRunner copy() {§return new MedicineRunner(this);§}§}§
public class NurturerInitiate extends CardImpl {§private static final FilterSpell filter = new FilterSpell("a green spell");§static {§filter.add(new ColorPredicate(ObjectColor.GREEN));§}§public NurturerInitiate(UUID ownerId) {§super(ownerId, 124, "Nurturer Initiate", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "SHM";§this.subtype.add("Elf");§this.subtype.add("Shaman");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SpellCastAllTriggeredAbility(new DoIfCostPaid(new BoostTargetEffect(1, 1, Duration.EndOfTurn), new ManaCostsImpl("{1}")), filter, false);§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public NurturerInitiate(final NurturerInitiate card) {§super(card);§}§@Override§public NurturerInitiate copy() {§return new NurturerInitiate(this);§}§}§
public class PuppeteerClique extends CardImpl {§public PuppeteerClique(UUID ownerId) {§super(ownerId, 75, "Puppeteer Clique", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{B}{B}");§this.expansionSetCode = "SHM";§this.subtype.add("Faerie");§this.subtype.add("Wizard");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new PuppeteerCliqueEffect(), false);§Target target = new TargetCardInOpponentsGraveyard(new FilterCreatureCard("creature card from your opponent's graveyard"));§ability.addTarget(target);§this.addAbility(ability);§this.addAbility(new PersistAbility());§}§public PuppeteerClique(final PuppeteerClique card) {§super(card);§}§@Override§public PuppeteerClique copy() {§return new PuppeteerClique(this);§}§}§class PuppeteerCliqueEffect extends OneShotEffect {§public PuppeteerCliqueEffect() {§super(Outcome.PutCreatureInPlay);§staticText = "put target creature card from an opponent's graveyard onto the battlefield under your control. It gains haste. At the beginning of your next end step, exile it";§}§public PuppeteerCliqueEffect(final PuppeteerCliqueEffect effect) {§super(effect);§}§@Override§public PuppeteerCliqueEffect copy() {§return new PuppeteerCliqueEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§boolean result = false;§Card card = game.getCard(getTargetPointer().getFirst(game, source));§if (card != null) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§if (controller.moveCards(card, Zone.BATTLEFIELD, source, game)) {§Permanent permanent = game.getPermanent(card.getId());§if (permanent != null) {§ContinuousEffect hasteEffect = new GainAbilityTargetEffect(HasteAbility.getInstance(), Duration.Custom);§hasteEffect.setTargetPointer(new FixedTarget(permanent, game));§game.addEffect(hasteEffect, source);§ExileTargetEffect exileEffect = new ExileTargetEffect("exile " + permanent.getLogName());§exileEffect.setTargetPointer(new FixedTarget(permanent, game));§DelayedTriggeredAbility delayedAbility = new AtTheBeginOfNextEndStepDelayedTriggeredAbility(exileEffect, TargetController.YOU);§game.addDelayedTriggeredAbility(delayedAbility, source);§result = true;§}§}§}§}§return result;§}§}§
public class RunedHalo extends CardImpl {§public RunedHalo(UUID ownerId) {§super(ownerId, 21, "Runed Halo", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{W}{W}");§this.expansionSetCode = "SHM";§Ability ability = new AsEntersBattlefieldAbility(new NameACardEffect(NameACardEffect.TypeOfName.ALL));§ability.addEffect(new RunedHaloSetProtectionEffect());§this.addAbility(ability);§}§public RunedHalo(final RunedHalo card) {§super(card);§}§@Override§public RunedHalo copy() {§return new RunedHalo(this);§}§}§class RunedHaloSetProtectionEffect extends OneShotEffect {§public RunedHaloSetProtectionEffect() {§super(Outcome.Protect);§staticText = "<br/><br/>You have protection from the chosen name <i>(You can't be targeted, dealt damage, or enchanted by anything with that name.)</i>";§}§public RunedHaloSetProtectionEffect(final RunedHaloSetProtectionEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§String cardName = (String) game.getState().getValue(source.getSourceId().toString() + NameACardEffect.INFO_KEY);§if (controller != null && cardName != null && !cardName.isEmpty()) {§FilterObject filter = new FilterObject("the name [" + cardName + "]");§filter.add(new NamePredicate(cardName));§ContinuousEffect effect = new GainAbilityControllerEffect(new ProtectionAbility(filter), Duration.Custom);§game.addEffect(effect, source);§return true;§}§return false;§}§@Override§public RunedHaloSetProtectionEffect copy() {§return new RunedHaloSetProtectionEffect(this);§}§}§
public class SlinkingGiant extends CardImpl {§public SlinkingGiant(UUID ownerId) {§super(ownerId, 106, "Slinking Giant", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "SHM";§this.subtype.add("Giant");§this.subtype.add("Rogue");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(WitherAbility.getInstance());§this.addAbility(new BlocksOrBecomesBlockedTriggeredAbility(new BoostSourceEffect(-3, 0, Duration.EndOfTurn), false));§}§public SlinkingGiant(final SlinkingGiant card) {§super(card);§}§@Override§public SlinkingGiant copy() {§return new SlinkingGiant(this);§}§}§
public class ThistledownDuo extends CardImpl {§private static final FilterSpell whiteFilter = new FilterSpell("a white spell");§private static final FilterSpell blueFilter = new FilterSpell("a blue spell");§static {§whiteFilter.add(new ColorPredicate(ObjectColor.WHITE));§blueFilter.add(new ColorPredicate(ObjectColor.BLUE));§}§public ThistledownDuo(UUID ownerId) {§super(ownerId, 152, "Thistledown Duo", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W/U}");§this.expansionSetCode = "SHM";§this.subtype.add("Kithkin");§this.subtype.add("Soldier");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SpellCastControllerTriggeredAbility(new BoostSourceEffect(1, 1, Duration.EndOfTurn), whiteFilter, false));§this.addAbility(new SpellCastControllerTriggeredAbility(new GainAbilitySourceEffect(FlyingAbility.getInstance(), Duration.EndOfTurn), blueFilter, false));§}§public ThistledownDuo(final ThistledownDuo card) {§super(card);§}§@Override§public ThistledownDuo copy() {§return new ThistledownDuo(this);§}§}§
public class Whimwader extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("a blue permanent");§static {§filter.add(new ColorPredicate(ObjectColor.BLUE));§}§public Whimwader(UUID ownerId) {§super(ownerId, 54, "Whimwader", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{U}");§this.expansionSetCode = "SHM";§this.subtype.add("Elemental");§this.power = new MageInt(6);§this.toughness = new MageInt(4);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CantAttackUnlessDefenderControllsPermanent(filter)));§}§public Whimwader(final Whimwader card) {§super(card);§}§@Override§public Whimwader copy() {§return new Whimwader(this);§}§}§
public class AlgaeGharial extends CardImpl {§public AlgaeGharial(UUID ownerId) {§super(ownerId, 123, "Algae Gharial", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{G}");§this.expansionSetCode = "ALA";§this.subtype.add("Crocodile");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(ShroudAbility.getInstance());§this.addAbility(new DiesCreatureTriggeredAbility(new AddCountersSourceEffect(CounterType.P1P1.createInstance()), true, true));§}§public AlgaeGharial(final AlgaeGharial card) {§super(card);§}§@Override§public AlgaeGharial copy() {§return new AlgaeGharial(this);§}§}§
public class BroodmateDragon extends CardImpl {§private static DragonToken dragonToken = new DragonToken();§public BroodmateDragon(UUID ownerId) {§super(ownerId, 160, "Broodmate Dragon", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{B}{R}{G}");§this.expansionSetCode = "ALA";§this.subtype.add("Dragon");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new EntersBattlefieldTriggeredAbility(new CreateTokenEffect(dragonToken), false));§this.addAbility(FlyingAbility.getInstance());§}§public BroodmateDragon(final BroodmateDragon card) {§super(card);§}§@Override§public BroodmateDragon copy() {§return new BroodmateDragon(this);§}§}§
public class DawnrayArcher extends CardImpl {§public DawnrayArcher(UUID ownerId) {§super(ownerId, 39, "Dawnray Archer", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "ALA";§this.subtype.add("Human");§this.subtype.add("Archer");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new ExaltedAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new ManaCostsImpl("{W}"));§ability.addTarget(new TargetAttackingOrBlockingCreature());§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public DawnrayArcher(final DawnrayArcher card) {§super(card);§}§@Override§public DawnrayArcher copy() {§return new DawnrayArcher(this);§}§}§
public class EtherswornCanonist extends CardImpl {§public EtherswornCanonist(UUID ownerId) {§super(ownerId, 10, "Ethersworn Canonist", Rarity.RARE, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "ALA";§this.subtype.add("Human");§this.subtype.add("Cleric");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new EtherswornCanonistReplacementEffect()), new EtherswornCanonistWatcher());§}§public EtherswornCanonist(final EtherswornCanonist card) {§super(card);§}§@Override§public EtherswornCanonist copy() {§return new EtherswornCanonist(this);§}§}§class EtherswornCanonistWatcher extends Watcher {§private Map<UUID, Boolean> castNonartifactSpell = new HashMap<>();§public EtherswornCanonistWatcher() {§super("EtherswornCanonistWatcher", WatcherScope.GAME);§}§public EtherswornCanonistWatcher(final EtherswornCanonistWatcher watcher) {§super(watcher);§for (Map.Entry<UUID, Boolean> entry: watcher.castNonartifactSpell.entrySet()) {§castNonartifactSpell.put(entry.getKey(), entry.getValue());§}§}§@Override§public void watch(GameEvent event, Game game) {§if (event.getType() == GameEvent.EventType.SPELL_CAST) {§Card card = game.getCard(event.getSourceId());§if(card != null && !card.getCardType().contains(CardType.ARTIFACT)){§UUID playerId = event.getPlayerId();§if (playerId != null) {§castNonartifactSpell.put(playerId, true);§}§}§}§}§@Override§public void reset() {§castNonartifactSpell.clear();§}§public boolean castNonArtifactSpell(UUID player){§Boolean value = castNonartifactSpell.get(player);§return value != null && value;§}§@Override§public EtherswornCanonistWatcher copy() {§return new EtherswornCanonistWatcher(this);§}§}§class EtherswornCanonistReplacementEffect extends ContinuousRuleModifyingEffectImpl {§public EtherswornCanonistReplacementEffect() {§super(Duration.WhileOnBattlefield, Outcome.Detriment);§staticText = "Each player who has cast a nonartifact spell this turn can't cast additional nonartifact spells";§}§public EtherswornCanonistReplacementEffect(final EtherswornCanonistReplacementEffect effect) {§super(effect);§}§@Override§public EtherswornCanonistReplacementEffect copy() {§return new EtherswornCanonistReplacementEffect(this);§}§@Override§public boolean checksEventType(GameEvent event, Game game) {§return event.getType() == GameEvent.EventType.CAST_SPELL;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§EtherswornCanonistWatcher watcher = (EtherswornCanonistWatcher)game.getState().getWatchers().get("EtherswornCanonistWatcher");§Card card = game.getCard(event.getSourceId());§if (card != null && !card.getCardType().contains(CardType.ARTIFACT) && watcher.castNonArtifactSpell(event.getPlayerId())) {§return true;§}§return false;§}§}§
public class GrixisPanorama extends CardImpl {§private static final FilterCard filter = new FilterCard("a basic Island, Swamp, or Mountain card");§static {§filter.add(new CardTypePredicate(CardType.LAND));§filter.add(new SupertypePredicate("Basic"));§filter.add(Predicates.or(§new SubtypePredicate("Island"),§new SubtypePredicate("Swamp"),§new SubtypePredicate("Mountain")));§}§public GrixisPanorama(UUID ownerId) {§super(ownerId, 224, "Grixis Panorama", Rarity.COMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "ALA";§this.addAbility(new ColorlessManaAbility());§TargetCardInLibrary target = new TargetCardInLibrary(filter);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new SearchLibraryPutInPlayEffect(target, true, Outcome.PutLandInPlay), new GenericManaCost(1));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public GrixisPanorama(final GrixisPanorama card) {§super(card);§}§@Override§public GrixisPanorama copy() {§return new GrixisPanorama(this);§}§}§
public class KederektLeviathan extends CardImpl {§private static final FilterNonlandPermanent filter = new FilterNonlandPermanent("all other nonland permanents");§static{§filter.add(new AnotherPredicate());§}§public KederektLeviathan(UUID ownerId) {§super(ownerId, 48, "Kederekt Leviathan", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{6}{U}{U}");§this.expansionSetCode = "ALA";§this.subtype.add("Leviathan");§this.power = new MageInt(5);§this.toughness = new MageInt(5);§this.addAbility(new EntersBattlefieldTriggeredAbility(new ReturnToHandFromBattlefieldAllEffect(filter)));§this.addAbility(new UnearthAbility(new ManaCostsImpl("{6}{U}")));§}§public KederektLeviathan(final KederektLeviathan card) {§super(card);§}§@Override§public KederektLeviathan copy() {§return new KederektLeviathan(this);§}§}§
public class Mosstodon extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature with power 5 or greater");§static {§filter.add(new PowerPredicate(ComparisonType.GreaterThan, 4));§}§public Mosstodon(UUID ownerId) {§super(ownerId, 139, "Mosstodon", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{G}");§this.expansionSetCode = "ALA";§this.subtype.add("Plant");§this.subtype.add("Elephant");§this.power = new MageInt(5);§this.toughness = new MageInt(3);§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new GainAbilityTargetEffect(TrampleAbility.getInstance(), Duration.EndOfTurn),§new ManaCostsImpl("{1}"));§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public Mosstodon(final Mosstodon card) {§super(card);§}§@Override§public Mosstodon copy() {§return new Mosstodon(this);§}§}§
public class QasaliAmbusher extends CardImpl {§public QasaliAmbusher(UUID ownerId) {§super(ownerId, 184, "Qasali Ambusher", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{G}{W}");§this.expansionSetCode = "ALA";§this.subtype.add("Cat");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(ReachAbility.getInstance());§this.addAbility(new QasaliAmbusherAbility());§}§public QasaliAmbusher(final QasaliAmbusher card) {§super(card);§}§@Override§public QasaliAmbusher copy() {§return new QasaliAmbusher(this);§}§}§class QasaliAmbusherAbility extends ActivatedAbilityImpl {§private static final FilterControlledLandPermanent filterPlains = new FilterControlledLandPermanent();§private static final FilterControlledLandPermanent filterForest = new FilterControlledLandPermanent();§static {§filterPlains.add(new SubtypePredicate("Plains"));§filterForest.add(new SubtypePredicate("Forest"));§}§public QasaliAmbusherAbility() {§super(Zone.HAND, new QasaliAmbusherEffect(), new ManaCostsImpl());§this.timing = TimingRule.INSTANT;§this.usesStack = false;§}§public QasaliAmbusherAbility(final QasaliAmbusherAbility ability) {§super(ability);§}§@Override§public QasaliAmbusherAbility copy() {§return new QasaliAmbusherAbility(this);§}§@Override§public boolean canActivate(UUID playerId, Game game) {§if (super.canActivate(playerId, game)) {§if (game.getBattlefield().getActivePermanents(filterPlains, this.getControllerId(), this.getSourceId(), game).size() > 0§&& game.getBattlefield().getActivePermanents(filterForest, this.getControllerId(), this.getSourceId(), game).size() > 0) {§for (CombatGroup group : game.getCombat().getGroups()) {§if (group.getDefenderId().equals(getControllerId())) {§return true;§}§}§}§}§return false;§}§@Override§public String getRule(boolean all) {§return this.getRule();§}§@Override§public String getRule() {§return "If a creature is attacking you and you control a Forest and a Plains, you may cast {this} without paying its mana cost and as though it had flash.";§}§}§class QasaliAmbusherEffect extends OneShotEffect {§public QasaliAmbusherEffect() {§super(Outcome.Benefit);§staticText = "";§}§public QasaliAmbusherEffect(final QasaliAmbusherEffect effect) {§super(effect);§}§@Override§public QasaliAmbusherEffect copy() {§return new QasaliAmbusherEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Card card = (Card) game.getObject(source.getSourceId());§if (card != null) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§SpellAbility spellAbility = card.getSpellAbility();§spellAbility.clear();§return controller.cast(spellAbility, game, true);§}§}§return false;§}§}§
public class SanctumGargoyle extends CardImpl {§public SanctumGargoyle(UUID ownerId) {§super(ownerId, 24, "Sanctum Gargoyle", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "ALA";§this.subtype.add("Gargoyle");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new ReturnToHandTargetEffect(), true);§ability.addTarget(new TargetCardInYourGraveyard(new FilterArtifactCard("artifact card from your graveyard")));§this.addAbility(ability);§}§public SanctumGargoyle(final SanctumGargoyle card) {§super(card);§}§@Override§public SanctumGargoyle copy() {§return new SanctumGargoyle(this);§}§}§
public class Skeletonize extends CardImpl {§public Skeletonize(UUID ownerId) {§super(ownerId, 114, "Skeletonize", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{4}{R}");§this.expansionSetCode = "ALA";§this.getSpellAbility().addEffect(new DamageTargetEffect(3));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new SkeletonizeEffect());§this.getSpellAbility().addWatcher(new DamagedByWatcher());§}§public Skeletonize(final Skeletonize card) {§super(card);§}§@Override§public Skeletonize copy() {§return new Skeletonize(this);§}§}§class SkeletonizeEffect extends OneShotEffect {§public SkeletonizeEffect() {§super(Outcome.PutCreatureInPlay);§this.staticText = "When a creature dealt damage this way dies this turn, put a 1/1 black Skeleton creature token onto the battlefield with \"{B}: Regenerate this creature\"";§}§public SkeletonizeEffect(final SkeletonizeEffect effect) {§super(effect);§}§@Override§public SkeletonizeEffect copy() {§return new SkeletonizeEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§DelayedTriggeredAbility delayedAbility = new SkeletonizeDelayedTriggeredAbility();§game.addDelayedTriggeredAbility(delayedAbility, source);§return true;§}§}§class SkeletonizeDelayedTriggeredAbility extends DelayedTriggeredAbility {§public SkeletonizeDelayedTriggeredAbility() {§super(new CreateTokenEffect(new SkeletonToken()), Duration.EndOfTurn);§}§public SkeletonizeDelayedTriggeredAbility(final SkeletonizeDelayedTriggeredAbility ability) {§super(ability);§}§@Override§public SkeletonizeDelayedTriggeredAbility copy() {§return new SkeletonizeDelayedTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.ZONE_CHANGE;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§ZoneChangeEvent zce = (ZoneChangeEvent) event;§if (zce.isDiesEvent()) {§DamagedByWatcher watcher = (DamagedByWatcher) game.getState().getWatchers().get("DamagedByWatcher", this.getSourceId());§if (watcher != null) {§return watcher.wasDamaged(zce.getTarget(), game);§}§}§return false;§}§@Override§public String getRule() {§return "When a creature dealt damage this way dies this turn, " + super.getRule();§}§}§class SkeletonToken extends Token {§SkeletonToken() {§super("Skeleton", "1/1 black Skeleton creature token with \"{B}: Regenerate this creature.\"");§this.cardType.add(CardType.CREATURE);§this.color = ObjectColor.BLACK;§this.subtype.add("Skeleton");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new ManaCostsImpl("{B}")));§}§}§
public class ThunderThrashElder extends CardImpl {§public ThunderThrashElder(UUID ownerId) {§super(ownerId, 117, "Thunder-Thrash Elder", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "ALA";§this.subtype.add("Viashino");§this.subtype.add("Warrior");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new DevourAbility(DevourFactor.Devour3));§}§public ThunderThrashElder(final ThunderThrashElder card) {§super(card);§}§@Override§public ThunderThrashElder copy() {§return new ThunderThrashElder(this);§}§}§
public class WindwrightMage extends CardImpl {§public WindwrightMage(UUID ownerId) {§super(ownerId, 208, "Windwright Mage", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{W}{U}{B}");§this.expansionSetCode = "ALA";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(LifelinkAbility.getInstance());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(§new GainAbilitySourceEffect(FlyingAbility.getInstance(), Duration.WhileOnBattlefield),§WindwrightMageCondition.getInstance(),§"{this} has flying as long as an artifact card is in your graveyard")));§}§public WindwrightMage(final WindwrightMage card) {§super(card);§}§@Override§public WindwrightMage copy() {§return new WindwrightMage(this);§}§}§class WindwrightMageCondition implements Condition {§private static WindwrightMageCondition fInstance = new WindwrightMageCondition();§private static final FilterCard filter = new FilterCard("artifact");§static {§filter.add(new CardTypePredicate(CardType.ARTIFACT));§}§public static Condition getInstance() {§return fInstance;§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§return player != null && player.getGraveyard().count(filter, game) > 0;§}§}§
public class DakmorSorceress extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("Swamps you control");§static {§filter.add(new SubtypePredicate("Swamp"));§}§public DakmorSorceress(UUID ownerId) {§super(ownerId, 74, "Dakmor Sorceress", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{B}");§this.expansionSetCode = "S99";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(0);§this.toughness = new MageInt(4);§this.addAbility(new SimpleStaticAbility(Zone.ALL, new SetPowerSourceEffect(new PermanentsOnBattlefieldCount(filter), Duration.EndOfGame)));§}§public DakmorSorceress(final DakmorSorceress card) {§super(card);§}§@Override§public DakmorSorceress copy() {§return new DakmorSorceress(this);§}§}§
public class WindSail extends CardImpl {§public WindSail(UUID ownerId) {§super(ownerId, 62, "Wind Sail", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{1}{U}");§this.expansionSetCode = "S99";§Effect effect = new GainAbilityTargetEffect(FlyingAbility.getInstance(), Duration.EndOfTurn);§effect.setText("One or two target creatures gain flying until end of turn");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetCreaturePermanent(1, 2));§}§public WindSail(final WindSail card) {§super(card);§}§@Override§public WindSail copy() {§return new WindSail(this);§}§}§
public class CorruptingLicid extends CardImpl {§public CorruptingLicid(UUID ownerId) {§super(ownerId, 4, "Corrupting Licid", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "STH";§this.subtype.add("Licid");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new LicidAbility(new ColoredManaCost(ColoredManaSymbol.B), new ColoredManaCost(ColoredManaSymbol.B)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(FearAbility.getInstance(), AttachmentType.AURA)));§}§public CorruptingLicid(final CorruptingLicid card) {§super(card);§}§@Override§public CorruptingLicid copy() {§return new CorruptingLicid(this);§}§}§
public class HermitDruid extends CardImpl {§public HermitDruid(UUID ownerId) {§super(ownerId, 58, "Hermit Druid", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "STH";§this.subtype.add("Human");§this.subtype.add("Druid");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new HermitDruidEffect(), new ManaCostsImpl("{G}"));§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public HermitDruid(final HermitDruid card) {§super(card);§}§@Override§public HermitDruid copy() {§return new HermitDruid(this);§}§}§class HermitDruidEffect extends OneShotEffect {§public HermitDruidEffect() {§super(Outcome.Benefit);§this.staticText = "Reveal cards from the top of your library until you reveal a basic land card. Put that card into your hand and all other cards revealed this way into your graveyard";§}§public HermitDruidEffect(final HermitDruidEffect effect) {§super(effect);§}§@Override§public HermitDruidEffect copy() {§return new HermitDruidEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§MageObject sourceObject= game.getObject(source.getSourceId());§if (player != null) {§Library library = player.getLibrary();§if (library.size() < 1) {§return true;§}§CardsImpl cards = new CardsImpl();§Card card;§FilterBasicLandCard filter = new FilterBasicLandCard();§do {§card = library.removeFromTop(game);§if (card != null) {§if (filter.match(card, game)) {§player.moveCards(card, Zone.LIBRARY, Zone.HAND, source, game);§} else {§cards.add(card);§}§}§} while (library.size() > 0 && card != null && !filter.match(card, game));§if (!cards.isEmpty()) {§player.moveCards(cards, Zone.LIBRARY, Zone.GRAVEYARD, source, game);§if (card != null) {§cards.add(card);§}§player.revealCards(sourceObject.getName(), cards, game);§}§return true;§}§return false;§}§}§
public class RabidRats extends CardImpl {§public RabidRats(UUID ownerId) {§super(ownerId, 17, "Rabid Rats", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "STH";§this.subtype.add("Rat");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(-1, -1, Duration.EndOfTurn), new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent(new FilterBlockingCreature()));§this.addAbility(ability);§}§public RabidRats(final RabidRats card) {§super(card);§}§@Override§public RabidRats copy() {§return new RabidRats(this);§}§}§
public class StrongholdTaskmaster extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("black creatures");§static {§filter.add(new ColorPredicate(ObjectColor.BLACK));§}§public StrongholdTaskmaster(UUID ownerId) {§super(ownerId, 22, "Stronghold Taskmaster", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{B}{B}");§this.expansionSetCode = "STH";§this.subtype.add("Giant");§this.subtype.add("Minion");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostAllEffect(-1, -1,§Duration.WhileOnBattlefield, filter, true)));§}§public StrongholdTaskmaster(final StrongholdTaskmaster card) {§super(card);§}§@Override§public StrongholdTaskmaster copy() {§return new StrongholdTaskmaster(this);§}§}§
public class AncientRunes extends CardImpl {§public AncientRunes(UUID ownerId) {§super(ownerId, 161, "Ancient Runes", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{R}");§this.expansionSetCode = "TMP";§this.addAbility(new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD, new AncientRunesDamageTargetEffect(), TargetController.ANY, false, true));§}§public AncientRunes(final AncientRunes card) {§super(card);§}§@Override§public AncientRunes copy() {§return new AncientRunes(this);§}§}§class AncientRunesDamageTargetEffect extends OneShotEffect{§public AncientRunesDamageTargetEffect()§{§super(Outcome.Damage);§}§public AncientRunesDamageTargetEffect(AncientRunesDamageTargetEffect copy)§{§super(copy);§}§@Override§public String getText(Mode mode) {§return "{this} deals damage to that player equal to the number of artifacts he or she controls";§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(targetPointer.getFirst(game, source));§if (player != null) {§int damage = game.getBattlefield().getAllActivePermanents(new FilterControlledArtifactPermanent("artifacts"), targetPointer.getFirst(game, source), game).size();§player.damage(damage, source.getSourceId(), game, false, true);§return true;§}§return false;§}§@Override§public AncientRunesDamageTargetEffect copy() {§return new AncientRunesDamageTargetEffect(this);§}§}§
public class CanopySpider extends CardImpl {§public CanopySpider(UUID ownerId) {§super(ownerId, 111, "Canopy Spider", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "TMP";§this.subtype.add("Spider");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§this.addAbility(ReachAbility.getInstance());§}§public CanopySpider(final CanopySpider card) {§super(card);§}§@Override§public CanopySpider copy() {§return new CanopySpider(this);§}§}§
public class DarkBanishing extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("nonblack creature");§static {§filter.add(Predicates.not(new ColorPredicate(ObjectColor.BLACK)));§}§public DarkBanishing(UUID ownerId) {§super(ownerId, 11, "Dark Banishing", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{B}");§this.expansionSetCode = "TMP";§this.getSpellAbility().addEffect(new DestroyTargetEffect(true));§this.getSpellAbility().addTarget(new TargetCreaturePermanent(filter));§}§public DarkBanishing(final DarkBanishing card) {§super(card);§}§@Override§public DarkBanishing copy() {§return new DarkBanishing(this);§}§}§
public class EliteJavelineer extends CardImpl {§public EliteJavelineer(UUID ownerId) {§super(ownerId, 229, "Elite Javelineer", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "TMP";§this.subtype.add("Human");§this.subtype.add("Soldier");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new BlocksTriggeredAbility(new DamageTargetEffect(1), false);§ability.addTarget(new TargetCreaturePermanent(new FilterAttackingCreature()));§this.addAbility(ability);§}§public EliteJavelineer(final EliteJavelineer card) {§super(card);§}§@Override§public EliteJavelineer copy() {§return new EliteJavelineer(this);§}§}§
public class FoolsTome extends CardImpl {§public FoolsTome(UUID ownerId) {§super(ownerId, 279, "Fool's Tome", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{4}");§this.expansionSetCode = "TMP";§Ability ability = new ConditionalActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1),§new ManaCostsImpl("{2}"), HellbentCondition.getInstance());§ability.addCost(new TapSourceCost());§this.addAbility(ability);§}§public FoolsTome(final FoolsTome card) {§super(card);§}§@Override§public FoolsTome copy() {§return new FoolsTome(this);§}§}§
public class HerosResolve extends CardImpl {§public HerosResolve(UUID ownerId) {§super(ownerId, 235, "Hero's Resolve", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{W}");§this.expansionSetCode = "TMP";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.BoostCreature));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(1, 5, Duration.WhileOnBattlefield)));§}§public HerosResolve(final HerosResolve card) {§super(card);§}§@Override§public HerosResolve copy() {§return new HerosResolve(this);§}§}§
public class Lobotomy extends CardImpl {§public Lobotomy(UUID ownerId) {§super(ownerId, 342, "Lobotomy", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{2}{U}{B}");§this.expansionSetCode = "TMP";§this.getSpellAbility().addEffect(new LobotomyEffect());§this.getSpellAbility().addTarget(new TargetPlayer());§}§public Lobotomy(final Lobotomy card) {§super(card);§}§@Override§public Lobotomy copy() {§return new Lobotomy(this);§}§}§class LobotomyEffect extends OneShotEffect {§private static final FilterCard filter = new FilterCard("card other than a basic land card");§static {§filter.add(Predicates.not(Predicates.and(new CardTypePredicate(CardType.LAND), new SupertypePredicate("Basic"))));§}§public LobotomyEffect() {§super(Outcome.Benefit);§staticText = "Target player reveals his or her hand, then you choose a card other than a basic land card from it. Search that player's graveyard, hand, and library for all cards with the same name as the chosen card and exile them. Then that player shuffles his or her library";§}§public LobotomyEffect(final LobotomyEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player targetPlayer = game.getPlayer(source.getFirstTarget());§Player controller = game.getPlayer(source.getControllerId());§MageObject sourceObject = game.getObject(source.getSourceId());§if (targetPlayer != null && sourceObject != null && controller != null) {§targetPlayer.revealCards(sourceObject.getIdName(), targetPlayer.getHand(), game);§TargetCard target = new TargetCard(Zone.HAND, filter);§target.setNotTarget(true);§Card chosenCard = null;§if (controller.chooseTarget(Outcome.Benefit, targetPlayer.getHand(), target, source, game)) {§chosenCard = game.getCard(target.getFirstTarget());§}§FilterCard filterNamedCards = new FilterCard();§if (chosenCard != null) {§filterNamedCards.add(new NamePredicate(chosenCard.getName()));§filterNamedCards.setMessage("cards named " + chosenCard.getName());§} else {§filterNamedCards.add(new NamePredicate("----")); §
public class MoggHollows extends CardImpl {§public MoggHollows(UUID ownerId) {§super(ownerId, 318, "Mogg Hollows", Rarity.UNCOMMON, new CardType[]{CardType.LAND}, null);§this.expansionSetCode = "TMP";§this.addAbility(new ColorlessManaAbility());§Ability ability = new RedManaAbility();§ability.addEffect(new DontUntapInControllersNextUntapStepSourceEffect());§this.addAbility(ability);§ability = new GreenManaAbility();§ability.addEffect(new DontUntapInControllersNextUntapStepSourceEffect());§this.addAbility(ability);§}§public MoggHollows(final MoggHollows card) {§super(card);§}§@Override§public MoggHollows copy() {§return new MoggHollows(this);§}§}§
public class Propaganda extends CardImpl {§public Propaganda(UUID ownerId) {§super(ownerId, 80, "Propaganda", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{U}");§this.expansionSetCode = "TMP";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CantAttackYouUnlessPayManaAllEffect(new ManaCostsImpl("{2}"))));§}§public Propaganda(final Propaganda card) {§super(card);§}§@Override§public Propaganda copy() {§return new Propaganda(this);§}§}§
public class RubyMedallion extends CardImpl {§private static final FilterCard filter = new FilterCard("Red spells");§static {§filter.add(new ColorPredicate(ObjectColor.RED));§}§public RubyMedallion(UUID ownerId) {§super(ownerId, 295, "Ruby Medallion", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "TMP";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new SpellsCostReductionControllerEffect(filter, 1)));§}§public RubyMedallion(final RubyMedallion card) {§super(card);§}§@Override§public RubyMedallion copy() {§return new RubyMedallion(this);§}§}§
public class ShadowRift extends CardImpl {§public ShadowRift(UUID ownerId) {§super(ownerId, 86, "Shadow Rift", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{U}");§this.expansionSetCode = "TMP";§this.getSpellAbility().addEffect(new GainAbilityTargetEffect(ShadowAbility.getInstance(), Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));§}§public ShadowRift(final ShadowRift card) {§super(card);§}§@Override§public ShadowRift copy() {§return new ShadowRift(this);§}§}§
public class SpontaneousCombustion extends CardImpl {§public SpontaneousCombustion(UUID ownerId) {§super(ownerId, 348, "Spontaneous Combustion", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{B}{R}");§this.expansionSetCode = "TMP";§this.getSpellAbility().addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent()));§this.getSpellAbility().addEffect(new DamageAllEffect(3, new FilterCreaturePermanent()));§}§public SpontaneousCombustion(final SpontaneousCombustion card) {§super(card);§}§@Override§public SpontaneousCombustion copy() {§return new SpontaneousCombustion(this);§}§}§
public class TortureChamber extends CardImpl {§public TortureChamber(UUID ownerId) {§super(ownerId, 303, "Torture Chamber", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "TMP";§this.addAbility(new OnEventTriggeredAbility(EventType.UPKEEP_STEP_PRE, "beginning of your upkeep", new AddCountersSourceEffect(CounterType.PAIN.createInstance())));§this.addAbility(new BeginningOfYourEndStepTriggeredAbility(new TortureChamberEffect1(), false));§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TortureChamberEffect2(), new GenericManaCost(1));§ability.addCost(new TapSourceCost());§ability.addCost(new TortureChamberCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public TortureChamber(final TortureChamber card) {§super(card);§}§@Override§public TortureChamber copy() {§return new TortureChamber(this);§}§}§class TortureChamberCost extends CostImpl {§private int removedCounters;§public TortureChamberCost() {§super();§this.removedCounters = 0;§this.text = "Remove all pain counters from {this}";§}§public TortureChamberCost(TortureChamberCost cost) {§super(cost);§this.removedCounters = cost.removedCounters;§}§@Override§public boolean canPay(Ability ability, UUID sourceId, UUID controllerId, Game game) {§return true;§}§@Override§public boolean pay(Ability ability, Game game, UUID sourceId, UUID controllerId, boolean noMana, Cost costToPay) {§Permanent permanent = game.getPermanent(ability.getSourceId());§if (permanent != null) {§this.removedCounters = permanent.getCounters().getCount(CounterType.PAIN);§if (this.removedCounters > 0) {§permanent.removeCounters(CounterType.PAIN.createInstance(this.removedCounters), game);§}§}§this.paid = true;§return true;§}§@Override§public TortureChamberCost copy() {§return new TortureChamberCost(this);§}§public int getRemovedCounters() {§return this.removedCounters;§}§}§class TortureChamberEffect1 extends OneShotEffect {§public TortureChamberEffect1() {§super(Outcome.Damage);§this.staticText = "{this} deals damage to you equal to the number of pain counters on it";§}§public TortureChamberEffect1(final TortureChamberEffect1 effect) {§super(effect);§}§@Override§public TortureChamberEffect1 copy() {§return new TortureChamberEffect1(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§Permanent permanent = game.getPermanent(source.getSourceId());§if (player != null && permanent != null) {§int painCounters = permanent.getCounters().getCount(CounterType.PAIN);§player.damage(painCounters, source.getSourceId(), game, false, true);§return true;§}§return false;§}§}§class TortureChamberEffect2 extends OneShotEffect {§public TortureChamberEffect2() {§super(Outcome.Damage);§this.staticText = "{this} deals damage to target creature equal to the number of pain counters removed this way";§}§public TortureChamberEffect2(final TortureChamberEffect2 effect) {§super(effect);§}§@Override§public TortureChamberEffect2 copy() {§return new TortureChamberEffect2(this);§}§@Override§public boolean apply(Game game, Ability source) {§int countersRemoved = 0;§for (Cost cost : source.getCosts()) {§if (cost instanceof TortureChamberCost) {§countersRemoved = ((TortureChamberCost) cost).getRemovedCounters();§}§}§Permanent permanent = game.getPermanent(source.getFirstTarget());§if (permanent != null) {§permanent.damage(countersRemoved, source.getSourceId(), game, false, true);§return true;§}§return false;§}§}§
public class AvengingAngel extends CardImpl {§public AvengingAngel(UUID ownerId) {§super(ownerId, 6, "Avenging Angel", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{W}{W}");§this.expansionSetCode = "TPR";§this.subtype.add("Angel");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new DiesTriggeredAbility(new AvengingAngelEffect(), true));§}§public AvengingAngel(final AvengingAngel card) {§super(card);§}§@Override§public AvengingAngel copy() {§return new AvengingAngel(this);§}§}§class AvengingAngelEffect extends OneShotEffect {§public AvengingAngelEffect() {§super(Outcome.Benefit);§this.staticText = "you may put it on the top of its owner's library";§}§public AvengingAngelEffect(final AvengingAngelEffect effect) {§super(effect);§}§@Override§public AvengingAngelEffect copy() {§return new AvengingAngelEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§Card sourceCard = game.getCard(source.getSourceId());§if (controller != null && sourceCard != null) {§if (game.getState().getZone(source.getSourceId()) == Zone.GRAVEYARD) {§controller.moveCardToLibraryWithInfo(sourceCard, source.getSourceId(), game, Zone.GRAVEYARD, true, true);§}§return true;§}§return false;§}§}§
public class Revenant extends CardImpl {§public Revenant(UUID ownerId) {§super(ownerId, 114, "Revenant", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{4}{B}");§this.expansionSetCode = "TPR";§this.subtype.add("Spirit");§this.power = new MageInt(0);§this.toughness = new MageInt(0);§this.addAbility(FlyingAbility.getInstance());§CardsInControllerGraveyardCount count = new CardsInControllerGraveyardCount(new FilterCreatureCard("creature cards"));§this.addAbility(new SimpleStaticAbility(Zone.ALL, new SetPowerToughnessSourceEffect(count, Duration.EndOfGame)));§}§public Revenant(final Revenant card) {§super(card);§}§@Override§public Revenant copy() {§return new Revenant(this);§}§}§
public class WaywardSoul extends CardImpl {§public WaywardSoul(UUID ownerId) {§super(ownerId, 78, "Wayward Soul", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{U}{U}");§this.expansionSetCode = "TPR";§this.subtype.add("Spirit");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new PutOnLibrarySourceEffect(true), new ManaCostsImpl("{U}")));§}§public WaywardSoul(final WaywardSoul card) {§super(card);§}§@Override§public WaywardSoul copy() {§return new WaywardSoul(this);§}§}§
public class BeaconOfDestruction extends CardImpl {§public BeaconOfDestruction(UUID ownerId) {§super(ownerId, 189, "Beacon of Destruction", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{3}{R}{R}");§this.expansionSetCode = "10E";§this.getSpellAbility().addEffect(new DamageTargetEffect(5));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§this.getSpellAbility().addEffect(ShuffleSpellEffect.getInstance());§}§public BeaconOfDestruction(final BeaconOfDestruction card) {§super(card);§}§@Override§public BeaconOfDestruction copy() {§return new BeaconOfDestruction(this);§}§}§
public class CrucibleOfWorlds extends CardImpl {§public CrucibleOfWorlds(UUID ownerId) {§super(ownerId, 319, "Crucible of Worlds", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "10E";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CrucibleOfWorldsEffect()));§}§public CrucibleOfWorlds(final CrucibleOfWorlds card) {§super(card);§}§@Override§public CrucibleOfWorlds copy() {§return new CrucibleOfWorlds(this);§}§}§class CrucibleOfWorldsEffect extends ContinuousEffectImpl {§public CrucibleOfWorldsEffect() {§super(Duration.WhileOnBattlefield, Layer.AbilityAddingRemovingEffects_6, SubLayer.NA, Outcome.AddAbility);§this.staticText = "You may play land cards from your graveyard";§}§public CrucibleOfWorldsEffect(final CrucibleOfWorldsEffect effect) {§super(effect);§}§@Override§public CrucibleOfWorldsEffect copy() {§return new CrucibleOfWorldsEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§for (UUID cardId: player.getGraveyard()) {§Card card = game.getCard(cardId);§if(card != null && card.getCardType().contains(CardType.LAND)){§PlayLandFromGraveyardAbility ability = new PlayLandFromGraveyardAbility(card.getName());§ability.setSourceId(cardId);§ability.setControllerId(card.getOwnerId());§game.getState().addOtherAbility(card, ability);§}§}§return true;§}§return false;§}§}§class PlayLandFromGraveyardAbility extends PlayLandAbility{§PlayLandFromGraveyardAbility(String name){§super(name);§zone = Zone.GRAVEYARD;§}§}§
public class ElvishChampion extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Elf creatures");§static {§filter.add(new SubtypePredicate("Elf"));§}§public ElvishChampion(UUID ownerId) {§super(ownerId, 261, "Elvish Champion", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{1}{G}{G}");§this.expansionSetCode = "10E";§this.subtype.add("Elf");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostAllEffect(1, 1, Duration.WhileOnBattlefield, filter, true)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAllEffect(new ForestwalkAbility(), Duration.WhileOnBattlefield, filter, true)));§}§public ElvishChampion(final ElvishChampion card) {§super(card);§}§@Override§public ElvishChampion copy() {§return new ElvishChampion(this);§}§}§
public class GoblinEliteInfantry extends CardImpl {§public GoblinEliteInfantry(UUID ownerId) {§super(ownerId, 206, "Goblin Elite Infantry", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "10E";§this.subtype.add("Goblin");§this.subtype.add("Warrior");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new BlocksOrBecomesBlockedTriggeredAbility(new BoostSourceEffect(-1, -1, Duration.EndOfTurn), false));§}§public GoblinEliteInfantry(final GoblinEliteInfantry card) {§super(card);§}§@Override§public GoblinEliteInfantry copy() {§return new GoblinEliteInfantry(this);§}§}§
public class Juggernaut extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Walls");§static {§filter.add(new SubtypePredicate("Wall"));§}§public Juggernaut(UUID ownerId) {§super(ownerId, 328, "Juggernaut", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{4}");§this.expansionSetCode = "10E";§this.subtype.add("Juggernaut");§this.power = new MageInt(5);§this.toughness = new MageInt(3);§this.addAbility(new AttacksEachTurnStaticAbility());§this.addAbility(new SimpleEvasionAbility(new CantBeBlockedByCreaturesSourceEffect(filter, Duration.WhileOnBattlefield)));§}§public Juggernaut(final Juggernaut card) {§super(card);§}§@Override§public Juggernaut copy() {§return new Juggernaut(this);§}§}§
public class MindStone extends CardImpl {§public MindStone(UUID ownerId) {§super(ownerId, 335, "Mind Stone", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "10E";§this.addAbility(new ColorlessManaAbility());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawCardSourceControllerEffect(1), new GenericManaCost(1));§ability.addCost(new TapSourceCost());§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public MindStone(final MindStone card) {§super(card);§}§@Override§public MindStone copy() {§return new MindStone(this);§}§}§
public class Puppeteer extends CardImpl {§public Puppeteer(UUID ownerId) {§super(ownerId, 98, "Puppeteer", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "10E";§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new MayTapOrUntapTargetEffect(), new ColoredManaCost(ColoredManaSymbol.U));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public Puppeteer(final Puppeteer card) {§super(card);§}§@Override§public Puppeteer copy() {§return new Puppeteer(this);§}§}§
public class RuleOfLaw extends CardImpl {§public RuleOfLaw(UUID ownerId) {§super(ownerId, 37, "Rule of Law", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{W}");§this.expansionSetCode = "10E";§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new CantCastMoreThanOneSpellEffect(TargetController.ANY)));§}§public RuleOfLaw(final RuleOfLaw card) {§super(card);§}§@Override§public RuleOfLaw copy() {§return new RuleOfLaw(this);§}§}§
public class SkyWeaver extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("white or black creature");§static {§filter.add(Predicates.or(§new ColorPredicate(ObjectColor.WHITE),§new ColorPredicate(ObjectColor.BLACK)));§}§public SkyWeaver(UUID ownerId) {§super(ownerId, 109, "Sky Weaver", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "10E";§this.subtype.add("Metathran");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilityTargetEffect(FlyingAbility.getInstance(), Duration.EndOfTurn), new GenericManaCost(2));§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public SkyWeaver(final SkyWeaver card) {§super(card);§}§@Override§public SkyWeaver copy() {§return new SkyWeaver(this);§}§}§
public class TerramorphicExpanse extends CardImpl {§public TerramorphicExpanse(UUID ownerId) {§super(ownerId, 360, "Terramorphic Expanse", Rarity.COMMON, new CardType[]{CardType.LAND}, null);§this.expansionSetCode = "10E";§this.addAbility(new TerramorphicExpanseAbility());§}§public TerramorphicExpanse(final TerramorphicExpanse card) {§super(card);§}§@Override§public TerramorphicExpanse copy() {§return new TerramorphicExpanse(this);§}§}§class TerramorphicExpanseAbility extends ActivatedAbilityImpl {§public TerramorphicExpanseAbility() {§super(Zone.BATTLEFIELD, null);§addCost(new TapSourceCost());§addCost(new SacrificeSourceCost());§TargetCardInLibrary target = new TargetCardInLibrary(new FilterBasicLandCard());§addEffect(new SearchLibraryPutInPlayEffect(target, true, Outcome.PutLandInPlay));§}§public TerramorphicExpanseAbility(final TerramorphicExpanseAbility ability) {§super(ability);§}§@Override§public TerramorphicExpanseAbility copy() {§return new TerramorphicExpanseAbility(this);§}§}§
public class ViridianShaman extends CardImpl {§private static final FilterPermanent filter = new FilterPermanent("artifact");§static {§filter.add(new CardTypePredicate(CardType.ARTIFACT));§}§public ViridianShaman(UUID ownerId) {§super(ownerId, 308, "Viridian Shaman", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "10E";§this.subtype.add("Elf");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new EntersBattlefieldTriggeredAbility(new DestroyTargetEffect(), false);§ability.addTarget(new TargetPermanent(filter));§this.addAbility(ability);§}§public ViridianShaman(final ViridianShaman card) {§super(card);§}§@Override§public ViridianShaman copy() {§return new ViridianShaman(this);§}§}§
public class Drowned extends CardImpl {§public Drowned(UUID ownerId) {§super(ownerId, 23, "Drowned", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "DRK";§this.subtype.add("Zombie");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new ManaCostsImpl("{B}")));§}§public Drowned(final Drowned card) {§super(card);§}§@Override§public Drowned copy() {§return new Drowned(this);§}§}§
public class RagMan extends CardImpl {§public RagMan(UUID ownerId) {§super(ownerId, 13, "Rag Man", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{B}{B}");§this.expansionSetCode = "DRK";§this.subtype.add("Human");§this.subtype.add("Minion");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§Ability ability = new ActivateIfConditionActivatedAbility(Zone.BATTLEFIELD, new RevealHandTargetEffect(), new ManaCostsImpl("{B}{B}{B}"), MyTurnCondition.getInstance());§ability.addCost(new TapSourceCost());§ability.addEffect(new RagManDiscardEffect());§ability.addTarget(new TargetOpponent());§this.addAbility(ability);§}§public RagMan(final RagMan card) {§super(card);§}§@Override§public RagMan copy() {§return new RagMan(this);§}§}§class RagManDiscardEffect extends OneShotEffect {§private static final FilterCreatureCard filter = new FilterCreatureCard();§public RagManDiscardEffect() {§super(Outcome.Discard);§this.staticText = "and discards a creature card at random";§}§public RagManDiscardEffect(final RagManDiscardEffect effect) {§super(effect);§}§@Override§public RagManDiscardEffect copy() {§return new RagManDiscardEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(targetPointer.getFirst(game, source));§if (player != null) {§Cards creatureCardsInHand = new CardsImpl();§for (UUID cardId : player.getHand()) {§Card card = player.getHand().get(cardId, game);§if (filter.match(card, game)) {§creatureCardsInHand.add(card);§}§}§if (!creatureCardsInHand.isEmpty()) {§Card card = creatureCardsInHand.getRandom(game);§if (card != null) {§player.discard(card, source, game);§}§}§return true;§}§return false;§}§}§
public class AnvilwroughtRaptor extends CardImpl {§public AnvilwroughtRaptor(UUID ownerId) {§super(ownerId, 211, "Anvilwrought Raptor", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{4}");§this.expansionSetCode = "THS";§this.subtype.add("Bird");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(FirstStrikeAbility.getInstance());§}§public AnvilwroughtRaptor(final AnvilwroughtRaptor card) {§super(card);§}§@Override§public AnvilwroughtRaptor copy() {§return new AnvilwroughtRaptor(this);§}§}§
public class BreachingHippocamp extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("another target creature you control");§static {§filter.add(new AnotherPredicate());§}§public BreachingHippocamp(UUID ownerId) {§super(ownerId, 43, "Breaching Hippocamp", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{U}");§this.expansionSetCode = "THS";§this.subtype.add("Horse");§this.subtype.add("Fish");§this.power = new MageInt(3);§this.toughness = new MageInt(2);§this.addAbility(FlashAbility.getInstance());§Ability ability = new EntersBattlefieldTriggeredAbility(new UntapTargetEffect(), false);§ability.addTarget(new TargetControlledCreaturePermanent(1,1,filter, false));§this.addAbility(ability);§}§public BreachingHippocamp(final BreachingHippocamp card) {§super(card);§}§@Override§public BreachingHippocamp copy() {§return new BreachingHippocamp(this);§}§}§
public class DeathbellowRaider extends CardImpl {§public DeathbellowRaider(UUID ownerId) {§super(ownerId, 117, "Deathbellow Raider", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "THS";§this.subtype.add("Minotaur");§this.subtype.add("Berserker");§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(new AttacksEachTurnStaticAbility());§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateSourceEffect(), new ManaCostsImpl("{2}{B}")));§}§public DeathbellowRaider(final DeathbellowRaider card) {§super(card);§}§@Override§public DeathbellowRaider copy() {§return new DeathbellowRaider(this);§}§}§
public class FiredrinkerSatyr extends CardImpl {§public FiredrinkerSatyr(UUID ownerId) {§super(ownerId, 122, "Firedrinker Satyr", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{R}");§this.expansionSetCode = "THS";§this.subtype.add("Satyr");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new DealtDamageToSourceTriggeredAbility(Zone.BATTLEFIELD, new FiredrinkerSatyrDealDamageEffect(), false));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostSourceEffect(1,0, Duration.EndOfTurn), new ManaCostsImpl("{1}{R}"));§Effect effect = new DamageControllerEffect(1);§effect.setText("and deals 1 damage to you");§ability.addEffect(effect);§this.addAbility(ability);§}§public FiredrinkerSatyr(final FiredrinkerSatyr card) {§super(card);§}§@Override§public FiredrinkerSatyr copy() {§return new FiredrinkerSatyr(this);§}§}§class FiredrinkerSatyrDealDamageEffect extends OneShotEffect {§public FiredrinkerSatyrDealDamageEffect() {§super(Outcome.Damage);§this.staticText = "it deals that much damage to you";§}§public FiredrinkerSatyrDealDamageEffect(final FiredrinkerSatyrDealDamageEffect effect) {§super(effect);§}§@Override§public FiredrinkerSatyrDealDamageEffect copy() {§return new FiredrinkerSatyrDealDamageEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§int amount = (Integer) getValue("damage");§if (amount > 0) {§Player player = game.getPlayer(source.getControllerId());§if (player != null) {§player.damage(amount, source.getSourceId(), game, false, true);§return true;§}§}§return false;§}§}§
public class HuntTheHunter extends CardImpl {§private static final FilterControlledCreaturePermanent filterControlledGreen = new FilterControlledCreaturePermanent("green creature you control");§private static final FilterCreaturePermanent filterOpponentGreen = new FilterCreaturePermanent("green creature an opponent controls");§static {§filterControlledGreen.add(new ColorPredicate(ObjectColor.GREEN));§filterOpponentGreen.add(new ControllerPredicate(TargetController.OPPONENT));§filterOpponentGreen.add(new ColorPredicate(ObjectColor.GREEN));§}§public HuntTheHunter(UUID ownerId) {§super(ownerId, 159, "Hunt the Hunter", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{G}");§this.expansionSetCode = "THS";§Effect effect = new BoostTargetEffect(2,2, Duration.EndOfTurn);§effect.setApplyEffectsAfter();§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetControlledCreaturePermanent(1,1,filterControlledGreen, false));§effect = new FightTargetsEffect();§effect.setText("It fights target green creature an opponent controls");§this.getSpellAbility().addEffect(effect);§Target target = new TargetCreaturePermanent(filterOpponentGreen);§this.getSpellAbility().addTarget(target);§}§public HuntTheHunter(final HuntTheHunter card) {§super(card);§}§@Override§public HuntTheHunter copy() {§return new HuntTheHunter(this);§}§}§
public class MinotaurSkullcleaver extends CardImpl {§public MinotaurSkullcleaver(UUID ownerId) {§super(ownerId, 130, "Minotaur Skullcleaver", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}");§this.expansionSetCode = "THS";§this.subtype.add("Minotaur");§this.subtype.add("Berserker");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(HasteAbility.getInstance());§this.addAbility(new EntersBattlefieldTriggeredAbility(new BoostSourceEffect(2,0, Duration.EndOfTurn)));§}§public MinotaurSkullcleaver(final MinotaurSkullcleaver card) {§super(card);§}§@Override§public MinotaurSkullcleaver copy() {§return new MinotaurSkullcleaver(this);§}§}§
public class PeakEruption extends CardImpl {§private static final FilterLandPermanent filter = new FilterLandPermanent("Mountain");§static{§filter.add(new SubtypePredicate(("Mountain")));§}§public PeakEruption(UUID ownerId) {§super(ownerId, 132, "Peak Eruption", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{2}{R}");§this.expansionSetCode = "THS";§this.getSpellAbility().addEffect(new DestroyTargetEffect());§Effect effect = new DamageTargetControllerEffect(3);§effect.setText("{this} deals 3 damage to that land's controller");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addTarget(new TargetLandPermanent(filter));§}§public PeakEruption(final PeakEruption card) {§super(card);§}§@Override§public PeakEruption copy() {§return new PeakEruption(this);§}§}§
public class ReadTheBones extends CardImpl {§public ReadTheBones(UUID ownerId) {§super(ownerId, 101, "Read the Bones", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{2}{B}");§this.expansionSetCode = "THS";§this.getSpellAbility().addEffect(new ScryEffect(2));§Effect effect = new DrawCardSourceControllerEffect(2);§effect.setText("then draw two cards");§this.getSpellAbility().addEffect(effect);§this.getSpellAbility().addEffect(new LoseLifeSourceControllerEffect(2));§}§public ReadTheBones(final ReadTheBones card) {§super(card);§}§@Override§public ReadTheBones copy() {§return new ReadTheBones(this);§}§}§
public class SilentArtisan extends CardImpl {§public SilentArtisan(UUID ownerId) {§super(ownerId, 31, "Silent Artisan", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{3}{W}{W}");§this.expansionSetCode = "THS";§this.subtype.add("Giant");§this.power = new MageInt(3);§this.toughness = new MageInt(5);§}§public SilentArtisan(final SilentArtisan card) {§super(card);§}§@Override§public SilentArtisan copy() {§return new SilentArtisan(this);§}§}§
public class ThassasBounty extends CardImpl {§public ThassasBounty(UUID ownerId) {§super(ownerId, 67, "Thassa's Bounty", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{5}{U}");§this.expansionSetCode = "THS";§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(3));§this.getSpellAbility().addEffect(new PutLibraryIntoGraveTargetEffect(3));§this.getSpellAbility().addTarget(new TargetPlayer());§}§public ThassasBounty(final ThassasBounty card) {§super(card);§}§@Override§public ThassasBounty copy() {§return new ThassasBounty(this);§}§}§
public class VulpineGoliath extends CardImpl {§public VulpineGoliath(UUID ownerId) {§super(ownerId, 183, "Vulpine Goliath", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{G}{G}");§this.expansionSetCode = "THS";§this.subtype.add("Fox");§this.power = new MageInt(6);§this.toughness = new MageInt(5);§this.addAbility(TrampleAbility.getInstance());§}§public VulpineGoliath(final VulpineGoliath card) {§super(card);§}§@Override§public VulpineGoliath copy() {§return new VulpineGoliath(this);§}§}§
public class Bewilder extends CardImpl {§public Bewilder(UUID ownerId) {§super(ownerId, 49, "Bewilder", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{U}");§this.expansionSetCode = "TSP";§this.getSpellAbility().addEffect(new BoostTargetEffect(-3, 0, Duration.EndOfTurn));§this.getSpellAbility().addTarget(new TargetCreaturePermanent());§this.getSpellAbility().addEffect(new DrawCardSourceControllerEffect(1));§}§public Bewilder(final Bewilder card) {§super(card);§}§@Override§public Bewilder copy() {§return new Bewilder(this);§}§}§
public class DeepSeaKraken extends CardImpl {§private static final FilterSpell filter = new FilterSpell("an opponent casts");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public DeepSeaKraken(UUID ownerId) {§super(ownerId, 56, "Deep-Sea Kraken", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{7}{U}{U}{U}");§this.expansionSetCode = "TSP";§this.subtype.add("Kraken");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(new CantBeBlockedSourceAbility());§this.addAbility(new SuspendAbility(9, new ManaCostsImpl("{2}{U}"), this));§this.addAbility(new ConditionalTriggeredAbility(§new SpellCastAllTriggeredAbility(Zone.EXILED, new RemoveCounterSourceEffect(CounterType.TIME.createInstance()), filter, false, SetTargetPointer.NONE), SuspendedCondition.getInstance(),§"Whenever an opponent casts a spell, if Deep-Sea Kraken is suspended, remove a time counter from it."));§}§public DeepSeaKraken(final DeepSeaKraken card) {§super(card);§}§@Override§public DeepSeaKraken copy() {§return new DeepSeaKraken(this);§}§}§
public class FlagstonesOfTrokair extends CardImpl {§private static final FilterLandCard FILTER = new FilterLandCard("Plains card");§static {§FILTER.add(new SubtypePredicate("Plains"));§}§public FlagstonesOfTrokair(UUID ownerId) {§super(ownerId, 272, "Flagstones of Trokair", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "TSP";§this.supertype.add("Legendary");§this.addAbility(new WhiteManaAbility());§this.addAbility(new PutIntoGraveFromBattlefieldSourceTriggeredAbility(new SearchLibraryPutInPlayEffect(new TargetCardInLibrary(FILTER), true, true), true));§}§public FlagstonesOfTrokair(final FlagstonesOfTrokair card) {§super(card);§}§@Override§public FlagstonesOfTrokair copy() {§return new FlagstonesOfTrokair(this);§}§}§
public class Greenseeker extends CardImpl {§public Greenseeker(UUID ownerId) {§super(ownerId, 198, "Greenseeker", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "TSP";§this.subtype.add("Elf");§this.subtype.add("Spellshaper");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new SearchLibraryPutInHandEffect(new TargetCardInLibrary(0, 1, new FilterBasicLandCard()), true, true),§new ManaCostsImpl("{G}"));§ability.addCost(new TapSourceCost());§ability.addCost(new DiscardCardCost());§this.addAbility(ability);§}§public Greenseeker(final Greenseeker card) {§super(card);§}§@Override§public Greenseeker copy() {§return new Greenseeker(this);§}§}§
public class LimDulTheNecromancer extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature an opponent controls");§private static final FilterPermanent filter2 = new FilterPermanent("Zombie");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§filter2.add(new SubtypePredicate("Zombie"));§}§public LimDulTheNecromancer(UUID ownerId) {§super(ownerId, 114, "Lim-Dul the Necromancer", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{5}{B}{B}");§this.expansionSetCode = "TSP";§this.supertype.add("Legendary");§this.subtype.add("Human");§this.subtype.add("Wizard");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(new DiesCreatureTriggeredAbility(new DoIfCostPaid(new LimDulTheNecromancerEffect(), new ManaCostsImpl("{1}{B}")), true, filter, true));§Ability ability2 = new SimpleActivatedAbility(Zone.BATTLEFIELD, new RegenerateTargetEffect(), new ManaCostsImpl("{1}{B}"));§ability2.addTarget(new TargetPermanent(filter2));§this.addAbility(ability2);§}§public LimDulTheNecromancer(final LimDulTheNecromancer card) {§super(card);§}§@Override§public LimDulTheNecromancer copy() {§return new LimDulTheNecromancer(this);§}§}§class LimDulTheNecromancerEffect extends OneShotEffect {§public LimDulTheNecromancerEffect() {§super(Outcome.PutCreatureInPlay);§staticText = "return that card to the battlefield under your control. If it's a creature, it's a Zombie in addition to its other creature types";§}§public LimDulTheNecromancerEffect(final LimDulTheNecromancerEffect effect) {§super(effect);§}§@Override§public LimDulTheNecromancerEffect copy() {§return new LimDulTheNecromancerEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Card card = game.getCard(targetPointer.getFirst(game, source));§if (card != null) {§if (controller.moveCards(card, Zone.BATTLEFIELD, source, game)§&& card.getCardType().contains(CardType.CREATURE)) {§Permanent creature = game.getPermanent(card.getId());§ContinuousEffect effect = new AddCardSubTypeTargetEffect("Zombie", Duration.WhileOnBattlefield);§effect.setTargetPointer(new FixedTarget(creature.getId()));§game.addEffect(effect, source);§}§}§return true;§}§return false;§}§}§
public class MysticalTeachings extends CardImpl {§private static final FilterCard filter = new FilterCard("an instant card or a card with flash");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.INSTANT),§new AbilityPredicate(FlashAbility.class)));§}§public MysticalTeachings(UUID ownerId) {§super(ownerId, 69, "Mystical Teachings", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{3}{U}");§this.expansionSetCode = "TSP";§this.getSpellAbility().addEffect(new SearchLibraryPutInHandEffect(new TargetCardInLibrary(filter), true, true));§this.addAbility(new FlashbackAbility(new ManaCostsImpl("{5}{B}"), TimingRule.INSTANT));§}§public MysticalTeachings(final MysticalTeachings card) {§super(card);§}§@Override§public MysticalTeachings copy() {§return new MysticalTeachings(this);§}§}§
public class PullFromEternity extends CardImpl {§private static final FilterCard filter = new FilterCard("face-up exiled card");§static {§filter.add(Predicates.not(new FaceDownPredicate()));§}§public PullFromEternity(UUID ownerId) {§super(ownerId, 35, "Pull from Eternity", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{W}");§this.expansionSetCode = "TSP";§this.getSpellAbility().addEffect(new PullFromEternityEffect());§this.getSpellAbility().addTarget(new TargetCardInExile(1,1,filter, null, true));§}§public PullFromEternity(final PullFromEternity card) {§super(card);§}§@Override§public PullFromEternity copy() {§return new PullFromEternity(this);§}§}§class PullFromEternityEffect extends OneShotEffect {§public PullFromEternityEffect() {§super(Outcome.Benefit);§this.staticText = "Put target face-up exiled card into its owner's graveyard.";§}§public PullFromEternityEffect(final PullFromEternityEffect effect) {§super(effect);§}§@Override§public PullFromEternityEffect copy() {§return new PullFromEternityEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Card card = game.getCard(getTargetPointer().getFirst(game, source));§if (card != null) {§controller.moveCards(card, Zone.EXILED, Zone.GRAVEYARD, source, game);§}§return true;§}§return false;§}§}§
public class SidewinderSliver extends CardImpl {§static final private FilterCreaturePermanent filter = new FilterCreaturePermanent("All Sliver creatures");§static{§filter.add(new SubtypePredicate("Sliver"));§}§public SidewinderSliver(UUID ownerId) {§super(ownerId, 41, "Sidewinder Sliver", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{W}");§this.expansionSetCode = "TSP";§this.subtype.add("Sliver");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAllEffect(new FlankingAbility(), Duration.WhileOnBattlefield, filter, false)));§}§public SidewinderSliver(final SidewinderSliver card) {§super(card);§}§@Override§public SidewinderSliver copy() {§return new SidewinderSliver(this);§}§}§
public class SuddenShock extends CardImpl {§public SuddenShock(UUID ownerId) {§super(ownerId, 179, "Sudden Shock", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, "{1}{R}");§this.expansionSetCode = "TSP";§this.addAbility(new SplitSecondAbility());§this.getSpellAbility().addEffect(new DamageTargetEffect(2, true));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§}§public SuddenShock(final SuddenShock card) {§super(card);§}§@Override§public SuddenShock copy() {§return new SuddenShock(this);§}§}§
public class TwoHeadedSliver extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Sliver creatures");§static {§filter.add(new SubtypePredicate("Sliver"));§}§public TwoHeadedSliver(UUID ownerId) {§super(ownerId, 183, "Two-Headed Sliver", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "TSP";§this.subtype.add("Sliver");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAllEffect(§new MenaceAbility(),§Duration.WhileOnBattlefield, filter,§"All Sliver creatures have menace. (They can't be blocked except by two or more creatures.)")));§}§public TwoHeadedSliver(final TwoHeadedSliver card) {§super(card);§}§@Override§public TwoHeadedSliver copy() {§return new TwoHeadedSliver(this);§}§}§
public class Arena extends CardImpl {§public Arena(UUID ownerId) {§super(ownerId, 117, "Arena", Rarity.SPECIAL, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "TSB";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new ArenaEffect(), new GenericManaCost(3));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetControlledCreaturePermanent());§ability.addTarget(new TargetOpponentsChoicePermanent(new FilterControlledCreaturePermanent()));§this.addAbility(ability);§}§public Arena(final Arena card) {§super(card);§}§@Override§public Arena copy() {§return new Arena(this);§}§}§class ArenaEffect extends OneShotEffect {§ArenaEffect() {§super(Outcome.Benefit);§this.staticText = "Tap target creature you control and target creature of an opponent's choice he or she controls. Those creatures fight each other.";§}§ArenaEffect(final ArenaEffect effect) {§super(effect);§}§@Override§public ArenaEffect copy() {§return new ArenaEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent creature = game.getPermanent(source.getFirstTarget());§if (creature != null) {§creature.tap(game);§}§creature = game.getPermanent(source.getTargets().get(1).getFirstTarget());§if (creature != null) {§creature.tap(game);§}§return new FightTargetsEffect().apply(game, source);§}§}§
public class KrosanCloudscraper extends CardImpl {§public KrosanCloudscraper(UUID ownerId) {§super(ownerId, 82, "Krosan Cloudscraper", Rarity.SPECIAL, new CardType[]{CardType.CREATURE}, "{7}{G}{G}{G}");§this.expansionSetCode = "TSB";§this.subtype.add("Beast");§this.subtype.add("Mutant");§this.power = new MageInt(13);§this.toughness = new MageInt(13);§this.addAbility(new BeginningOfUpkeepTriggeredAbility(new SacrificeSourceUnlessPaysEffect(new ManaCostsImpl("{G}{G}")), TargetController.YOU, false));§this.addAbility(new MorphAbility(this, new ManaCostsImpl("{7}{G}{G}")));§}§public KrosanCloudscraper(final KrosanCloudscraper card) {§super(card);§}§@Override§public KrosanCloudscraper copy() {§return new KrosanCloudscraper(this);§}§}§
public class WallOfRoots extends CardImpl {§public WallOfRoots(UUID ownerId) {§super(ownerId, 89, "Wall of Roots", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{G}");§this.expansionSetCode = "TSB";§this.subtype.add("Plant");§this.subtype.add("Wall");§this.power = new MageInt(0);§this.toughness = new MageInt(5);§this.addAbility(DefenderAbility.getInstance());§this.addAbility(new ActivateOncePerTurnManaAbility(Zone.BATTLEFIELD, new BasicManaEffect(Mana.GreenMana(1)), new WallOfRootsCost()));§}§public WallOfRoots(final WallOfRoots card) {§super(card);§}§@Override§public WallOfRoots copy() {§return new WallOfRoots(this);§}§}§class WallOfRootsCost extends CostImpl {§public WallOfRootsCost() {§this.text = "Put a -0/-1 counter on {this}";§}§public WallOfRootsCost(WallOfRootsCost cost) {§super(cost);§}§@Override§public boolean canPay(Ability ability, UUID sourceId, UUID controllerId, Game game) {§return true;§}§@Override§public boolean pay(Ability ability, Game game, UUID sourceId, UUID controllerId, boolean noMana, Cost costToPay) {§Permanent permanent = game.getPermanent(sourceId);§if (permanent != null) {§permanent.addCounters(new BoostCounter(0, -1), game);§this.paid = true;§}§return paid;§}§@Override§public WallOfRootsCost copy() {§return new WallOfRootsCost(this);§}§}§
public class CephalidIllusionist extends CardImpl {§public CephalidIllusionist(UUID ownerId) {§super(ownerId, 28, "Cephalid Illusionist", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{1}{U}");§this.expansionSetCode = "TOR";§this.subtype.add("Cephalid");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new BecomesTargetTriggeredAbility(new PutTopCardOfLibraryIntoGraveControllerEffect(3)));§Effect effect = new PreventDamageToTargetEffect(Duration.EndOfTurn, true);§effect.setText("Prevent all combat damage that would be dealt to");§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, effect, new ManaCostsImpl("{2}{U}"));§effect = new PreventDamageByTargetEffect(Duration.EndOfTurn, true);§effect.setText("and dealt by target creature you control this turn.");§ability.addEffect(effect);§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetControlledCreaturePermanent());§this.addAbility(ability);§}§public CephalidIllusionist(final CephalidIllusionist card) {§super(card);§}§@Override§public CephalidIllusionist copy() {§return new CephalidIllusionist(this);§}§}§
public class Gravegouger extends CardImpl {§public Gravegouger(UUID ownerId) {§super(ownerId, 62, "Gravegouger", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "TOR";§this.subtype.add("Nightmare");§this.subtype.add("Horror");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Effect effect = new ExileTargetForSourceEffect();§effect.setText("exile up to two target cards from a single graveyard");§Ability ability = new EntersBattlefieldTriggeredAbility(effect, false);§ability.addTarget(new TargetCardInASingleGraveyard(0, 2, new FilterCard("cards from a single graveyard")));§this.addAbility(ability);§this.addAbility(new LeavesBattlefieldTriggeredAbility(new ReturnFromExileForSourceEffect(Zone.GRAVEYARD), false));§}§public Gravegouger(final Gravegouger card) {§super(card);§}§@Override§public Gravegouger copy() {§return new Gravegouger(this);§}§}§
public class NantukoBlightcutter extends CardImpl {§private static final FilterCard filter = new FilterCard("black");§private static final FilterPermanent filter2 = new FilterPermanent();§static {§filter.add(new ColorPredicate(ObjectColor.BLACK));§filter2.add(new ColorPredicate(ObjectColor.BLACK));§filter2.add(new ControllerPredicate(TargetController.OPPONENT));§}§public NantukoBlightcutter(UUID ownerId) {§super(ownerId, 131, "Nantuko Blightcutter", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "TOR";§this.subtype.add("Insect");§this.subtype.add("Druid");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new ProtectionAbility(filter));§PermanentsOnBattlefieldCount count = new PermanentsOnBattlefieldCount(filter2);§Ability ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new ConditionalContinuousEffect(§new BoostSourceEffect(count, count, Duration.WhileOnBattlefield), new CardsInControllerGraveCondition(7),§"{this} gets +1/+1 for each black permanent your opponents control as long as seven or more cards are in your graveyard"));§ability.setAbilityWord(AbilityWord.THRESHOLD);§this.addAbility(ability);§}§public NantukoBlightcutter(final NantukoBlightcutter card) {§super(card);§}§@Override§public NantukoBlightcutter copy() {§return new NantukoBlightcutter(this);§}§}§
public class Radiate extends CardImpl {§protected static final FilterSpell filter = new FilterInstantOrSorcerySpell();§static {§filter.add(new SpellWithOnlySingleTargetPredicate());§filter.add(new SpellWithOnlyPermanentOrPlayerTargetsPredicate());§filter.setMessage("instant or sorcery spell that targets only a single permanent or player");§}§public Radiate(UUID ownerId) {§super(ownerId, 113, "Radiate", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{3}{R}{R}");§this.expansionSetCode = "TOR";§this.getSpellAbility().addEffect(new RadiateEffect());§this.getSpellAbility().addTarget(new TargetSpell(filter));§}§public Radiate(final Radiate card) {§super(card);§}§@Override§public Radiate copy() {§return new Radiate(this);§}§}§class SpellWithOnlySingleTargetPredicate implements ObjectPlayerPredicate<ObjectPlayer<Spell>> {§@Override§public boolean apply(ObjectPlayer<Spell> input, Game game) {§Spell spell = input.getObject();§if (spell == null) {§return false;§}§UUID singleTarget = null;§for (TargetAddress addr : TargetAddress.walk(spell)) {§Target targetInstance = addr.getTarget(spell);§for (UUID targetId : targetInstance.getTargets()) {§if (singleTarget == null) {§singleTarget = targetId;§} else if (!singleTarget.equals(targetId)) {§return false;§}§}§}§return singleTarget != null;§}§}§class SpellWithOnlyPermanentOrPlayerTargetsPredicate implements ObjectPlayerPredicate<ObjectPlayer<Spell>> {§@Override§public boolean apply(ObjectPlayer<Spell> input, Game game) {§Spell spell = input.getObject();§if (spell == null) {§return false;§}§for (TargetAddress addr : TargetAddress.walk(spell)) {§Target targetInstance = addr.getTarget(spell);§for (UUID targetId : targetInstance.getTargets()) {§if (game.getPermanent(targetId) == null§&& game.getPlayer(targetId) == null) {§return false;§}§}§}§return true;§}§}§class RadiateEffect extends CopySpellForEachItCouldTargetEffect<MageItem> {§public RadiateEffect() {§this(new FilterPermanentOrPlayer());§}§public RadiateEffect(RadiateEffect effect) {§super(effect);§}§private RadiateEffect(FilterInPlay<MageItem> filter) {§super(filter);§}§@Override§public String getText(Mode mode) {§return "Choose target instant or sorcery spell that targets only a single permanent or player. Copy that spell for each other permanent or player the spell could target. Each copy targets a different one of those permanents and players.";§}§@Override§protected Spell getSpell(Game game, Ability source) {§StackObject ret = game.getStack().getStackObject(targetPointer.getFirst(game, source));§if (ret instanceof Spell) {§return (Spell) ret;§}§return null;§}§@Override§protected boolean changeTarget(Target target, Game game, Ability source) {§return true;§}§@Override§protected void modifyCopy(Spell copy, Game game, Ability source) {§copy.setControllerId(source.getControllerId());§}§@Override§public RadiateEffect copy() {§return new RadiateEffect(this);§}§}§
public class VengefulDreams extends CardImpl {§public VengefulDreams(UUID ownerId) {§super(ownerId, 21, "Vengeful Dreams", Rarity.RARE, new CardType[]{CardType.INSTANT}, "{W}{W}");§this.expansionSetCode = "TOR";§this.getSpellAbility().addCost(new DiscardXTargetCost(new FilterCard("cards"), true));§Effect effect = new ExileTargetEffect();§effect.setText("Exile X target attacking creatures");§this.getSpellAbility().addEffect(effect);§}§public VengefulDreams(final VengefulDreams card) {§super(card);§}§@Override§public void adjustTargets(Ability ability, Game game) {§int xValue = new GetXValue().calculate(game, ability, null);§Target target = new TargetCreaturePermanent(0, xValue, new FilterAttackingCreature(), false);§ability.addTarget(target);§}§@Override§public VengefulDreams copy() {§return new VengefulDreams(this);§}§}§
public class Attrition extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("nonblack creature");§static {§filter.add(Predicates.not(new ColorPredicate(ObjectColor.BLACK)));§}§public Attrition(UUID ownerId) {§super(ownerId, 52, "Attrition", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{1}{B}{B}");§this.expansionSetCode = "UDS";§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DestroyTargetEffect(), new ManaCostsImpl("{B}"));§ability.addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent()));§ability.addTarget(new TargetCreaturePermanent(filter));§this.addAbility(ability);§}§public Attrition(final Attrition card) {§super(card);§}§@Override§public Attrition copy() {§return new Attrition(this);§}§}§
public class Extruder extends CardImpl {§private static final FilterControlledPermanent filter = new FilterControlledPermanent("an artifact");§static {§filter.add(new CardTypePredicate(CardType.ARTIFACT));§}§public Extruder(UUID ownerId) {§super(ownerId, 130, "Extruder", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{4}");§this.expansionSetCode = "UDS";§this.subtype.add("Juggernaut");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§this.addAbility(new EchoAbility("{4}"));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new AddCountersTargetEffect(CounterType.P1P1.createInstance()), new SacrificeTargetCost(new TargetControlledPermanent(filter)));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public Extruder(final Extruder card) {§super(card);§}§@Override§public Extruder copy() {§return new Extruder(this);§}§}§
public class MaskOfLawAndGrace extends CardImpl {§private static final FilterCard filter = new FilterCard("black and from red");§static {§filter.add(Predicates.or(new ColorPredicate(ObjectColor.BLACK), new ColorPredicate(ObjectColor.RED)));§}§public MaskOfLawAndGrace(UUID ownerId) {§super(ownerId, 11, "Mask of Law and Grace", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{W}");§this.expansionSetCode = "UDS";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(new ProtectionAbility(filter),§AttachmentType.AURA, Duration.WhileOnBattlefield)));§}§public MaskOfLawAndGrace(final MaskOfLawAndGrace card) {§super(card);§}§@Override§public MaskOfLawAndGrace copy() {§return new MaskOfLawAndGrace(this);§}§}§
public class SerraAdvocate extends CardImpl {§public SerraAdvocate(UUID ownerId) {§super(ownerId, 19, "Serra Advocate", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{3}{W}");§this.expansionSetCode = "UDS";§this.subtype.add("Angel");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BoostTargetEffect(2, 2, Duration.EndOfTurn), new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent(new FilterAttackingOrBlockingCreature()));§this.addAbility(ability);§}§public SerraAdvocate(final SerraAdvocate card) {§super(card);§}§@Override§public SerraAdvocate copy() {§return new SerraAdvocate(this);§}§}§
public class AngelicCurator extends CardImpl {§public AngelicCurator(UUID ownerId) {§super(ownerId, 1, "Angelic Curator", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "ULG";§this.subtype.add("Angel");§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new ProtectionAbility(new FilterArtifactCard("artifacts")));§}§public AngelicCurator(final AngelicCurator card) {§super(card);§}§@Override§public AngelicCurator copy() {§return new AngelicCurator(this);§}§}§
public class DerangedHermit extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("Squirrel creatures");§static {§filter.add(new SubtypePredicate("Squirrel"));§}§public DerangedHermit(UUID ownerId) {§super(ownerId, 101, "Deranged Hermit", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{G}{G}");§this.expansionSetCode = "ULG";§this.subtype.add("Elf");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new EchoAbility("{3}{G}{G}"));§this.addAbility(new EntersBattlefieldTriggeredAbility(new CreateTokenEffect(new SquirrelToken(), 4)));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostAllEffect(1, 1, Duration.WhileOnBattlefield, filter, false)));§}§public DerangedHermit(final DerangedHermit card) {§super(card);§}§@Override§public DerangedHermit copy() {§return new DerangedHermit(this);§}§}§
public class IronMaiden extends CardImpl {§public IronMaiden(UUID ownerId) {§super(ownerId, 127, "Iron Maiden", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "ULG";§Ability ability = new BeginningOfUpkeepTriggeredAbility(new IronMaidenEffect(), TargetController.OPPONENT, false);§this.addAbility(ability);§}§public IronMaiden(final IronMaiden card) {§super(card);§}§@Override§public IronMaiden copy() {§return new IronMaiden(this);§}§}§class IronMaidenEffect extends OneShotEffect {§private IronMaidenEffect(final IronMaidenEffect effect) {§super(effect);§}§public IronMaidenEffect() {§super(Outcome.Damage);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(targetPointer.getFirst(game, source));§if(player != null)§{§int amount = player.getHand().size() - 4;§if(amount > 0)§{§if (player != null) {§player.damage(amount, source.getSourceId(), game, false, true);§return true;§}§}§}§return false;§}§@Override§public IronMaidenEffect copy() {§return new IronMaidenEffect(this);§}§@Override§public String getText(Mode mode) {§return "Iron Maiden deals X damage to that player, where X is the number of cards in his or her hand minus 4";§}§}§
public class Parch extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("blue creature");§static {§filter.add(new ColorPredicate(ObjectColor.BLUE));§}§public Parch(UUID ownerId) {§super(ownerId, 86, "Parch", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{R}");§this.expansionSetCode = "ULG";§this.getSpellAbility().addEffect(new DamageTargetEffect(2));§this.getSpellAbility().addTarget(new TargetCreatureOrPlayer());§Mode mode = new Mode();§mode.getEffects().add(new DamageTargetEffect(4));§mode.getTargets().add(new TargetCreaturePermanent(filter));§this.getSpellAbility().addMode(mode);§}§public Parch(final Parch card) {§super(card);§}§@Override§public Parch copy() {§return new Parch(this);§}§}§
public class Repopulate extends CardImpl {§public Repopulate(UUID ownerId) {§super(ownerId, 111, "Repopulate", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{1}{G}");§this.expansionSetCode = "ULG";§this.getSpellAbility().addTarget(new TargetPlayer());§this.getSpellAbility().addEffect(new RepopulateEffect());§this.addAbility(new CyclingAbility(new ManaCostsImpl("{2}")));§}§public Repopulate(final Repopulate card) {§super(card);§}§@Override§public Repopulate copy() {§return new Repopulate(this);§}§}§class RepopulateEffect extends OneShotEffect {§RepopulateEffect() {§super(Outcome.Benefit);§staticText = "Shuffle all creature cards from target player's graveyard into that player's library";§}§RepopulateEffect(final RepopulateEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getFirstTarget());§if (player != null) {§Set<Card> cards = player.getGraveyard().getCards(new FilterCreatureCard(), game);§for(Card card : cards)§{§card.moveToZone(Zone.LIBRARY, source.getSourceId(), game, true);§}§player.shuffleLibrary(game);§return true;§}§return false;§}§@Override§public RepopulateEffect copy() {§return new RepopulateEffect(this);§}§}§
public class TickingGnomes extends CardImpl {§public TickingGnomes(UUID ownerId) {§super(ownerId, 136, "Ticking Gnomes", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{3}");§this.expansionSetCode = "ULG";§this.subtype.add("Gnome");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new EchoAbility("{3}"));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(1), new SacrificeSourceCost());§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public TickingGnomes(final TickingGnomes card) {§super(card);§}§@Override§public TickingGnomes copy() {§return new TickingGnomes(this);§}§}§
public class AcidicSoil extends CardImpl {§public AcidicSoil(UUID ownerId) {§super(ownerId, 172, "Acidic Soil", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{2}{R}");§this.expansionSetCode = "USG";§this.getSpellAbility().addEffect(new AcidicSoilEffect());§}§public AcidicSoil(final AcidicSoil card) {§super(card);§}§@Override§public AcidicSoil copy() {§return new AcidicSoil(this);§}§}§class AcidicSoilEffect extends OneShotEffect {§AcidicSoilEffect() {§super(Outcome.Damage);§staticText = "Acidic Soil deals damage to each player equal to the number of lands he or she controls";§}§AcidicSoilEffect(final AcidicSoilEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§List<Permanent> permanents = game.getBattlefield().getActivePermanents(new FilterLandPermanent(), source.getControllerId(), source.getSourceId(), game);§for (UUID playerId : game.getState().getPlayersInRange(source.getControllerId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§int amount = 0;§for (Permanent permanent : permanents) {§if (permanent.getControllerId().equals(playerId)) {§amount++;§}§}§if (amount > 0) {§player.damage(amount, source.getSourceId(), game, false, true);§}§}§}§return true;§}§@Override§public AcidicSoilEffect copy() {§return new AcidicSoilEffect(this);§}§}§
public class BloodVassal extends CardImpl {§public BloodVassal(UUID ownerId) {§super(ownerId, 118, "Blood Vassal", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "USG";§this.subtype.add("Thrull");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new SimpleManaAbility(Zone.BATTLEFIELD, new BasicManaEffect(Mana.BlackMana(2)), new SacrificeSourceCost()));§}§public BloodVassal(final BloodVassal card) {§super(card);§}§@Override§public BloodVassal copy() {§return new BloodVassal(this);§}§}§
public class Confiscate extends CardImpl {§public Confiscate(UUID ownerId) {§super(ownerId, 66, "Confiscate", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{4}{U}{U}");§this.expansionSetCode = "USG";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetPermanent();§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.GainControl));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ControlEnchantedEffect("permanent")));§}§public Confiscate(final Confiscate card) {§super(card);§}§@Override§public Confiscate copy() {§return new Confiscate(this);§}§}§
public class ElvishHerder extends CardImpl {§public ElvishHerder(UUID ownerId) {§super(ownerId, 247, "Elvish Herder", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{G}");§this.expansionSetCode = "USG";§this.subtype.add("Elf");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new GainAbilityTargetEffect(§TrampleAbility.getInstance(), Duration.EndOfTurn), new ManaCostsImpl("{G}"));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public ElvishHerder(final ElvishHerder card) {§super(card);§}§@Override§public ElvishHerder copy() {§return new ElvishHerder(this);§}§}§
public class Gamble extends CardImpl {§public Gamble(UUID ownerId) {§super(ownerId, 188, "Gamble", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{R}");§this.expansionSetCode = "USG";§Effect effect = new SearchLibraryPutInHandEffect(new TargetCardInLibrary(), false, true);§effect.setText("Search your library for a card, put that card into your hand");§this.getSpellAbility().addEffect(effect);§effect = new DiscardControllerEffect(1, true);§effect.setText(", discard a card at random, then shuffle your library");§this.getSpellAbility().addEffect(effect);§}§public Gamble(final Gamble card) {§super(card);§}§@Override§public Gamble copy() {§return new Gamble(this);§}§}§
public class HollowDogs extends CardImpl {§public HollowDogs(UUID ownerId) {§super(ownerId, 137, "Hollow Dogs", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{B}");§this.expansionSetCode = "USG";§this.subtype.add("Zombie");§this.subtype.add("Hound");§this.power = new MageInt(3);§this.toughness = new MageInt(3);§this.addAbility(new AttacksTriggeredAbility(new BoostSourceEffect(2, 0, Duration.EndOfTurn), false));§}§public HollowDogs(final HollowDogs card) {§super(card);§}§@Override§public HollowDogs copy() {§return new HollowDogs(this);§}§}§
public class MonkIdealist extends CardImpl {§private static final FilterCard filter = new FilterCard("enchantment card from your graveyard");§static {§filter.add(new CardTypePredicate(CardType.ENCHANTMENT));§}§public MonkIdealist(UUID ownerId) {§super(ownerId, 20, "Monk Idealist", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "USG";§this.subtype.add("Human");§this.subtype.add("Monk");§this.subtype.add("Cleric");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new EntersBattlefieldTriggeredAbility(new ReturnToHandTargetEffect(), true);§ability.addTarget(new TargetCardInYourGraveyard(filter));§this.addAbility(ability);§}§public MonkIdealist(final MonkIdealist card) {§super(card);§}§@Override§public MonkIdealist copy() {§return new MonkIdealist(this);§}§}§
public class PlanarBirth extends CardImpl {§public PlanarBirth(UUID ownerId) {§super(ownerId, 31, "Planar Birth", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{1}{W}");§this.expansionSetCode = "USG";§this.getSpellAbility().addEffect(new PlanarBirthEffect());§}§public PlanarBirth(final PlanarBirth card) {§super(card);§}§@Override§public PlanarBirth copy() {§return new PlanarBirth(this);§}§}§class PlanarBirthEffect extends OneShotEffect {§PlanarBirthEffect() {§super(Outcome.PutLandInPlay);§this.staticText = "Return all basic land cards from all graveyards to the battlefield tapped under their owners' control";§}§PlanarBirthEffect(final PlanarBirthEffect effect) {§super(effect);§}§@Override§public PlanarBirthEffect copy() {§return new PlanarBirthEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller != null) {§Cards toBattlefield = new CardsImpl();§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§toBattlefield.addAll(player.getGraveyard().getCards(new FilterBasicLandCard(), source.getSourceId(), controller.getId(), game));§}§}§controller.moveCards(toBattlefield.getCards(game), Zone.BATTLEFIELD, source, game, true, false, true, null);§return true;§}§return false;§}§}§
public class RuneOfProtectionLands extends CardImpl {§public RuneOfProtectionLands(UUID ownerId) {§super(ownerId, 39, "Rune of Protection: Lands", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{1}{W}");§this.expansionSetCode = "USG";§this.addAbility(new SimpleActivatedAbility(Zone.BATTLEFIELD, new RuneOfProtectionLandsEffect() , new ManaCostsImpl("W")));§this.addAbility(new CyclingAbility(new ManaCostsImpl("{2}")));§}§public RuneOfProtectionLands(final RuneOfProtectionLands card) {§super(card);§}§@Override§public RuneOfProtectionLands copy() {§return new RuneOfProtectionLands(this);§}§}§class RuneOfProtectionLandsEffect extends PreventionEffectImpl {§private static final FilterObject filter = new FilterObject("land source");§static {§filter.add(new CardTypePredicate(CardType.LAND));§}§private TargetSource target;§public RuneOfProtectionLandsEffect() {§super(Duration.EndOfTurn);§target = new TargetSource(filter);§staticText = "The next time a land source of your choice would deal damage to you this turn, prevent that damage";§}§public RuneOfProtectionLandsEffect(final RuneOfProtectionLandsEffect effect) {§super(effect);§this.target = effect.target.copy();§}§@Override§public RuneOfProtectionLandsEffect copy() {§return new RuneOfProtectionLandsEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public void init(Ability source, Game game) {§this.target.choose(Outcome.PreventDamage, source.getControllerId(), source.getSourceId(), game);§}§@Override§public boolean replaceEvent(GameEvent event, Ability source, Game game) {§if (event.getTargetId().equals(source.getControllerId()) && event.getSourceId().equals(target.getFirstTarget())) {§preventDamage(event, source, target.getFirstTarget(), game);§return true;§}§return false;§}§private void preventDamage(GameEvent event, Ability source, UUID target, Game game) {§GameEvent preventEvent = new GameEvent(GameEvent.EventType.PREVENT_DAMAGE, target, source.getSourceId(), source.getControllerId(), event.getAmount(), false);§if (!game.replaceEvent(preventEvent)) {§int damage = event.getAmount();§event.setAmount(0);§this.used = true;§game.fireEvent(GameEvent.getEvent(GameEvent.EventType.PREVENTED_DAMAGE, target, source.getSourceId(), source.getControllerId(), damage));§}§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (!this.used && super.applies(event, source, game)) {§if (event.getTargetId().equals(source.getControllerId()) && event.getSourceId().equals(target.getFirstTarget())) {§return true;§}§}§return false;§}§}§
public class SlipperyKarst extends CardImpl {§public SlipperyKarst(UUID ownerId) {§super(ownerId, 327, "Slippery Karst", Rarity.COMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "USG";§this.addAbility(new EntersBattlefieldTappedAbility());§this.addAbility(new GreenManaAbility());§this.addAbility(new CyclingAbility(new ManaCostsImpl("{2}")));§}§public SlipperyKarst(final SlipperyKarst card) {§super(card);§}§@Override§public SlipperyKarst copy() {§return new SlipperyKarst(this);§}§}§
public class TorchSong extends CardImpl {§public TorchSong(UUID ownerId) {§super(ownerId, 222, "Torch Song", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{2}{R}");§this.expansionSetCode = "USG";§this.addAbility(new BeginningOfUpkeepTriggeredAbility(Zone.BATTLEFIELD,§new AddCountersSourceEffect(CounterType.VERSE.createInstance(), true), TargetController.YOU, true));§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(new CountersCount(CounterType.VERSE)), new ManaCostsImpl("{2}{R}"));§ability.addCost(new SacrificeSourceCost());§ability.addTarget(new TargetCreatureOrPlayer());§this.addAbility(ability);§}§public TorchSong(final TorchSong card) {§super(card);§}§@Override§public TorchSong copy() {§return new TorchSong(this);§}§}§
public class WindingWurm extends CardImpl{§public WindingWurm(UUID ownerId) {§super(ownerId, 285, "Winding Wurm", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{4}{G}");§this.expansionSetCode = "USG";§this.subtype.add("Wurm");§this.power = new MageInt(6);§this.toughness = new MageInt(6);§this.addAbility(new EchoAbility("{4}{G}"));§}§public WindingWurm(final WindingWurm card) {§super(card);§}§@Override§public WindingWurm copy() {§return new WindingWurm(this);§}§}§
public class ChainersEdict extends CardImpl {§public ChainersEdict(UUID ownerId) {§super(ownerId, 108, "Chainer's Edict", Rarity.COMMON, new CardType[]{CardType.SORCERY}, "{1}{B}");§this.expansionSetCode = "VMA";§this.getSpellAbility().addEffect(new SacrificeEffect(new FilterCreaturePermanent(), 1, "Target player"));§this.getSpellAbility().addTarget(new TargetPlayer());§this.addAbility(new FlashbackAbility(new ManaCostsImpl("{5}{B}{B}"), TimingRule.SORCERY));§}§public ChainersEdict(final ChainersEdict card) {§super(card);§}§@Override§public ChainersEdict copy() {§return new ChainersEdict(this);§}§}§
public class HulkingGoblin extends CardImpl {§public HulkingGoblin(UUID ownerId) {§super(ownerId, 174, "Hulking Goblin", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "VMA";§this.subtype.add("Goblin");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§this.addAbility(new CantBlockAbility());§}§public HulkingGoblin(final HulkingGoblin card) {§super(card);§}§@Override§public HulkingGoblin copy() {§return new HulkingGoblin(this);§}§}§
public class ReignOfThePit extends CardImpl {§public ReignOfThePit(UUID ownerId) {§super(ownerId, 138, "Reign of the Pit", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{4}{B}{B}");§this.expansionSetCode = "VMA";§this.getSpellAbility().addEffect(new ReignOfThePitEffect());§}§public ReignOfThePit(final ReignOfThePit card) {§super(card);§}§@Override§public ReignOfThePit copy() {§return new ReignOfThePit(this);§}§}§class ReignOfThePitEffect extends OneShotEffect {§ReignOfThePitEffect() {§super(Outcome.Sacrifice);§this.staticText = "Each player sacrifices a creature. Put an X/X black Demon creature token with flying onto the battlefield, where X is the total power of the creatures sacrificed this way";§}§ReignOfThePitEffect(final ReignOfThePitEffect effect) {§super(effect);§}§@Override§public ReignOfThePitEffect copy() {§return new ReignOfThePitEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player controller = game.getPlayer(source.getControllerId());§if (controller == null) {§return false;§}§int totalPowerSacrificed = 0;§List<UUID> perms = new ArrayList<>();§for (UUID playerId : game.getState().getPlayersInRange(controller.getId(), game)) {§Player player = game.getPlayer(playerId);§if (player != null) {§TargetControlledCreaturePermanent target = new TargetControlledCreaturePermanent(1, 1, new FilterControlledCreaturePermanent(), true);§if (target.canChoose(player.getId(), game)) {§while (!target.isChosen() && player.canRespond()) {§player.choose(Outcome.Sacrifice, target, source.getSourceId(), game);§}§perms.addAll(target.getTargets());§}§}§}§for (UUID permID : perms) {§Permanent permanent = game.getPermanent(permID);§if (permanent != null) {§int power = permanent.getPower().getValue();§if (permanent.sacrifice(source.getSourceId(), game)) {§totalPowerSacrificed += power;§}§}§}§new CreateTokenEffect(new ReignOfThePitToken(totalPowerSacrificed)).apply(game, source);§return true;§}§}§class ReignOfThePitToken extends Token {§ReignOfThePitToken(int xValue) {§super("Demon", "X/X black Demon creature token with flying");§power = new MageInt(xValue);§toughness = new MageInt(xValue);§color.setBlack(true);§subtype.add("Demon");§cardType.add(CardType.CREATURE);§this.addAbility(FlyingAbility.getInstance());§}§}§
public class Betrayal extends CardImpl {§private static final FilterCreaturePermanent filter = new FilterCreaturePermanent("creature an opponent controls");§static {§filter.add(new ControllerPredicate(TargetController.OPPONENT));§}§public Betrayal(UUID ownerId) {§super(ownerId, 26, "Betrayal", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{U}");§this.expansionSetCode = "VIS";§this.subtype.add("Aura");§TargetPermanent auraTarget = new TargetCreaturePermanent(filter);§this.getSpellAbility().addTarget(auraTarget);§this.getSpellAbility().addEffect(new AttachEffect(Outcome.Detriment));§Ability ability = new EnchantAbility(auraTarget.getTargetName());§this.addAbility(ability);§this.addAbility(new BecomesTappedAttachedTriggeredAbility(new DrawCardSourceControllerEffect(1), "enchanted creature"));§}§public Betrayal(final Betrayal card) {§super(card);§}§@Override§public Betrayal copy() {§return new Betrayal(this);§}§}§
public class FreewindFalcon extends CardImpl {§private static final FilterCard filter = new FilterCard("red");§static {§filter.add(new ColorPredicate(ObjectColor.RED));§}§public FreewindFalcon(UUID ownerId) {§super(ownerId, 105, "Freewind Falcon", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{W}");§this.expansionSetCode = "VIS";§this.subtype.add("Bird");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new ProtectionAbility(filter));§}§public FreewindFalcon(final FreewindFalcon card) {§super(card);§}§@Override§public FreewindFalcon copy() {§return new FreewindFalcon(this);§}§}§
public class NaturalOrder extends CardImpl {§private static final FilterControlledCreaturePermanent filter = new FilterControlledCreaturePermanent("a green creature");§private static final FilterCreatureCard filterCard = new FilterCreatureCard("green creature card");§static {§filter.add(new ColorPredicate(ObjectColor.GREEN));§filterCard.add(new ColorPredicate(ObjectColor.GREEN));§}§public NaturalOrder(UUID ownerId) {§super(ownerId, 64, "Natural Order", Rarity.RARE, new CardType[]{CardType.SORCERY}, "{2}{G}{G}");§this.expansionSetCode = "VIS";§this.getSpellAbility().addCost(new SacrificeTargetCost(new TargetControlledCreaturePermanent(1,1,filter, true)));§this.getSpellAbility().addEffect(new SearchLibraryPutInPlayEffect(new TargetCardInLibrary(1 , filterCard), false, true));§}§public NaturalOrder(final NaturalOrder card) {§super(card);§}§@Override§public NaturalOrder copy() {§return new NaturalOrder(this);§}§}§
public class Solfatara extends CardImpl {§public Solfatara(UUID ownerId) {§super(ownerId, 93, "Solfatara", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{2}{R}");§this.expansionSetCode = "VIS";§this.getSpellAbility().addEffect(new SolfataraEffect());§this.getSpellAbility().addTarget(new TargetPlayer());§this.getSpellAbility().addEffect(new CreateDelayedTriggeredAbilityEffect(§new AtTheBeginOfNextUpkeepDelayedTriggeredAbility(new DrawCardSourceControllerEffect(1), Duration.OneUse), false));§}§public Solfatara(final Solfatara card) {§super(card);§}§@Override§public Solfatara copy() {§return new Solfatara(this);§}§}§class SolfataraEffect extends ContinuousRuleModifyingEffectImpl {§public SolfataraEffect() {§super(Duration.EndOfTurn, Outcome.Detriment);§staticText = "Target player can't play land cards this turn.";§}§public SolfataraEffect(final SolfataraEffect effect) {§super(effect);§}§@Override§public SolfataraEffect copy() {§return new SolfataraEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§return true;§}§@Override§public String getInfoMessage(Ability source, GameEvent event, Game game) {§MageObject mageObject = game.getObject(source.getSourceId());§if (mageObject != null) {§return "You can't play lands this turn (" + mageObject.getIdName() + ").";§}§return null;§}§@Override§public boolean applies(GameEvent event, Ability source, Game game) {§if (event.getType() == GameEvent.EventType.PLAY_LAND && event.getPlayerId().equals(source.getFirstTarget())) {§return true;§}§return false;§}§}§
public class Alms extends CardImpl {§public Alms(UUID ownerId) {§super(ownerId, 119, "Alms", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{W}");§this.expansionSetCode = "WTH";§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PreventDamageToTargetEffect(Duration.EndOfTurn, 1), new GenericManaCost(1));§ability.addCost(new ExileTopCardOfGraveyardCost(1));§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public Alms(final Alms card) {§super(card);§}§@Override§public Alms copy() {§return new Alms(this);§}§}§
public class DwarvenBerserker extends CardImpl {§public DwarvenBerserker(UUID ownerId) {§super(ownerId, 97, "Dwarven Berserker", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{R}");§this.expansionSetCode = "WTH";§this.subtype.add("Dwarf");§this.subtype.add("Berserker");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Effect effect = new BoostSourceEffect(3, 0, Duration.EndOfTurn);§effect.setText("it gets +3/+0");§Ability ability = new BecomesBlockedTriggeredAbility(effect, false);§effect = new GainAbilitySourceEffect(TrampleAbility.getInstance(), Duration.EndOfTurn);§effect.setText("and gains trample until end of turn");§ability.addEffect(effect);§this.addAbility(ability);§}§public DwarvenBerserker(final DwarvenBerserker card) {§super(card);§}§@Override§public DwarvenBerserker copy() {§return new DwarvenBerserker(this);§}§}§
public class LotusVale extends CardImpl {§private static final FilterControlledLandPermanent filter = new FilterControlledLandPermanent("two untapped lands");§static {§filter.add(Predicates.not(new TappedPredicate()));§}§public LotusVale(UUID ownerId) {§super(ownerId, 165, "Lotus Vale", Rarity.RARE, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "WTH";§this.addAbility(new SimpleStaticAbility(Zone.ALL, new EnterBattlefieldPayCostOrPutGraveyardEffect(§new SacrificeTargetCost(new TargetControlledPermanent(2, 2, filter, false)))));§this.addAbility(new SimpleManaAbility(Zone.BATTLEFIELD, new AddManaOfAnyColorEffect(3), new TapSourceCost()));§}§public LotusVale(final LotusVale card) {§super(card);§}§@Override§public LotusVale copy() {§return new LotusVale(this);§}§}§
public class Relearn extends CardImpl {§public static final FilterCard filter = new FilterCard("instant or sorcery card from your graveyard");§static {§filter.add(Predicates.or(§new CardTypePredicate(CardType.INSTANT),§new CardTypePredicate(CardType.SORCERY)));§}§public Relearn(UUID ownerId) {§super(ownerId, 51, "Relearn", Rarity.UNCOMMON, new CardType[]{CardType.SORCERY}, "{1}{U}{U}");§this.expansionSetCode = "WTH";§this.getSpellAbility().addEffect(new ReturnFromGraveyardToHandTargetEffect());§this.getSpellAbility().addTarget(new TargetCardInYourGraveyard(filter));§}§public Relearn(final Relearn card) {§super(card);§}§@Override§public Relearn copy() {§return new Relearn(this);§}§}§
public class VodalianIllusionist extends CardImpl {§public VodalianIllusionist(UUID ownerId) {§super(ownerId, 58, "Vodalian Illusionist", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{U}");§this.expansionSetCode = "WTH";§this.subtype.add("Merfolk");§this.subtype.add("Wizard");§this.power = new MageInt(2);§this.toughness = new MageInt(2);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PhaseOutTargetEffect(), new ManaCostsImpl("{U}{U}"));§ability.addCost(new TapSourceCost());§ability.addTarget(new TargetCreaturePermanent());§this.addAbility(ability);§}§public VodalianIllusionist(final VodalianIllusionist card) {§super(card);§}§@Override§public VodalianIllusionist copy() {§return new VodalianIllusionist(this);§}§}§
public class BojukaBog extends CardImpl {§public BojukaBog(UUID ownerId) {§super(ownerId, 132, "Bojuka Bog", Rarity.COMMON, new CardType[]{CardType.LAND}, "");§this.expansionSetCode = "WWK";§this.addAbility(new EntersBattlefieldTappedAbility());§EntersBattlefieldTriggeredAbility ability = new EntersBattlefieldTriggeredAbility(new ExileGraveyardAllTargetPlayerEffect());§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§this.addAbility(new BlackManaAbility());§}§public BojukaBog(final BojukaBog card) {§super(card);§}§@Override§public BojukaBog copy() {§return new BojukaBog(this);§}§}§
public class Dispel extends CardImpl {§private static final FilterSpell filter = new FilterSpell("instant spell");§static {§filter.add(new CardTypePredicate(CardType.INSTANT));§}§public Dispel(UUID ownerId) {§super(ownerId, 26, "Dispel", Rarity.COMMON, new CardType[]{CardType.INSTANT}, "{U}");§this.expansionSetCode = "WWK";§this.getSpellAbility().addTarget(new TargetSpell(filter));§this.getSpellAbility().addEffect(new CounterTargetEffect());§}§public Dispel(final Dispel card) {§super(card);§}§@Override§public Dispel copy() {§return new Dispel(this);§}§}§
public class HammerOfRuin extends CardImpl {§public HammerOfRuin (UUID ownerId) {§super(ownerId, 124, "Hammer of Ruin", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{2}");§this.expansionSetCode = "WWK";§this.subtype.add("Equipment");§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(2, 0)));§this.addAbility(new HammerOfRuinTriggeredAbility());§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(2)));§}§public HammerOfRuin (final HammerOfRuin card) {§super(card);§}§@Override§public HammerOfRuin copy() {§return new HammerOfRuin(this);§}§}§class HammerOfRuinTriggeredAbility extends TriggeredAbilityImpl {§HammerOfRuinTriggeredAbility() {§super(Zone.BATTLEFIELD, new DestroyTargetEffect(), true);§}§HammerOfRuinTriggeredAbility(final HammerOfRuinTriggeredAbility ability) {§super(ability);§}§@Override§public HammerOfRuinTriggeredAbility copy() {§return new HammerOfRuinTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.DAMAGED_PLAYER;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§DamagedPlayerEvent damageEvent = (DamagedPlayerEvent)event;§Permanent p = game.getPermanent(event.getSourceId());§if (damageEvent.isCombatDamage() && p != null && p.getAttachments().contains(this.getSourceId())) {§FilterPermanent filter = new FilterPermanent("Equipment that player controls");§filter.add(new SubtypePredicate("Equipment"));§filter.add(new ControllerIdPredicate(event.getPlayerId()));§filter.setMessage("creature controlled by " + game.getPlayer(event.getTargetId()).getLogName());§this.getTargets().clear();§this.addTarget(new TargetPermanent(filter));§return true;§}§return false;§}§@Override§public String getRule() {§return "Whenever equipped creature deals combat damage to a player, you may destroy target Equipment that player controls.";§}§}§
public class LodestoneGolem extends CardImpl {§public LodestoneGolem(UUID ownerId) {§super(ownerId, 127, "Lodestone Golem", Rarity.RARE, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, "{4}");§this.expansionSetCode = "WWK";§this.subtype.add("Golem");§this.power = new MageInt(5);§this.toughness = new MageInt(3);§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new LodestoneGolemCostReductionEffect()));§}§public LodestoneGolem(final LodestoneGolem card) {§super(card);§}§@Override§public LodestoneGolem copy() {§return new LodestoneGolem(this);§}§}§class LodestoneGolemCostReductionEffect extends CostModificationEffectImpl {§LodestoneGolemCostReductionEffect ( ) {§super(Duration.WhileOnBattlefield, Outcome.Benefit, CostModificationType.INCREASE_COST);§staticText = "Nonartifact spells cost {1} more to cast";§}§LodestoneGolemCostReductionEffect(LodestoneGolemCostReductionEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source, Ability abilityToModify) {§SpellAbility spellAbility = (SpellAbility) abilityToModify;§spellAbility.getManaCostsToPay().add(new GenericManaCost(1));§return true;§}§@Override§public boolean applies(Ability abilityToModify, Ability source, Game game) {§if (abilityToModify instanceof SpellAbility || abilityToModify instanceof FlashbackAbility) {§Card card = game.getCard(abilityToModify.getSourceId());§if (card != null && !card.getCardType().contains(CardType.ARTIFACT)) {§return true;§}§}§return false;§}§@Override§public LodestoneGolemCostReductionEffect copy() {§return new LodestoneGolemCostReductionEffect(this);§}§}§
public class RazorBoomerang extends CardImpl {§public RazorBoomerang(UUID ownerId) {§super(ownerId, 129, "Razor Boomerang", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, "{3}");§this.expansionSetCode = "WWK";§this.subtype.add("Equipment");§Ability gainAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new RazorBoomerangEffect(this.getId()), new TapSourceCost());§gainAbility.addCost(new UnattachCost(this.getId()));§gainAbility.addTarget(new TargetCreatureOrPlayer());§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(gainAbility, AttachmentType.EQUIPMENT)));§this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(2)));§}§public RazorBoomerang(final RazorBoomerang card) {§super(card);§}§@Override§public RazorBoomerang copy() {§return new RazorBoomerang(this);§}§}§class UnattachCost extends CostImpl {§private UUID attachmentid;§public UnattachCost(UUID attachmentid) {§this.text = "Unattach Razor Boomerang";§this.attachmentid = attachmentid;§}§public UnattachCost(UnattachCost cost) {§super(cost);§this.attachmentid = cost.attachmentid;§}§@Override§public boolean pay(Ability ability, Game game, UUID sourceId, UUID controllerId, boolean noMana, Cost costToPay) {§Permanent permanent = game.getPermanent(sourceId);§if (permanent != null) {§Permanent attachment = game.getPermanent(attachmentid);§if (attachment != null) {§permanent.removeAttachment(attachmentid, game);§this.paid = true;§}§}§return paid;§}§@Override§public boolean canPay(Ability ability, UUID sourceId, UUID controllerId, Game game) {§Permanent permanent = game.getPermanent(sourceId);§if (permanent != null) {§Permanent attachment = game.getPermanent(attachmentid);§if (attachment != null && permanent.getAttachments().contains(attachmentid)) {§return true;§}§}§return false;§}§@Override§public UnattachCost copy() {§return new UnattachCost(this);§}§}§class RazorBoomerangEffect extends OneShotEffect {§private static String text = "Razor Boomerang deals 1 damage to target creature or player. Return Razor Boomerang to its owner's hand";§private UUID attachmentid;§RazorBoomerangEffect(UUID attachmentid) {§super(Outcome.Damage);§this.attachmentid = attachmentid;§staticText = text;§}§RazorBoomerangEffect(RazorBoomerangEffect effect) {§super(effect);§this.attachmentid = effect.attachmentid;§}§@Override§public boolean apply(Game game, Ability source) {§for (UUID target : targetPointer.getTargets(game, source)) {§Permanent creature = game.getPermanent(target);§if (creature != null) {§creature.damage(1, attachmentid, game, false, true);§}§Player player = game.getPlayer(target);§if (player != null) {§player.damage(1, attachmentid, game, false, true);§}§}§Permanent razor = game.getPermanent(attachmentid);§if (razor != null) {§razor.moveToZone(Zone.HAND, id, game, true);§}§return true;§}§@Override§public RazorBoomerangEffect copy() {§return new RazorBoomerangEffect(this);§}§}§
public class SnappingCreeper extends CardImpl {§public SnappingCreeper (UUID ownerId) {§super(ownerId, 112, "Snapping Creeper", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "WWK";§this.subtype.add("Plant");§this.color.setGreen(true);§this.power = new MageInt(2);§this.toughness = new MageInt(3);§this.addAbility(new LandfallAbility(new GainAbilitySourceEffect(VigilanceAbility.getInstance(), Duration.EndOfTurn), false));§}§public SnappingCreeper (final SnappingCreeper card) {§super(card);§}§@Override§public SnappingCreeper copy() {§return new SnappingCreeper(this);§}§}§
public class VastwoodAnimist extends CardImpl {§public VastwoodAnimist(UUID ownerId) {§super(ownerId, 116, "Vastwood Animist", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{2}{G}");§this.expansionSetCode = "WWK";§this.subtype.add("Elf");§this.subtype.add("Shaman");§this.subtype.add("Ally");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new VastwoodAnimistEffect(), new TapSourceCost());§ability.addTarget(new TargetControlledPermanent(new FilterControlledLandPermanent()));§this.addAbility(ability);§}§public VastwoodAnimist(final VastwoodAnimist card) {§super(card);§}§@Override§public VastwoodAnimist copy() {§return new VastwoodAnimist(this);§}§}§class VastwoodAnimistEffect extends OneShotEffect {§final static FilterControlledPermanent filterAllies = new FilterControlledPermanent("allies you control");§static {§filterAllies.add(new SubtypePredicate("Ally"));§}§public VastwoodAnimistEffect() {§super(Outcome.Benefit);§this.staticText = "Target land you control becomes an X/X Elemental creature until end of turn, where X is the number of Allies you control. It's still a land.";§}§public VastwoodAnimistEffect(final VastwoodAnimistEffect effect) {§super(effect);§}§@Override§public VastwoodAnimistEffect copy() {§return new VastwoodAnimistEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§int amount = new PermanentsOnBattlefieldCount(filterAllies).calculate(game, source, this);§ContinuousEffect effect = new BecomesCreatureTargetEffect(new VastwoodAnimistElementalToken(amount), false, true, Duration.EndOfTurn);§effect.setTargetPointer(targetPointer);§game.addEffect(effect, source);§return false;§}§}§class VastwoodAnimistElementalToken extends Token {§VastwoodAnimistElementalToken(int amount) {§super("", "X/X Elemental creature, where X is the number of Allies you control");§cardType.add(CardType.CREATURE);§subtype.add("Elemental");§power = new MageInt(amount);§toughness = new MageInt(amount);§}§}§
public class BeastmasterAscension extends CardImpl {§public BeastmasterAscension(UUID ownerId) {§super(ownerId, 159, "Beastmaster Ascension", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, "{2}{G}");§this.expansionSetCode = "ZEN";§this.addAbility(new AttacksCreatureYouControlTriggeredAbility(new AddCountersSourceEffect(CounterType.QUEST.createInstance()), true));§this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BeastmasterAscensionEffect()));§}§public BeastmasterAscension(final BeastmasterAscension card) {§super(card);§}§@Override§public BeastmasterAscension copy() {§return new BeastmasterAscension(this);§}§}§class BeastmasterAscensionEffect extends BoostControlledEffect {§public BeastmasterAscensionEffect() {§super(5, 5, Duration.WhileOnBattlefield);§staticText = "As long as {this} has seven or more quest counters on it, creatures you control get +5/+5";§}§public BeastmasterAscensionEffect(final BeastmasterAscensionEffect effect) {§super(effect);§}§@Override§public boolean apply(Game game, Ability source) {§Permanent permanent = game.getPermanent(source.getSourceId());§if (permanent != null && permanent.getCounters().getCount(CounterType.QUEST) > 6) {§super.apply(game, source);§}§return false;§}§@Override§public BeastmasterAscensionEffect copy() {§return new BeastmasterAscensionEffect(this);§}§}§
public class CosisTrickster extends CardImpl {§public CosisTrickster(UUID ownerId) {§super(ownerId, 45, "Cosi's Trickster", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{U}");§this.expansionSetCode = "ZEN";§this.subtype.add("Merfolk");§this.subtype.add("Wizard");§this.power = new MageInt(1);§this.toughness = new MageInt(1);§this.addAbility(new CosisTricksterTriggeredAbility());§}§public CosisTrickster(final CosisTrickster card) {§super(card);§}§@Override§public CosisTrickster copy() {§return new CosisTrickster(this);§}§}§class CosisTricksterTriggeredAbility extends TriggeredAbilityImpl {§public CosisTricksterTriggeredAbility() {§super(Zone.BATTLEFIELD, new AddCountersSourceEffect(CounterType.P1P1.createInstance()), true);§}§public CosisTricksterTriggeredAbility(final CosisTricksterTriggeredAbility ability) {§super(ability);§}§@Override§public CosisTricksterTriggeredAbility copy() {§return new CosisTricksterTriggeredAbility(this);§}§@Override§public boolean checkEventType(GameEvent event, Game game) {§return event.getType() == EventType.LIBRARY_SHUFFLED;§}§@Override§public boolean checkTrigger(GameEvent event, Game game) {§return game.getOpponents(controllerId).contains(event.getPlayerId());§}§@Override§public String getRule() {§return "Whenever an opponent shuffles his or her library, you may put a +1/+1 counter on {this}.";§}§}§
public class GiantScorpion extends CardImpl {§public GiantScorpion(UUID ownerId) {§super(ownerId, 90, "Giant Scorpion", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{B}");§this.expansionSetCode = "ZEN";§this.subtype.add("Scorpion");§this.power = new MageInt(1);§this.toughness = new MageInt(3);§this.addAbility(DeathtouchAbility.getInstance());§}§public GiantScorpion(final GiantScorpion card) {§super(card);§}§@Override§public GiantScorpion copy() {§return new GiantScorpion(this);§}§}§
public class HedronCrab extends CardImpl {§public HedronCrab(UUID ownerId) {§super(ownerId, 47, "Hedron Crab", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{U}");§this.expansionSetCode = "ZEN";§this.subtype.add("Crab");§this.power = new MageInt(0);§this.toughness = new MageInt(2);§LandfallAbility ability = new LandfallAbility(new PutLibraryIntoGraveTargetEffect(3), false);§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public HedronCrab(final HedronCrab card) {§super(card);§}§@Override§public HedronCrab copy() {§return new HedronCrab(this);§}§}§
public class KhalniHeartExpedition extends CardImpl {§public KhalniHeartExpedition(UUID ownerId) {§super(ownerId, 167, "Khalni Heart Expedition", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, "{1}{G}");§this.expansionSetCode = "ZEN";§this.addAbility(new LandfallAbility(new AddCountersSourceEffect(CounterType.QUEST.createInstance()), true));§TargetCardInLibrary target = new TargetCardInLibrary(0, 2, new FilterBasicLandCard());§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new SearchLibraryPutInPlayEffect(target, true, Outcome.PutLandInPlay),§new RemoveCountersSourceCost(CounterType.QUEST.createInstance(3)));§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public KhalniHeartExpedition(final KhalniHeartExpedition card) {§super(card);§}§@Override§public KhalniHeartExpedition copy() {§return new KhalniHeartExpedition(this);§}§}§
public class MalakirBloodwitch extends CardImpl {§private static final FilterCard filter = new FilterCard("white");§static {§filter.add(new ColorPredicate(ObjectColor.WHITE));§}§public MalakirBloodwitch(UUID ownerId) {§super(ownerId, 100, "Malakir Bloodwitch", Rarity.RARE, new CardType[]{CardType.CREATURE}, "{3}{B}{B}");§this.expansionSetCode = "ZEN";§this.subtype.add("Vampire");§this.subtype.add("Shaman");§this.power = new MageInt(4);§this.toughness = new MageInt(4);§this.addAbility(FlyingAbility.getInstance());§this.addAbility(new ProtectionAbility(filter));§this.addAbility(new EntersBattlefieldTriggeredAbility(new MalakirBloodwitchEffect(), false));§}§public MalakirBloodwitch(final MalakirBloodwitch card) {§super(card);§}§@Override§public MalakirBloodwitch copy() {§return new MalakirBloodwitch(this);§}§}§class MalakirBloodwitchEffect extends OneShotEffect {§public MalakirBloodwitchEffect() {§super(Outcome.Benefit);§this.staticText = "each opponent loses life equal to the number of Vampires you control. You gain life equal to the life lost this way";§}§public MalakirBloodwitchEffect(final MalakirBloodwitchEffect effect) {§super(effect);§}§@Override§public MalakirBloodwitchEffect copy() {§return new MalakirBloodwitchEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§Player player = game.getPlayer(source.getControllerId());§if (player == null) {§return false;§}§FilterControlledPermanent filter = new FilterControlledPermanent("Vampire");§filter.add(new SubtypePredicate("Vampire"));§int amount = game.getBattlefield().countAll(filter, source.getControllerId(), game);§Set<UUID> opponents = game.getOpponents(source.getControllerId());§int total = 0;§for (UUID opponentUuid : opponents) {§Player opponent = game.getPlayer(opponentUuid);§if (opponent != null) {§total += opponent.loseLife(amount, game);§}§if (total > 0) {§player.gainLife(total, game);§}§}§return true;§}§}§
public class NobleVestige extends CardImpl {§public NobleVestige(UUID ownerId) {§super(ownerId, 29, "Noble Vestige", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{W}");§this.expansionSetCode = "ZEN";§this.subtype.add("Spirit");§this.power = new MageInt(1);§this.toughness = new MageInt(2);§this.addAbility(FlyingAbility.getInstance());§Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PreventDamageToTargetEffect(Duration.EndOfTurn, 1), new TapSourceCost());§ability.addTarget(new TargetPlayer());§this.addAbility(ability);§}§public NobleVestige(final NobleVestige card) {§super(card);§}§@Override§public NobleVestige copy() {§return new NobleVestige(this);§}§}§
public class QuestForTheGravelord extends CardImpl {§public QuestForTheGravelord(UUID ownerId) {§super(ownerId, 108, "Quest for the Gravelord", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, "{B}");§this.expansionSetCode = "ZEN";§this.addAbility(new DiesCreatureTriggeredAbility(new AddCountersSourceEffect(CounterType.QUEST.createInstance()), true));§SimpleActivatedAbility ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,§new CreateTokenEffect(new ZombieToken()),§new RemoveCountersSourceCost(CounterType.QUEST.createInstance(3)));§ability.addCost(new SacrificeSourceCost());§this.addAbility(ability);§}§public QuestForTheGravelord(final QuestForTheGravelord card) {§super(card);§}§@Override§public QuestForTheGravelord copy() {§return new QuestForTheGravelord(this);§}§}§class ZombieToken extends Token {§public ZombieToken() {§super("Zombie Giant", "5/5 black Zombie Giant creature token");§cardType.add(CardType.CREATURE);§subtype.add("Zombie");§subtype.add("Giant");§color.setBlack(true);§power = new MageInt(5);§toughness = new MageInt(5);§}§}§
public class ShatterskullGiant extends CardImpl {§public ShatterskullGiant(UUID ownerId) {§super(ownerId, 148, "Shatterskull Giant", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{2}{R}{R}");§this.expansionSetCode = "ZEN";§this.subtype.add("Giant");§this.subtype.add("Warrior");§this.power = new MageInt(4);§this.toughness = new MageInt(3);§}§public ShatterskullGiant(final ShatterskullGiant card) {§super(card);§}§@Override§public ShatterskullGiant copy() {§return new ShatterskullGiant(this);§}§}§
public class SurrakarMarauder extends CardImpl {§public SurrakarMarauder(UUID ownerId) {§super(ownerId, 113, "Surrakar Marauder", Rarity.COMMON, new CardType[]{CardType.CREATURE}, "{1}{B}");§this.expansionSetCode = "ZEN";§this.subtype.add("Surrakar");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(new LandfallAbility(new GainAbilitySourceEffect(IntimidateAbility.getInstance(), Duration.EndOfTurn), false));§}§public SurrakarMarauder(final SurrakarMarauder card) {§super(card);§}§@Override§public SurrakarMarauder copy() {§return new SurrakarMarauder(this);§}§}§
public class VampireHexmage extends CardImpl {§public VampireHexmage(UUID ownerId) {§super(ownerId, 114, "Vampire Hexmage", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, "{B}{B}");§this.expansionSetCode = "ZEN";§this.subtype.add("Vampire");§this.subtype.add("Shaman");§this.power = new MageInt(2);§this.toughness = new MageInt(1);§this.addAbility(FirstStrikeAbility.getInstance());§SimpleActivatedAbility vampireHexmageAbility = new SimpleActivatedAbility(Zone.BATTLEFIELD, new VampireHexmageEffect(), new SacrificeSourceCost());§vampireHexmageAbility.addTarget(new TargetPermanent());§this.addAbility(vampireHexmageAbility);§}§public VampireHexmage(final VampireHexmage card) {§super(card);§}§@Override§public VampireHexmage copy() {§return new VampireHexmage(this);§}§}§class VampireHexmageEffect extends OneShotEffect {§VampireHexmageEffect ( ) {§super(Outcome.Benefit);§staticText = "Remove all counters from target permanent";§}§VampireHexmageEffect ( VampireHexmageEffect effect ) {§super(effect);§}§@Override§public VampireHexmageEffect copy() {§return new VampireHexmageEffect(this);§}§@Override§public boolean apply(Game game, Ability source) {§TargetPermanent target = (TargetPermanent)source.getTargets().get(0);§Permanent permanent = game.getPermanent(target.getFirstTarget());§if (permanent != null) {§for(Counter counter : permanent.getCounters().values()){§permanent.removeCounters(counter, game);§}§return true;§}§return false;§}§}§
